<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[体味RxJava2.0(一)]]></title>
      <url>http://yoursite.com/2017/01/06/%E4%BD%93%E5%91%B3rxjava2.0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Rxjava2.0也发布了一段时间了。然后看到一些小的不同，就跟大大们分享一下，如果有什么不合适的就直接☞（指出）哈！</p>
<h3 id="2-0的模式"><a href="#2-0的模式" class="headerlink" title="2.0的模式"></a>2.0的模式</h3><p>在1.0中就提到过rxjava使用的是观察者模式，在2.0中仍然么有改变。但是在2.0中为了解决1.0中的一个不完善的问题——Backpressure（背压）,支持了两种不同的观察者模式。</p>
<ul>
<li>Observable(被观察者)/Observer（观察者）</li>
<li>Flowable(被观察者)/Subscriber(观察者)</li>
</ul>
<p><img src="https://dn-mhke0kuv.qbox.me/1cfc1779f2a93ad2f7c8.png" alt="观察者模式"></p>
<p>在2.0中专门对背压或者不背压进行了区分。如果是不背压就使用第一种方式，如果是背压就使用第二种方式。<br><strong>注意：Obsesrver用于订阅Observable，而Subscriber用于订阅Flowable</strong></p>
<h3 id="背压策略"><a href="#背压策略" class="headerlink" title="背压策略"></a>背压策略</h3><p>说了那么多，那什么是背压，被压其实就是一种策略。在1.0中，我们就知道被观察者发送一个事件，观察者就处理一个事件，一直到onError()或者onCompleted()。那么，这样就产生了一个问题：如果被观察者的发送速度大于观察的处理速度，那么就会在内存中堆积，当堆积的数量达到了128，就会抛出</p>
<pre><code>Caused by: rx.exceptions.MissingBackpressureException
</code></pre><p>的异常。在2.0中就不会出现这中问题，如果仍然使用上面的<strong> Observable(被观察者)/Observer（观察者）</strong>方式，在达到128的时候，也不会抛出这个异常，它会继续堆积，直到OutOfMemoryError(内存溢出)<br>那么就借用大神的一句话来总结一下背压<br><strong>背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略</strong></p>
<h3 id="Observer-Subscriber（观察者）"><a href="#Observer-Subscriber（观察者）" class="headerlink" title="Observer/Subscriber（观察者）"></a>Observer/Subscriber（观察者）</h3><p>从上面我们可以知道，支持背压和不支持背压是通过下游（观察者）通知上游（被观察者），先得了解一下观察者的变化：</p>
<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;Integer&gt; observer = <span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Log.d(TAG,value+<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(TAG,<span class="string">"compeleted.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Observable.range(<span class="number">1</span>,<span class="number">5</span>).subscribe(observer);</span><br></pre></td></tr></table></figure>
<p>可以看到在2.0中对Observer增加了一个 <strong>onSubscribe(Disposable d)</strong> 的方法。这个方法是在执行订阅之后发送数据之前会调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Represents a disposable resource.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Dispose the resource, the operation should be idempotent.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns true if this resource has been disposed.</span><br><span class="line">     * <span class="doctag">@return</span> true if this resource has been disposed</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在订阅时将一个Disposable传入观察者，这个Disposable其实就是Subscription，可以用于取消订阅。<br><strong>dispose() 用于取消订阅</strong><br>比如，将上面的onSubscribe()和onNext()更改一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> Disposable disposable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"Disposable---&gt;&gt;&gt;&gt;"</span>);</span><br><span class="line">    disposable = d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">3</span>)</span><br><span class="line">        disposable.dispose();</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         Log.d(TAG, value + <span class="string">""</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>结果就会输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onNext---&gt;<span class="number">1</span></span><br><span class="line">onNext---&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>后面的几个数字就不能被发出了。<br>那么问题来了：<br><strong>1. 可以看出上面被终止之后没有打印onError()或者onCompleted(),这是为什么呢？</strong><br><strong>2. 如果我想恢复继续发送呢，这个时候该怎么办呢？</strong><br>对于1，disposable.dispose()取消订阅，就相当于说，观察者已经不再订阅被观察者了，所以不论被观察者是什么情况，观察者都不再执行任何操作！<br>对于2， 取消订阅意味着我跟你无关了，只能重新订阅~~</p>
<h4 id="Subscriber"><a href="#Subscriber" class="headerlink" title="Subscriber"></a>Subscriber</h4><p>先看一下2.0中神秘的Subscriber：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;Integer&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">               Log.d(TAG, <span class="string">"onNext---&gt;&gt;&gt;&gt;"</span>+integer);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出和Observer一样，都有一个onSubscribe(Subscription s)的方法，都是在订阅之后发送数据之前调用的，来看看Subscription<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这其中只有两个方法<strong>request(long n)</strong> 和 <strong>cancel()</strong></p>
<p><strong>cancel()</strong><br>就是取消订阅，这个没商量，跟上面的Observer一样。<br><strong>request(long n)</strong>     </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1978544-d4527e27f47f3dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flowable.png"></p>
<p>结合上图，当我们订阅之后    </p>
<pre><code>Flowable.range(1,10).subscribe(subscriber)；
</code></pre><p>这时你会发现怎么一个值都不打印，这是因为观察者没有告诉被观察者到底发送几个，所以我们将Subscriber这样修改(<strong>这时就会用到request(n)</strong>)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;Integer&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">           Subscription sub;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">               Log.d(TAG, <span class="string">"onSubscribe---&gt;&gt;&gt;&gt;"</span>);</span><br><span class="line">               sub = s;</span><br><span class="line">               s.request(<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">               Log.d(TAG, <span class="string">"onNext---&gt;&gt;&gt;&gt;"</span>+integer);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">               Log.d(TAG, <span class="string">"onError---&gt;&gt;&gt;&gt;"</span>+t.getMessage());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               Log.d(TAG, <span class="string">"onComplete---&gt;&gt;&gt;&gt;"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样修改之后，你会发现只是打印了一个值，后面的值都没有打印处理，这是因为打印完成一个之后，必须继续以这种方式告诉被观察者你下一次需要几个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;Integer&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">          Subscription sub;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">              Log.d(TAG, <span class="string">"onSubscribe---&gt;&gt;&gt;&gt;"</span>);</span><br><span class="line">              sub = s;</span><br><span class="line">              s.request(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">              Log.d(TAG, <span class="string">"onNext---&gt;&gt;&gt;&gt;"</span>+integer);</span><br><span class="line">              sub.request(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">              Log.d(TAG, <span class="string">"onError---&gt;&gt;&gt;&gt;"</span>+t.getMessage());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              Log.d(TAG, <span class="string">"onComplete---&gt;&gt;&gt;&gt;"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>
<p>我们结合上图综合来看，当订阅之后，首先在onSubscribe(Subscription s)方法中调用了 <strong>s.request(1)</strong>，我们说了onSubscribe(Subscription s)会在订阅后发送数据前调用，所以这里面先<strong>request(1)</strong><br>，在onNext()的<strong>sub.request(1)</strong>，这个就是告诉被观察者，我下次需要1个,然后就向下send(1),依次继续打印，就打印完成所有~~。</p>
<h3 id="Observable-Flowable-被观察者"><a href="#Observable-Flowable-被观察者" class="headerlink" title="Observable/Flowable(被观察者)"></a>Observable/Flowable(被观察者)</h3><p>对于Observable我们已经比较了解了，但是在2.0中也有些许不同</p>
<h4 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.x Observable</span></span><br><span class="line"> Observable&lt;Integer&gt; observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                emitter.onNext(<span class="number">1</span>);</span><br><span class="line">                emitter.onNext(<span class="number">2</span>);</span><br><span class="line">                emitter.onNext(<span class="number">3</span>);</span><br><span class="line">                emitter.onNext(<span class="number">4</span>);</span><br><span class="line">                emitter.onComplete();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Flowable"><a href="#Flowable" class="headerlink" title="Flowable"></a>Flowable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               emitter.onNext(<span class="number">1</span>);</span><br><span class="line">               emitter.onNext(<span class="number">2</span>);</span><br><span class="line">               emitter.onNext(<span class="number">3</span>);</span><br><span class="line">               emitter.onNext(<span class="number">4</span>);</span><br><span class="line">               emitter.onComplete();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, BackpressureStrategy.BUFFER).subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<p>从上面看出，两种被观察者的写法差不多，但是Flowable多了一个BackpressureStrategy.BUFFER的参数，仅此而已。</p>
<p>那么BackpressureStrategy到底是什么？</p>
<h4 id="BackpressureStrategy"><a href="#BackpressureStrategy" class="headerlink" title="BackpressureStrategy"></a>BackpressureStrategy</h4><p>BackpressureStrategy是背压的策略，有几种方式：   </p>
<ul>
<li><strong>MISSING</strong>  不会缓存数据和删除数据，那么下游必须处理溢出</li>
<li><strong>ERROR</strong>    下游处理事件的速度和上游发送速度不均衡的时候抛出MissingBackpressureException</li>
<li><strong>BUFFER</strong> 把上游收到的全部缓存下来，等下游来请求再发给下游</li>
<li><strong>DROP</strong> 丢弃存不下的数据</li>
<li><strong>LATEST</strong>    一直保留最新的数据</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>http://yoursite.com/2016/07/01/Rx%E7%B3%BB%E5%88%97%E4%B9%8BRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h2 id="Rx系列之RxJava操作符"><a href="#Rx系列之RxJava操作符" class="headerlink" title="Rx系列之RxJava操作符"></a>Rx系列之RxJava操作符</h2><p>在前面一章节中，讲解了Rxjava的基本的组成，他们之间的关系，这一章，主要让大家了解一下在RxJava中的操作符。但是在这之前，我们还得先了解一下 Scheduler(调度器) </p>
<h3 id="Scheduler-调度器"><a href="#Scheduler-调度器" class="headerlink" title="Scheduler(调度器)"></a>Scheduler(调度器)</h3><p>在上一章节，我们讲到了，Rxjava的就是<strong>异步</strong>。<br>那么如何让他进行异步呢？这就要用到我们的调度器了。<br>先看看RxJava中调度器支持哪几种调度：</p>
<table>
<thead>
<tr>
<th style="text-align:center">调度器类型</th>
<th style="text-align:center">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Schedulers.computation( )</td>
<td style="text-align:center">用于计算任务，如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量</td>
</tr>
<tr>
<td style="text-align:center">Schedulers.from(executor)</td>
<td style="text-align:center">使用指定的Executor作为调度器</td>
</tr>
<tr>
<td style="text-align:center">Schedulers.immediate( )</td>
<td style="text-align:center">在当前线程立即开始执行任务</td>
</tr>
<tr>
<td style="text-align:center">Schedulers.io( )</td>
<td style="text-align:center">用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器</td>
</tr>
<tr>
<td style="text-align:center">Schedulers.newThread( )</td>
<td style="text-align:center">为每个任务创建一个新线程</td>
</tr>
<tr>
<td style="text-align:center">Schedulers.trampoline( )</td>
<td style="text-align:center">当其它排队的任务完成后，在当前线程排队开始执行</td>
</tr>
</tbody>
</table>
<p>有了上述所说的几种调度之后，就可以调用subscribeOn()和observeOn()来对线程进行调度了。<br><strong>subscribeOn()指定：Observable将全部的处理过程（包括发射数据和通知）放在特定的调度器上执行。</strong><br><strong>ObserveOn()指定：一个Observable在一个特定的调度器上调用观察者的onNext, onError和onCompleted方法，</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Subscriber subcriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onCompleted: Completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onError: Error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onNext: "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Observable.just(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(subcriber);</span><br></pre></td></tr></table></figure>
<p><strong>上面这段代码中，由于指定了1，2，3，4发射代码为Schedulers.io()，那么发射数据就将在io线程中执行。而onNext, onError和onCompleted则将在主线中执行。</strong></p>
<h3 id="Operators-操作符"><a href="#Operators-操作符" class="headerlink" title="Operators(操作符)"></a>Operators(操作符)</h3><h4 id="map家族"><a href="#map家族" class="headerlink" title="map家族"></a>map家族</h4><p>RxJava提供了几个mapping函数：map(),flatMap(),concatMap(),flatMapIterable()以及switchMap().所有这些函数都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。</p>
<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>map 是用于变换的一个操作符，这在RxJava中占据了一定的地位，就是因为它的变换操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Subscriber subcriber = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onCompleted: Completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onError: Error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onNext: "</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Observable.just(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .map(<span class="keyword">new</span> Func1&lt;String, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(subcriber);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我通过map将字符串转化成了整形的1，2，3，4，返回一个Observable的对象。<br><strong>请注意：这个操作符默认不在任何特定的调度器上执行。</strong>   </p>
<h5 id="flatmap"><a href="#flatmap" class="headerlink" title="flatmap"></a>flatmap</h5><p>flatmap对于新入门的来说，理解起来确实有一定的难度，可以先看一个简单的栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Subscriber subcriber = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onCompleted: Completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onError: Error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onNext: "</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Observable.just(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;String, Observable&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;Integer&gt; <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Observable.just(Integer.parseInt(s)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(subcriber);</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看出，<strong>map与flatmap很相似，都是用的Func1，而且模式都是<i,o>模式，即是：I转换成O并返回。但是最大的不同点在于：我们flatmap的输出类型是Observable的类型。<br>在这里请注意一个问题：在执行flatmap中返回之后(O输出返回的Observable)，并不是立马把返回的Observable通过Subscribe进行订阅，而是将返回的若干Observables都交给同一个Observable，然后再进行subscribe。</i,o></strong></p>
<p>所以，在上面我们先将字符串”1”,”2”, “3”, “4” 分别转换成一个整形的Observable类型，即是：Observable(2),Observable(3),Observable(4),Observable(5)。然后将这些个Observables统一转换成一个Observable，再进行subscribe。看一下结果：</p>
<pre><code>onNext: 2
onNext: 3
onNext: 4
onNext: 5
onCompleted: Completed!
</code></pre><p><strong>那么，这个flatmap到底有何用呢？可以用在什么地方呢？</strong>   </p>
<p>假设这样一种情景：一个学校的老师我们定义为一个集合A，每个老师包括了个人信息和所教课程，一个老师不可能只教授一门课程，所以我们将老师所教授课程定义为集合B。如果让你打印每个老师所教课程，该怎么做？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Teacher[] teachers = ...;</span><br><span class="line">Subscriber&lt;Course&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Course&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Course course)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, course.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Observable.from(teachers)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;Teacher, Observable&lt;Course&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;Course&gt; <span class="title">call</span><span class="params">(Teacher teacher)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.from(teacher.getCourses());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<p><strong>最后再补充一点：FlatMap对这些Observables发射的数据做的是合并(merge)操作，因此它们可能是交错的。这意味着flatMap()函数在最后的Observable中不能够保证源Observables确切的发射顺序。</strong></p>
<h5 id="ConcatMap"><a href="#ConcatMap" class="headerlink" title="ConcatMap"></a>ConcatMap</h5><p>RxJava的concatMap()函数解决了flatMap()的交叉问题，提供了一种能够把发射的值连续在一起的铺平函数，而不是合并它们，如下图所示：<br><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_3.png" alt="ConcatMap示意图"><br>变换的操作符还有很多：buffer,Scan…等等，大家可以研究一下。</p>
<h4 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h4><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><p><strong>让你发射的数据重复发射</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Subscriber subcriber = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Observable.just(<span class="string">"1"</span>, <span class="string">"2"</span>,<span class="string">"3"</span>)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;String, Observable&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;Integer&gt; <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Observable.just(Integer.parseInt(s)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .repeat(<span class="number">3</span>)</span><br><span class="line">        .subscribe(subcriber);</span><br></pre></td></tr></table></figure>
<p>看一下结果：</p>
<pre><code>onNext: 2
onNext: 3
onNext: 4
onNext: 2
onNext: 3
onNext: 4
onNext: 2
onNext: 3
onNext: 4
onCompleted: Completed!
</code></pre><h5 id="range"><a href="#range" class="headerlink" title="range"></a>range</h5><p><strong>从起始点开始发射数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Subscriber subcriber = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Observable.range(<span class="number">10</span>,<span class="number">3</span>)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(subcriber);</span><br></pre></td></tr></table></figure>
<p>结果为：10，11，12。range(10,3),其中10 是起始，3是数量。</p>
<h5 id="interval"><a href="#interval" class="headerlink" title="interval"></a>interval</h5><p><strong>在需要轮询的时候是最好的选择</strong></p>
<pre><code>Observable.interval(3,TimeUnit.SECONDS)
        .subscribe(new Observer&lt;Long&gt;() {
            @Override
            public void onCompleted() {
            ...
        });
</code></pre><p>interval()函数的两个参数：一个指定两次发射的时间间隔，另一个是用到的时间单位。</p>
<h5 id="take"><a href="#take" class="headerlink" title="take"></a>take</h5><pre><code>Observable.just(1, 2, 3, 4, 5, 6, 7, 8)
          .take(4)
          .subscribe(new Subscriber&lt;Integer&gt;() {
        ...
    });
</code></pre><p>输出</p>
<pre><code>Next: 1
Next: 2
Next: 3
Next: 4
Sequence complete.
</code></pre><h5 id="TakeLast"><a href="#TakeLast" class="headerlink" title="TakeLast"></a>TakeLast</h5><p><strong>如果我们想要最后N个元素，我们只需使用takeLast()函数：</strong></p>
<pre><code>Observable.just(1, 2, 3, 4, 5, 6, 7, 8)
              .takelast(2)
              .subscribe(new Subscriber&lt;Integer&gt;() {
            ...
        });
</code></pre><p>输出</p>
<pre><code>Next: 7
Next: 8
Sequence complete.
</code></pre><p><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Operators.html" target="_blank" rel="external">戳我</a>可以查看更多的操作符的用法。</p>
]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>http://yoursite.com/2016/06/29/Rx%E5%AE%B6%E6%97%8F%E4%B9%8BRxJava%E5%88%9D%E8%AF%86/</url>
      <content type="html"><![CDATA[<h2 id="Rx系列之RxJava初识"><a href="#Rx系列之RxJava初识" class="headerlink" title="Rx系列之RxJava初识"></a>Rx系列之RxJava初识</h2><h3 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h3><p>第一次听说Rxjava的时候，我顿时就懵b了,什么事RxJava？新的一门强大的语言么！顿时怀着对RxJava的期待，慢慢的去了解了。后来才发现，RxJava其实用到了响应式开发的一种新的开发模式。响应式开发，哇，感觉不得鸟啊！所以在不断的挖掘下，对RxJava做了一个稍微的整理。</p>
<h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><p>在开始了解RxJava之前，得先了解一下<strong>响应式编程</strong>，这是因为Rx响应式编程也是响应式编程的一种。<strong>响应式编程：一种面向数据流和变化传播的编程范式。</strong>不懂啊，没关系，我们来举个栗子：<br><img src="http://ww4.sinaimg.cn/large/52eb2279jw1f2rx409pcnj2044048mx5.jpg" alt=""><br>例如，在我们现在的命令式编程中，a = b + c 表示将表达式的结果赋值给a,那么之后，我改变b或者c之后，a会改变么？有人可能会说肯定会啊。其实是不会变的:</p>
<pre><code>a = b + c;
a = ?
b = d ;
a = ? // 两次的a不会改变
</code></pre><p>所以如上，它是不会变得。那么<strong>响应式编程</strong>与<strong>命令式</strong>的区别在哪里咯？<br>还是如上所说，在<strong>响应式编程</strong>中 ，a的值会随着b或c的改变而改变。</p>
<p>当然，上面所说的，没有解决实际的问题，上面只是一个表面现象，那么最根本的区别到底是什么？<br><strong>可以这样说，当b改变时候，它向a发了一个通知：hi，我改变了，你变一下。</strong>但是，命令式编程中b改变，不会去通知a改变。所以，最大的区别就是：某个数据变更，那么就会发个<strong>通知</strong>。</p>
<p>那么，我们还可以，再进行联想一下：既然响应式能够通知，那是不是，在它通知之前，我可以做任何事情呢？<br>设想一下这个情景：小明，放学回家之后，他跟他妈妈说，饭做好了叫我。<strong>“叫他”</strong>这个就是个通知，那么在这个通知之前，小明是不是可以看电视，做作业…。哟嚯，这个就有意思了，这个像不像我们所说的异步呢？</p>
<h3 id="RxJava之Observables"><a href="#RxJava之Observables" class="headerlink" title="RxJava之Observables"></a>RxJava之Observables</h3><p>用过或者了解过Rxjava的人都知道，在Rxjava中，使用的是Observables。</p>
<p>在面向对象的架构中，开发者致力于创建一组解耦的实体。这样的话，实体就可以在不用妨碍整个系统的情况下可以被测试、复用和维护。设计这种系统就带来一个棘手的负面影响：维护相关对象之间的<strong>统一</strong>。</p>
<p>在众多的设计模式中，观察者模式，是最符合<strong>响应式编程</strong>的一种设计模式，为什么这么说呢？<br><strong>观察者模式</strong>是一种行为模式并提供一种以一对多的依赖来绑定对象的方法：<strong>即当一个对象发生变化时，依赖它的所有对象都会被通知并且会自动更新</strong>。这也就是为什么RxJava中使用到Observables的原因。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式的基本需求：观察者和被观察者之间是完全分离的，当被观察者的状态发生变化之后，<br>通过<strong>Register（注册）</strong> 或者 <strong>Subscribe（订阅）</strong>的方式，通知观察者。如上小明让他妈妈叫他吃饭的例子：观察者就是小明，被观察者是饭，那个会说了，被观察者不是他妈妈么！他妈妈其实就是一个订阅或者注册，当饭这一状态变成好了的时候，那么就会通知小明。</p>
<p> Android 开发中一个比较典型的例子是点击监听器 <strong>OnClickListener</strong> 。对设置 <strong>OnClickListener</strong> 来说， <strong>View</strong> 是被观察者， <strong>OnClickListener</strong> 是观察者，二者通过 <strong>setOnClickListener() </strong>方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework 就会将点击事件发送给已经注册的 OnClickListener 。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。</p>
<p><img src="http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4446ldj20ga03p74h.jpg" alt="观察者模式图"></p>
<h3 id="Rxjava的观察者模式"><a href="#Rxjava的观察者模式" class="headerlink" title="Rxjava的观察者模式"></a>Rxjava的观察者模式</h3><p>在Rxjava中有四种角色：</p>
<ul>
<li><strong>Observable（被观察者）</strong>    </li>
<li><strong>Observer（观察者）</strong>  </li>
<li><strong>Subcriber</strong></li>
<li><strong>Subjects</strong></li>
</ul>
<p>Observable 和 Observer通过 subcribe（订阅）实现订阅关系，所以Observable在状态发生变化的时候通知Observer。</p>
<h3 id="Observer（观察者）"><a href="#Observer（观察者）" class="headerlink" title="Observer（观察者）"></a>Observer（观察者）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>
<p>从中我们可以看出，Observer（观察者）除了传统的onNext（onEvent）还实现了onCompleted()和onError()。<br><strong>onCompleted()</strong>：告知Observable没有更多的数据了，即是没有新的onNext()发出时，就执行onCompleted()。<br><strong>onError()</strong>:在事件处理过程中，出现了异常或者错误，就会被触发，同时整个队列将被终止，不再有事件发出。</p>
<p>在一个队列中，<strong>onCompleted()</strong>和<strong>onError()</strong> 都是最后触发的，而且两者中只有一个会被触发。</p>
<h3 id="Subcriber"><a href="#Subcriber" class="headerlink" title="Subcriber"></a>Subcriber</h3><p>接下来我们再看看<strong>Subcriber</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>
<p>欸嘿嘿，这个怎么跟上面的Observer一毛一样啊！然后我们查看Subcriber的源码就会发现，其实Subscriber其实就是实现了Observer接口的一个抽象类。</p>
<p>那么问题来了：<strong>Observer和Subcriber有什么区别呢？我调用时候使用Observer还是Subcriber呢？</strong><br>subcriber其实是对Observer进行了一些扩展，在Rxjava的Subcribe（订阅）中，Observer总是先辈转换成一个Subcriber再使用的，所以，如果用的话，就用Subcriber就行。</p>
<p><strong>区别：</strong>     </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加Subscription 到关于Subcriber的一个Subscription列表中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">        subscriptions.add(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    subscriptions.unsubscribe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于判断当前是否订阅。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isUnsubscribed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> subscriptions.isUnsubscribed();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是 Subscriber 增加的方法。它会在 Subscribe   刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing by default</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建Observable"><a href="#创建Observable" class="headerlink" title="创建Observable"></a>创建Observable</h3><p>在上述中，我们已经了解了观察者的一些基本内容，那么被观察者怎么创建呢？</p>
<h4 id="Observable-create"><a href="#Observable-create" class="headerlink" title="Observable.create()"></a>Observable.create()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>通过 <strong>Observable.create()</strong>方法创建，那么就需要一个OnSubcribe的对象，卧槽，这个OnSubcribe是个什么东东？打开源就知道，这个OnSubcriber是实现了一个Acton1接口的接口。</p>
<p>每个Observable有一个final OnSubscribe<t> onSubscribe 成员，在唉成员方法中调用call()方法，这个call方法的参数就是 Observable.subscribe() 方法传入的 Subsriber实例。</t></p>
<p><strong>注意：</strong>在Rxjava中ActionX系列，其实就是无返回值的的接口</p>
<h4 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h4><p>上面了解了观察者和被观察者，那么就可以进行订阅了，先来看一个简单的栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被观察者</span></span><br><span class="line">Observable&lt;Integer&gt; observableInteger = Observable.create(<span class="keyword">new</span> Observable</span><br><span class="line">        .OnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            subscriber.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者</span></span><br><span class="line">Subscriber subscriber = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onCompleted: Observable completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onError: Observable error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onNext: "</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//进行订阅</span></span><br><span class="line">Subscription subscription = observableInteger.subscribe(subscriber);</span><br><span class="line"></span><br><span class="line">Log.d(TAG, <span class="string">"subscription: "</span> + subscription.isUnsubscribed() + <span class="string">",Observable:"</span> + subscriber</span><br><span class="line">        .isUnsubscribed());</span><br></pre></td></tr></table></figure>
<p>这里创建了一个观察者，一个订阅者，然后通过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subscription subscription = observableInteger.subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<p>生成一个Subscription订阅关系。<br>为了确定这个订阅是否生效，就打印了里面的循环数据：</p>
<pre><code>onNext: 0
onNext: 1
onNext: 2
onNext: 3
onNext: 4
onCompleted: Observable completed
subscription: true,Observable:true
</code></pre><p>可以看到，Subscriber和Observanle之间已经进行了订阅，如果没有Subscribe就不会发射事件。<br>在Subsriber(Observer)中不关心你给我的到底是个什么，你给我什么，我就操作什么！</p>
<p>有人会说了：如果直接用一个循环打印，岂不是更简单，你这样做复杂化了，太麻烦。<br>确实，在这个例子中复杂化了，上面讲到Rxjava的最大的优势就是：<strong>异步</strong>，并不是进行这么简单的操作，所以，稍安勿躁，请听我慢慢道来。</p>
<h4 id="Observable-from"><a href="#Observable-from" class="headerlink" title="Observable.from()"></a>Observable.from()</h4><p>在上面的例子中，我们创建一个序列，然后一个一个的发射他们，如果现在我们已经有一个序列呢？有没有方法去直接实现它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">integers.add(<span class="number">1</span>);</span><br><span class="line">integers.add(<span class="number">2</span>);</span><br><span class="line">integers.add(<span class="number">3</span>);</span><br><span class="line">integers.add(<span class="number">4</span>);</span><br><span class="line">integers.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">Subscriber subscriber = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onCompleted: Observable completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onError: Observable error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onNext: "</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Observable.from(integers).subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<p>这个跟上面的结果一样一样的。</p>
<h4 id="Observable-just"><a href="#Observable-just" class="headerlink" title="Observable.just()"></a>Observable.just()</h4><p><strong>将传入的参数依次发射出去。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Subscriber subscriber = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onCompleted: Observable completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onError: Observable error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onNext: "</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<p>just()中可以传入1-10个参数，并且将传入参数的顺序来发射出去。</p>
<h3 id="Subjects"><a href="#Subjects" class="headerlink" title="Subjects"></a>Subjects</h3><p>上面我们已经了解了Observer，Subscribe和Observable，还有一个Subject，那么Subject是什么呢？</p>
<p>让我们来看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个当中，我们可以看出，这个Subject即实现了Observer，又继承了Observable，也就是说，Subject当中有观察者又有被观察者，这…你tm在逗我么？其实这并没有问题，就像你自己，既继承了你爸爸的一部分，又继承了你妈妈的一部分，然后形成了你，所以：存在即合理。</p>
<p>那有人会问了：这个既有Observer又有Observable，那该怎么用呢？<br>很简单，它既可以当Observer，又可以当作Observable       </p>
<p>可以用一个表达式来表示：<br><strong><em>Subject = Observable + Observer</em></strong>       </p>
<p>当Subject作为Observer的时候，可以订阅Observable；当Subject作为Observable的时候，可以向Observer发射数据，很显然，作为一个Observable，观察者们或者其它Subject都可以订阅它。</p>
<p><strong>RxJava针对不同的场景提供四种不同的Subject：</strong></p>
<ul>
<li><strong>PublishSubject</strong></li>
<li><strong>BehaviorSubject</strong></li>
<li><strong>ReplaySubject</strong></li>
<li><strong>AsyncSubject</strong></li>
</ul>
<p>也就是说，他们并不是在所有的实现中都全部存在</p>
<h4 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h4><p><strong>当Observable完成时AsyncSubject只会发布最后一个数据给已经订阅的每一个观察者。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">AsyncSubject&lt;String&gt; asyncSubject = AsyncSubject.create();</span><br><span class="line"></span><br><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">"onCompleted: AsyncSubject Completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onError: AsyncSubject Error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onNext: "</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Subscription subscription = asyncSubject.subscribe(subscriber);</span><br><span class="line"></span><br><span class="line">asyncSubject.onNext(<span class="string">"one!"</span>);</span><br><span class="line">asyncSubject.onNext(<span class="string">"two!"</span>);</span><br><span class="line">asyncSubject.onNext(<span class="string">"three!"</span>);</span><br><span class="line">asyncSubject.onCompleted();</span><br></pre></td></tr></table></figure>
<p>看一下结果如何：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onNext: three!</span><br><span class="line">onCompleted: AsyncSubject Completed!</span><br></pre></td></tr></table></figure>
<p><strong>当然如果原始Observable没有发射任何值，AsyncObject也不发射任何值</strong><br>AsyncSubject会把最后一个值发射给后续的观察者。如下图</p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.AsyncSubject.png" alt="AsyncSubject示意图"></p>
<p>那么，在我们这个AsyncSubject异常的情况下会发生什么呢？</p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.AsyncSubject.e.png" alt="AsyncSubject异常示意图"></p>
<p><strong>请注意：如果在AsyncSubject异常时，那么不会向观察者发射任何值，只会传递一个错误的通知。</strong></p>
<h4 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h4><p><strong>当观察者订阅BehaviorSubject时，它开始发射原始Observable最近发射的数据（如果此时还没有收到任何数据，它会发射一个默认值），然后继续发射其它任何来自原始Observable的数据。</strong></p>
<p><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/S.BehaviorSubject.png" alt="BehaviorSubject示意图"></p>
<p>先上代码，试试水：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BehaviorSubject&lt;String&gt; behaviorSubject = BehaviorSubject.create(<span class="string">"default"</span>);</span><br><span class="line"></span><br><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onCompleted: BehaviorSubject Completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onError: BehaviorSubject Error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onNext: "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">behaviorSubject.subscribe(subscriber);</span><br><span class="line">behaviorSubject.onNext(<span class="string">"one"</span>);</span><br><span class="line">behaviorSubject.onNext(<span class="string">"two"</span>);</span><br><span class="line">behaviorSubject.onNext(<span class="string">"three"</span>);</span><br></pre></td></tr></table></figure></p>
<p>我们来看看结果：</p>
<pre><code>onNext: default
onNext: one
onNext: two
onNext: three
</code></pre><p>不是说好的，是最近发射的嘛！怎么全部都打印出来了？还有default哪儿冒出来的？</p>
<p>在我们创建BehaviorSubject的时候可以携带一个默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BehaviorSubject&lt;String&gt; behaviorSubject = BehaviorSubject.create(<span class="string">"default"</span>);</span><br></pre></td></tr></table></figure>
<p>所以如果去掉上面最后三行代码，还是会打印一个default。</p>
<p>那为什么全部都打印出来了呢？<br>我们把上述代码做个改变：</p>
<pre><code>behaviorSubject.subscribe(subscriber);
</code></pre><p>放到倒数第2行，也就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">behaviorSubject.onNext(<span class="string">"one"</span>);</span><br><span class="line">behaviorSubject.onNext(<span class="string">"two"</span>);</span><br><span class="line">behaviorSubject.subscribe(subscriber);</span><br><span class="line">behaviorSubject.onNext(<span class="string">"three"</span>);</span><br></pre></td></tr></table></figure>
<p>欸嘿嘿，我们在来看看结果，变成什么了：</p>
<pre><code>onNext: two
onNext: three
</code></pre><p><strong>看到结果，我们不难看出，其实上面所说的发射最近所发射的数据，其实就是以</strong></p>
<pre><code>behaviorSubject.subscribe(subscriber);
</code></pre><p><strong>为界，这句代码之前的一个和之后的所以发射。</strong></p>
<p>不信你可以试试，将这句代码放到最后一行。看看是不是只有：</p>
<pre><code>onNext: three
</code></pre><hr>
<p>当然，如果原始的Observable因为发生了一个错误而终止，BehaviorSubject将不会发射任何数据，只是简单的向前传递这个错误通知。 </p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.BehaviorSubject.e.png" alt="BehaviorSubject异常示意图"></p>
<h4 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h4><p>那 ReplaySubject 又是什么呢？<br><strong>ReplaySubject会发射所有来自原始Observable的数据给观察者，无论它们是何时订阅的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ReplaySubject&lt;String&gt; replaySubject = ReplaySubject.create();</span><br><span class="line"></span><br><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onCompleted: ReplaySubject Completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onError: ReplaySubject Error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onNext: "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">replaySubject.subscribe(subscriber);</span><br><span class="line"></span><br><span class="line">replaySubject.onNext(<span class="string">"one"</span>);</span><br><span class="line">replaySubject.onNext(<span class="string">"two"</span>);</span><br><span class="line">replaySubject.onNext(<span class="string">"three"</span>);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>onNext: one
onNext: two
onNext: three
</code></pre><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.ReplaySubject.png" alt="ReplaySubject示意图"></p>
<p>这个跟BehaviorSubject的不同之处就是：<strong>不论在什么地方进行订阅，都不影响我发射全部数据。</strong></p>
<h4 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h4><p><strong>PublishSubject只会把在订阅发生的时间点之后来自原始Observable的数据发射给观察者。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PublishSubject&lt;String&gt; publishSubject = PublishSubject.create();</span><br><span class="line"></span><br><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onCompleted: PublishSubject Completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onError: PublishSubject Error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onNext: "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">publishSubject.onNext(<span class="string">"one"</span>);</span><br><span class="line">publishSubject.onNext(<span class="string">"two"</span>);</span><br><span class="line">publishSubject.subscribe(subscriber);</span><br><span class="line">publishSubject.onNext(<span class="string">"three"</span>);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>onNext: three
</code></pre><p>其实这个已经很形象的说明了，<strong>从订阅开始之前的数据都将不会被发射，而只有订阅之后的数据才会被发射出去。</strong></p>
<p><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/S.PublishSubject.png" alt="PublishSubject示意图"></p>
<p>最后在总结一下<strong>Subject</strong>几种类型的区别：</p>
<p><strong>ReplaySubject：不论订阅所处任何位置，都将发射全部数据</strong><br><strong>AsyncSubject：不论订阅所处任何位置，只会发射最后一个数据</strong><br><strong>BehaviorSubject：订阅之前的一个和订阅之后的全部数据被发射</strong><br><strong>PublishSubject：订阅之后的数据全部被发射。</strong>   </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[让人激动的Dagger2---官方文档翻译 ]]></title>
      <url>http://yoursite.com/2016/06/15/dagger2using/</url>
      <content type="html"><![CDATA[<p>Dagger 用法<br>通过建立一个coffee maker,我们将展示依赖注入和Dagger。通过一个完整的代码例子，你能编译和<br>运行，也可以来看Dagger’s coffee example（<a href="https://github.com/square/dagger/tree/master" target="_blank" rel="external">https://github.com/square/dagger/tree/master</a><br>/examples/simple/src/main/java/coffee）。</p>
<h2 id="声明依赖"><a href="#声明依赖" class="headerlink" title="声明依赖"></a>声明依赖</h2><p>Dagger的构建取决于应用类的实例并且满足类的依赖。它使用javax.inject.Inject注入注解去标<br>识那些需要的构造方法和字段。</p>
<p>使用 @Inject 去注入注解 Dagger创建一个类实例的构造方法。当一个新的类实例<br>被注解，Dagger将获得这个必要的参数值和包括这个构造方法。</p>
<pre><code>class Thermosiphon implements Pump {
  private final Heater heater;

  @Inject
  Thermosiphon(Heater heater) {
    this.heater = heater;
  }

  ...
}
</code></pre><p>Dagger 可以直接注入字段。在这个例子中包含了一个Heater的实例即是 heater字段 和包含了一个<br>Pump 实例 即是pump字段</p>
<pre><code>class CoffeeMaker {
  @Inject Heater heater;
  @Inject Pump pump;

  ...
}
</code></pre><p>如果你的类有@Inject 注释关键字，但是没有@Inject注释构造方法，那么Dagger将自动<br>对构造方法注入这些关键字而不会创建新的实例。增加一个没有参数的构造方法，并且用<br>@Inject注解，那也就意味着Dagger能创建实例。<br>虽然构造方法或关键字注入是优先选择的，但是Dagger也支持方法注解。<br>如果类缺少@Inject 注释，那么就不能够被Dagger 构建。</p>
<h2 id="满足依赖关系"><a href="#满足依赖关系" class="headerlink" title="满足依赖关系"></a>满足依赖关系</h2><p>一般来说，如同上面描述的需要类型一样，Dagger满足每一种依赖关系，当你需要一个<br>CoffeeMaker，通过回调 new CoffeeMaker()它将包含一个注释，并且设置它自己的注解关键字。<br>但是@Inject也有不起作用的地方<br>    1.接口不能被构建<br>    2.第三方不能被注释<br>    3.配置类型的对象一定不能被使用的。<br>因为在处理这些案例的时候@Inject是不足的和不够灵便的，但是可以使用@Provides注释方法<br>去满足一种依赖。用这个类的返回类型规定去满足这个依赖。</p>
<p>例如，当某个地方需要的时候，这个provideHeader()就将会被调用。</p>
<pre><code>@Provides static Heater provideHeater() {
  return new ElectricHeater();
}
</code></pre><p>由于@Provide 方法，依赖自身将是可能的。无论什么时候需要一个Pump,这个就将返回一个<br>Thermosition 。</p>
<pre><code>@Provides static Pump providePump(Thermosiphon pump) {
  return pump;
}
</code></pre><p>所有的@Provide方法都必须归属于一个module。仅仅类有一个@Module注释</p>
<pre><code>@Module
class DripCoffeeModule {
  @Provides static Heater provideHeater() {
    return new ElectricHeater();
  }

  @Provides static Pump providePump(Thermosiphon pump) {
    return pump;
  }
}
</code></pre><p>通过协定，@Provide方法用一个provide前缀的方式命名，并且module类用一个有Module后缀<br>的方式命名。</p>
<h2 id="构建图表"><a href="#构建图表" class="headerlink" title="构建图表"></a>构建图表</h2><p>这个@Inject 和 @Provide注释类形成了一个对象图表，对他们的依赖进行了链接。通过一组已经<br>定义好的根能够调用一个应用的main方法和一个android应用存取代码。在dagger2 中那个集合被<br>一个没有参数和返回值类型要求的接口定义。通过应用一个@Component 注释这样一个接口，并且<br>通过module类型去配置modules参数，那么Dagger2 将生成一个完整的关系实现。</p>
<pre><code>@Component(modules = DripCoffeeModule.class)
interface CoffeeShop {
  CoffeeMaker maker();
}
</code></pre><p>这个实现工具用相同的Dagger前缀作为这个接口的名字。这个实现工具包含一个通过调用builder()<br>方式得到的实例，和使用这个builder返回去设置依赖并且build()一个新的实例。</p>
<pre><code>CoffeeShop coffeeShop = DaggerCoffeeShop.builder()
    .dripCoffeeModule(new DripCoffeeModule())
    .build();
</code></pre><p>Note: 如果你的@Component不是一个最高阶层的类型，那么这个生成的component的名字以下划线的方式<br>将包含他自己的全部类型名。例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">BazComponent</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将生成一个以DaggerFoo_Bar_BazComponent命名的component</p>
<p>任何一个module都带有一个默认的构造方法，但是当使用builder的时候，这个构造方法是被忽略。<br>当module没有设置builder的时候，module能够自动构建一个实例。并且对于任何一个@Provides<br>注释的所有方法是static的module来说，这个实现工具不再需要一个实例。如果没有使用创建一个依赖实例，<br>所有依赖能够被构建，那么这个生成的实现工具将也有一个create()方法，这个方法能够被用于得到一个<br>实例，所以没有必要去处理这个builder。</p>
<pre><code>CoffeeShop coffeeShop = DaggerCoffeeShop.create();
</code></pre><p>那么现在，我们的CoffeeApp能够简单的使用这个CoffeeShop的Dagger生成实现工具去得到一个完整<br>injected 的CoffeeMaker;</p>
<pre><code>public class CoffeeApp {
  public static void main(String[] args) {
    CoffeeShop coffeeShop = DaggerCoffeeShop.create();
    coffeeShop.maker().brew();
  }
}
</code></pre><p>既然这个图表被构建，并且所有的关键点都被注入注释，我们运行coffee maker app。激动人心的时刻：</p>
<pre><code>$ java -cp ... coffee.CoffeeApp
~ ~ ~ heating ~ ~ ~
=&gt; =&gt; pumping =&gt; =&gt;
 [_]P coffee! [_]P
</code></pre><h2 id="绑定图表"><a href="#绑定图表" class="headerlink" title="绑定图表"></a>绑定图表</h2><p>如上使用一些更加典型的绑定去演示如何构建一个component，但是这儿有大量的原理，这样有助于去<br>绑定图表。下面是大量的依赖并且能够被用于生产一个较好形式的component。</p>
<ol>
<li><p>这些表明包含在@Module里面的@Provides方法通过@Component.modules被直接引用,或者通过@Module.includes<br>被用来过度.</p>
</li>
<li><p>任何一个带有@Inject的构造方法，不论是否使用@Scope注释，这个构造方法将匹配一个component的Scope;</p>
</li>
<li><p>component提供component依赖方法</p>
</li>
<li><p>可以component自身</p>
</li>
<li><p>没有限定builders，因为每一个都包含subComponent。</p>
</li>
<li><p>Provider 或者 lazy wrappers 适用于任何上面的绑定</p>
</li>
<li><p>一个Layer由任何上述绑定组成，一个Provider由一个lazy组成。(e.g., Provider<lazy<coffeemaker>&gt;)</lazy<coffeemaker></p>
</li>
<li><p>一个成员注入器适用于任何类型</p>
</li>
</ol>
<h2 id="单例对象和作用域绑定"><a href="#单例对象和作用域绑定" class="headerlink" title="单例对象和作用域绑定"></a>单例对象和作用域绑定</h2><p>用@Singleton注释一个@Provide方法或者一个可注入的类。这个图表将使用一个独立实例值用于它的所有clients。</p>
<pre><code>@Provides @Singleton static Heater provideHeater() {
  return new ElectricHeater();
}
</code></pre><p>这个@Singleton注释一个可注入的类也能作为一个文档用来服务。这个用来提醒潜在的维护人员，那个类能够被多<br>重线程分享。</p>
<pre><code>@Singleton
class CoffeeMaker {
  ...
}
</code></pre><p>在图表中，由于Dagger2 用component生成的实例工具关联scope的实例，所以这些component需要去声明它代表<br>哪个scope。例如，在相同的component中有一个@Singleton绑定和一个@RequestScoped绑定，这样是说不通的，因为<br>在相同的component中这些Scope有不同的生命周期，因此其所对应的component应该也具有不同的生命周期。这就<br>表明component与给定的scope相关联，仅仅能应用这一个scope注释component接口。</p>
<pre><code>@Component(modules = DripCoffeeModule.class)
@Singleton
interface CoffeeShop {
  CoffeeMaker maker();
}
</code></pre><p>Component有多个scope注释被应用，这表明他们是同一个scope的别名，所以以至于component能够包含它定义的任何scoped绑定。</p>
<h2 id="可重用的范围"><a href="#可重用的范围" class="headerlink" title="可重用的范围"></a>可重用的范围</h2><p>有时你即想限制一个@Inject注释的构造类被实例化的次数，或者一个@Provides方法被调用的次数，但是你又可以不需要去保证，在任何特定<br>的component或者subcomponent生命周期期间相同的实例被使用。这个是非常有用的，例如android的环境中，这种配置是十分重要的。</p>
<p>对于这些绑定，你能够应用@Reusable Scope,@Reusable-scoped不像其他的绑定，他是不用关联任何一个独立的component；相反，<br>每一个使用了这个绑定的component将存储返回对象或者实例化对象。</p>
<p>这样就意味着你在一个component中配置了一个使用@Reusable绑定的module，但是只有一个subcomponent真正的使用了这个绑定，然后，<br>只有这个subcomponent将能够缓存这个绑定的对象。如果没有同一个父类的两个subcomponent使用这个绑定，那么他们都可以缓存自己的<br>对象，如果一个component的父类已经缓存了这个对象，那么这个subcomponent将不再缓存。</p>
<p>这儿没有保证component仅仅调用这个绑定一次，所以应用@Reusable 去绑定返回不定的对象或者指向相同的实例的对象集是十分危险的。<br>只有为了一个固定的对象使用@Resuable才是安全的。</p>
<pre><code>@Reusable // It doesn&apos;t matter how many scoopers we use, but don&apos;t waste them.
class CoffeeScooper {
  @Inject CoffeeScooper() {}
}

@Module
class CashRegisterModule {
  @Provides
  @Reusable // DON&apos;T DO THIS! You do care which register you put your cash in.
            // Use a specific scope instead.
  static CashRegister badIdeaCashRegister() {
    return new CashRegister();
  }
}


@Reusable // DON&apos;T DO THIS! You really do want a new filter each time, so this
          // should be unscoped.
class CoffeeFilter {
  @Inject CoffeeFilter() {}
}
</code></pre><h2 id="provider-注入"><a href="#provider-注入" class="headerlink" title="provider 注入"></a>provider 注入</h2><p>有时你需要去返回多重的实例代替仅仅注入single 值。你可以有几个选择选项（Factories，Builders 等），一个是注入Provider<t><br>代替 T 。 一个Provider<t> 因为 T 每次调用这个绑定逻辑，get() 是会被调用的。如果那个绑定逻辑是一个@Inject 构造方法，那么<br>一个新的实例将会被创建，但是一个@Provides 方法没有这样的保证。</t></t></p>
<pre><code>class BigCoffeeMaker {
  @Inject Provider&lt;Filter&gt; filterProvider;

  public void brew(int numberOfPots) {
  ...
    for (int p = 0; p &lt; numberOfPots; p++) {
      maker.addFilter(filterProvider.get()); //new filter every time.
      maker.addCoffee(...);
      maker.percolate();
      ...
    }
  }
}
</code></pre><p>Note: 注入 Provider<t>有可能造成混乱代码，并且可能在你的graph中被设计成错误的scope或者错误的构造对象。<br>你可能经常想使用一个factory 或者一个 Lazy<t> 或者重组 这个生命周期 ，并且使你代码的结构体可能仅仅注入 一个 T.<br>然而，注入Provider<t> 仅仅在某些情况下才起作用。</t></t></t></p>
<h2 id="Qualifiers-限定符"><a href="#Qualifiers-限定符" class="headerlink" title="Qualifiers(限定符)"></a>Qualifiers(限定符)</h2><p>有时这个单独的类型是不足以去鉴别一个依赖的。例如，一个复杂的coffee maker app 想分别热水和加热暖板。</p>
<p>在这个案例中，我们增加一个qualifier(限定符)注释。这是一个自身具有@Qualifier注释的注解。这儿是一个用@Name声明的qualifier，<br>一个qualifier注释包含在 javax.inject:</p>
<pre><code>@Qualifier
@Documented
@Retention(RUNTIME)
public @interface Named {
  String value() default &quot;&quot;;
}
</code></pre><p>你能创建你自己的qulifiers注释，或者就使用@Named。通过注释关键字或者有意义的参数就可以使用qualifiers。这个自定义的类型和<br>qualifiers注释同时使用，就能鉴别不同的依赖关系。</p>
<pre><code>class ExpensiveCoffeeMaker {
  @Inject @Named(&quot;water&quot;) Heater waterHeater;
  @Inject @Named(&quot;hot plate&quot;) Heater hotPlateHeater;
  ...
}
</code></pre><p>通过注释与提供qualifiers相一致的@Provides方法</p>
<p>@Provides @Named(“hot plate”) static Heater provideHotPlateHeater() {<br>  return new ElectricHeater(70);<br>}</p>
<p>@Provides @Named(“water”) static Heater provideWaterHeater() {<br>  return new ElectricHeater(93);<br>}</p>
<p>这种依赖关系不能有多重的qualifier注释。</p>
<h2 id="编译时生效"><a href="#编译时生效" class="headerlink" title="编译时生效"></a>编译时生效</h2><p>Dagger 注释处理是十分精确的，如果任何一个绑定是无效的或者不完整的，那么就有可能造成编译时错误。例如，下面这个module只是配置在了<br>一个component上而没有绑定Executor</p>
<pre><code>@Module
class DripCoffeeModule {
  @Provides static Heater provideHeater(Executor executor) {
    return new CpuHeater(executor);
  }
}
</code></pre><p>当编译的时候，javac 是拒绝这个遗漏绑定</p>
<pre><code>[ERROR] COMPILATION ERROR :
[ERROR] error: java.util.concurrent.Executor cannot be provided without an @Provides-annotated method.
</code></pre><p>要解决这个问题，就是在这个component中，通过增加一个Executor的@Provides注释方法到某一个modules，当@Inject，@Module和<br>@Provides都分别生效的时候，所有绑定关系都建立在@Component上。Dagger 1 是直接依赖在@Module上生效的（这就有可能或者没可能<br>反应出运行时的状态），但是Dagger 2 是省略了这种生效形式（以及在@Module上随之而来的参数配置）。</p>
<h2 id="编译时代码生成"><a href="#编译时代码生成" class="headerlink" title="编译时代码生成"></a>编译时代码生成</h2><p>Dagger的注释处理器也有可能生成资源文件，用一些像CoffeeMaker_Factory.java 或者 CoffeeMaker_MembersInjector.java.来命名的。<br>这些文件是Dagger生成实现的详情。尽管当单步调试时，通过一个注解就可以很便利的实现，但是你还是不应该这样直接使用。这个生成的<br>类型文件应该在你的代码中指向这个用Dagger重定向的component。</p>
<h2 id="使用dagger"><a href="#使用dagger" class="headerlink" title="使用dagger"></a>使用dagger</h2><p>在应用运行时，需要包括一个  dagger-2.2.jar，为了使你的代码更加快速生成，那么在你的build编译时还将包含一个dagger-compiler-2.2.jar</p>
<p>在一个maven项目中，将包括在运行时依赖部分的一个pom.xml和dagger-compiler 作为编辑插件依赖。</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;com.google.dagger&lt;/groupId&gt;
    &lt;artifactId&gt;dagger&lt;/artifactId&gt;
    &lt;version&gt;2.2&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;com.google.dagger&lt;/groupId&gt;
    &lt;artifactId&gt;dagger-compiler&lt;/artifactId&gt;
    &lt;version&gt;2.2&lt;/version&gt;
    &lt;optional&gt;true&lt;/optional&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RxJava开发精要8 - 与REST无缝结合-RxJava和Retrofit]]></title>
      <url>http://yoursite.com/2016/06/08/chap8/</url>
      <content type="html"><![CDATA[<h1 id="RxJava开发精要8-与REST无缝结合-RxJava和Retrofit"><a href="#RxJava开发精要8-与REST无缝结合-RxJava和Retrofit" class="headerlink" title="RxJava开发精要8 - 与REST无缝结合-RxJava和Retrofit"></a>RxJava开发精要8 - 与REST无缝结合-RxJava和Retrofit</h1><blockquote>
<ul>
<li>原文出自《RxJava Essentials》</li>
<li>原文作者 : <a href="https://www.packtpub.com/books/info/authors/ivan-morgillo" target="_blank" rel="external">Ivan Morgillo</a></li>
<li>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>转载声明: 本译文已授权<a href="http://toutiao.io/download" target="_blank" rel="external">开发者头条</a>享有独家转载权，未经允许，不得转载!</li>
<li>译者 : <a href="https://github.com/yuxingxin" target="_blank" rel="external">yuxingxin</a> </li>
<li>项目地址 : <a href="https://github.com/yuxingxin/RxJava-Essentials-CN" target="_blank" rel="external">RxJava-Essentials-CN</a></li>
</ul>
</blockquote>
<p>在上一章中，我们学习了如何使用调度器在不同于UI线程的线程上操作。我们学习了如何高效的运行I/O任务而不用阻塞UI以及如何运行耗时的计算任务而不耗损应用性能。在最后一章中，我们将创建一个最终版的<code>真实世界</code>的例子，用Retrofit映射到远程的API,异步的查询数据，从而不费力的创造一个丰富的UI。</p>
<h2 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h2><p>我们将在已存在的例子中创建一个新的<code>Activity</code>。这个<code>Activity</code>将会使用StackExchange API从stackoverflow检索最活跃的10位用户。使用这个信息，App将会展示一个用户的头像，姓名，名望数以及住址列表。对于每一位用户，app将会使用其居住城市和OpenWeatherMap API 来检索当地的天气预报，并展示一个小的天气图标。基于从StackOverflow检索的信息，app对列表的每一位用户将会提供一个<code>onClick</code>事件，它将会打开他们在个人信息中指定的个人网站或者打开Stack Overflow的个人主页。</p>
<h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><p>Retrofit是Square公司专为Android和Java设计的一个类型安全的REST客户端。它帮助你很容易的和任何REST API交互，它完美的集成R小Java：所有的JSON响应对象都被映射成原始的Java对象，并且所有的网络调用都基于Rxjava Observable这些对象。</p>
<p>使用API文档，我们可以定义我们从服务器接收的JSON响应数据。为了很容易的将JSON响应数据映射为我们的Java代码，我们将使用jsonschema2pojo(<a href="http://www.jsonschema2pojo.org)，这个灵活的服务将会生成我们所需要映射JSON响应数据的所有Java类。" target="_blank" rel="external">http://www.jsonschema2pojo.org)，这个灵活的服务将会生成我们所需要映射JSON响应数据的所有Java类。</a></p>
<p>当我们把所有的Java model准备好后，我们就可以开始建立Retrofit。Retrofi使用标准的Java接口来映射API路由。例如例子中，我们将使用来自API的一个路由，下面是我们Retrofit的接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StackExchangeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"2.2users?order=desc&amp;sort=reputation&amp;site=stackoverflow"</span>)</span><br><span class="line">    Observable&lt;User sResponse&gt; getMostPopularSOusers(<span class="meta">@Query</span>(<span class="string">"pagesize"</span>) <span class="keyword">int</span> howmany);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>interface</code>接口只包含一个方法，即<code>getMostPopularSOusers</code>。这个方法用整型<code>howmany</code>作为一个参数并返回<code>UserResponse</code>的Observable。</p>
<p>当我们有了<code>interface</code>，我们可以创建<code>RestAdapter</code>类，为了更清楚的组织我们的代码，我们创建一个<code>SeApiManager</code>函数提供一种更适当的方式来和StackExchange API交互。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeApiManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StackExchangeService mStackExchangeService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeApiManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestAdapter restAdapter = <span class="keyword">new</span> RestAdapter.Builder()</span><br><span class="line">            .setEndpoint(<span class="string">"https://api.stackexchange.com"</span>)</span><br><span class="line">            .setLogLevel(RestAdapter.LogLevel.BASIC)</span><br><span class="line">            .build();</span><br><span class="line">        mStackExchangeService = restAdapter.create(StackExchangeService.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Observable&lt;List&lt;User&gt;&gt; getMostPopularSOusers(<span class="keyword">int</span> howmany) &#123;</span><br><span class="line">    <span class="keyword">return</span> mStackExchangeService</span><br><span class="line">    .getMostPopularSOusers(howmany)</span><br><span class="line">    .map(UsersResponse::getUsers)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了简化例子，我们不再将这个类设计为它本应该设计为的单例。使用依赖注入解决方案，如Dagger2将会使代码质量更高。</p>
<p>创建<code>RestAdapter</code>类，我们为API客户端建立了几个重要的点。这个例子中，我们设置<code>endpoint</code>和<code>log level</code>。由于这个例子URL只是硬编码，使用外部资源来像这样存储数据很重要。避免在代码中硬编码字符串是一个好的实践。</p>
<p>Retrofit把<code>RestAdapter</code>类和我们的API接口绑定在一起后就创建结束。它返回给我们一个对象用来查询API。我们可以选择直接暴露这个对象，或者以某种方式封装依次来限制访问它。在这个例子中，我们封装它并只暴露<code>getMostPopularSOusers</code>方法。这个方法执行查询，让Retrofit解析JSON响应数据。获得用户列表，并返回给订阅者。正如你看到的，使用Retrofit、RxJava和Retrolambda，我们几乎没有模板代码：它非常紧凑并且可读性也高。</p>
<p>现在，我们已经有一个API管理者来暴露一个响应式的方法，它从远程API获取到数据并给I/O调度器，解析映射最后提供给我们的消费者一个简洁的用户列表。</p>
<h2 id="App架构"><a href="#App架构" class="headerlink" title="App架构"></a>App架构</h2><p>我们不使用任何MVC，MVP，或者MVVM模式。因为那不是这本书的目的，因此我们的<code>Activity</code>类将包含我们需要创建和展示用户列表的所有逻辑。</p>
<h2 id="创建Activity类"><a href="#创建Activity类" class="headerlink" title="创建Activity类"></a>创建Activity类</h2><p>我们将在<code>onCreate()</code>方法里创建<code>SwipeRefreshLayout</code>和<code>RecyclerView</code>；我们有一个<code>refreshList()</code>方法来处理用户列表的获取和展示，<code>showRefreshing()</code>方法来管理进度条和<code>RecyclerView</code>的显示。</p>
<p>我们的<code>refreshList()</code>函数看起来如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshList</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    showRefresh(<span class="keyword">true</span>);</span><br><span class="line">    mSeApiManager.getMostPopularSOusers(<span class="number">10</span>)</span><br><span class="line">        .subscribe(users -&gt; &#123; </span><br><span class="line">            showRefresh(<span class="keyword">false</span>);</span><br><span class="line">            mAdapter.updateUsers(users);</span><br><span class="line">        &#125;, error -&gt; &#123; </span><br><span class="line">            App.L.error(error.toString());</span><br><span class="line">            showRefresh(<span class="keyword">false</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们显示了进度条，从StackExchange API 管理器观测用户列表。一旦获取到列表数据，我们开始展示它并更新<code>Adapter</code>的内容并让<code>RecyclerView</code>显示为可见。</p>
<h2 id="创建RecyclerView-Adapter"><a href="#创建RecyclerView-Adapter" class="headerlink" title="创建RecyclerView Adapter"></a>创建RecyclerView Adapter</h2><p>我们从REST API获取到数据后，我们需要把它绑定View上，并用一个适配器填充列表。我们的RecyclerView适配器是标准的。它继承于<code>RecyclerView.Adapter</code>并指定它自己的<code>ViewHolder</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@InjectView</span>(R.id.name) TextView name;</span><br><span class="line">    <span class="meta">@InjectView</span>(R.id.city) TextView city;</span><br><span class="line">    <span class="meta">@InjectView</span>(R.id.reputation) TextView reputation;</span><br><span class="line">    <span class="meta">@InjectView</span>(R.id.user_image) ImageView user_image;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(View view)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>(view);</span><br><span class="line">        ButterKnife.inject(<span class="keyword">this</span>, view); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们一旦收到来自API管理器的数据，我们可以设置界面上所有的标签：<code>name</code>,<code>city</code>和<code>reputation</code>。</p>
<p>为了展示用户的头像，我们将使用Sergey Tarasevich (<a href="https://github.com/nostra13/Android-Universal-" target="_blank" rel="external">https://github.com/nostra13/Android-Universal-</a> ImageLoader)写的<code>Universal Image Loader</code>。UIL是非常有名的并且被测试出很好用的图片管理库。我们也可以使用Square公司的Picasso，Glide或者Facebook公司的Fresco。这只是根据你自己的爱好。重要的是无须重复造轮子：库能够方便开发者的生活并让他们更快速实现目标。</p>
<p>在我们的适配器中，我们可以这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(SoAdapter.ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    User user = mUsers.get(position);</span><br><span class="line">    holder.setUser(user); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>ViewHolder</code>，我们可以这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123; </span><br><span class="line">    name.setText(user.getDisplayName());</span><br><span class="line">    city.setText(user.getLocation());</span><br><span class="line">    reputation.setText(String.valueOf(user.getReputation()));</span><br><span class="line">    </span><br><span class="line">    ImageLoader.getInstance().displayImage(user.getProfileImage(), user_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时，我们可以允许代码获得一个用户列表，正如下图所示：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter8_1.png" width="240"></p>
<h3 id="检索天气预报"><a href="#检索天气预报" class="headerlink" title="检索天气预报"></a>检索天气预报</h3><p>我们加大难度，将当地城市的天气加入列表中。<strong>OpenWeatherMap</strong>是一个灵活的web service公共API，我们可以查询检索许多有用的预报信息。</p>
<p>和往常一样，我们将使用Retrofit映射到API然后通过RxJava来访问它。至于StackExchange API，我们将创建<code>interface</code>，<code>RestAdapter</code>和一个灵活的管理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OpenWeatherMapService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"data2.5/weather"</span>)</span><br><span class="line">    <span class="function">Observable&lt;WeatherResponse&gt; <span class="title">getForecastByCity</span><span class="params">(@Query(<span class="string">"q"</span>)</span> String city)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法用城市名字作为参数提供当地的预报信息。我们像下面这样将接口和<code>RestAdapter</code>类绑定在一起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RestAdapter restAdapter = <span class="keyword">new</span> RestAdapter.Builder()</span><br><span class="line">        .setEndpoint(<span class="string">"http://api.openweathermap.org"</span>)</span><br><span class="line">        .setLogLevel(RestAdapter.LogLevel.BASIC)</span><br><span class="line">        .build();</span><br><span class="line">mOpenWeatherMapService = restAdapter.create(OpenWeatherMapService.class);</span><br></pre></td></tr></table></figure>
<p>像以前一样，我们只需设置API端口和log级别：我们只需要立马做的两件事情。</p>
<p><code>OpenWeatherMapApiManager</code>类将提供下面的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;WeatherResponse&gt; <span class="title">getForecastByCity</span><span class="params">(String city)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mOpenWeatherMapService.getForecastByCity(city)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，我们有了用户列表，我们可以根据城市名来查询OpenWeatherMap来接收天气预报信息。下一步是修改我们的<code>ViewHolder</code>类来为每位用户检索和使用天气预报信息从而根据状态来展示天气图标。</p>
<p>我们使用这些工具方法先验证用户主页信息并获得一个合法的城市名字：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCityValid</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> separatorPosition = getSeparatorPosition(location);</span><br><span class="line">    <span class="keyword">return</span> !<span class="string">""</span>.equals(location) &amp;&amp; separatorPosition &gt; -<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSeparatorPosition</span><span class="params">(String location)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> separatorPosition = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (location != <span class="keyword">null</span>) &#123;</span><br><span class="line">        separatorPosition = location.indexOf(<span class="string">","</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> separatorPosition; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getCity</span><span class="params">(String location, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (location != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> location.substring(<span class="number">0</span>, position); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>借助一个有效的城市名，我们可以用下面命令来获得我们所需要天气的所有数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpenWeatherMapApiManager.getInstance().getForecastByCity(city)</span><br></pre></td></tr></table></figure>
<p>用天气响应的结果，我们可以获得天气图标的URL：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getWeatherIconUrl(weatherResponse);</span><br></pre></td></tr></table></figure>
<p>用图标URL，我们可以检索到图标本身：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;Bitmap&gt; <span class="title">loadBitmap</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(subscriber -&gt; &#123;</span><br><span class="line">        ImageLoader.getInstance().displayImage(url,city_image, <span class="keyword">new</span> ImageLoadingListener() &#123; </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadingStarted</span><span class="params">(String imageUri, View view)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadingFailed</span><span class="params">(String imageUri, View view, FailReason failReason)</span> </span>&#123;</span><br><span class="line">                subscriber.onError(failReason.getCause()); </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadingComplete</span><span class="params">(String imageUri, View view, Bitmap loadedImage)</span> </span>&#123;</span><br><span class="line">                subscriber.onNext(loadedImage);</span><br><span class="line">                subscriber.onCompleted(); </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadingCancelled</span><span class="params">(String imageUri, View view)</span> </span>&#123;</span><br><span class="line">                subscriber.onError(<span class="keyword">new</span> Throwable(<span class="string">"Image loading cancelled"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>loadBitmap()</code>返回的Observable可以链接前面一个，并且最后我们可以为这个任务返回一个单独的Observable：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isCityValid(location)) &#123;</span><br><span class="line">    String city = getCity(location, separatorPosition);</span><br><span class="line">    OpenWeatherMapApiManager.getInstance().getForecastByCity(city)</span><br><span class="line">        .filter(response -&gt; response != <span class="keyword">null</span>)</span><br><span class="line">        .filter(response -&gt; response.getWeather().size() &gt; <span class="number">0</span>)</span><br><span class="line">        .flatMap(response -&gt; &#123;</span><br><span class="line">            String url = getWeatherIconUrl(response);</span><br><span class="line">            <span class="keyword">return</span> loadBitmap(url);</span><br><span class="line">        &#125;)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observer&lt;Bitmap&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            App.L.error(e.toString()); </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Bitmap icon)</span> </span>&#123;</span><br><span class="line">            city_image.setImageBitmap(icon); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，我们可以在下面列表中为每个用户获得新的天气图标：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter8_2.png" width="240"></p>
<h3 id="打开网站"><a href="#打开网站" class="headerlink" title="打开网站"></a>打开网站</h3><p>使用用户主页包含的信息，我们将会创建一个<code>onClick</code>监听器来导航到用户web页面，如果有，或者是Stack Overflow个人主页。</p>
<p>为了实现它，我们简单实现<code>Activity</code>类的接口，用来在适配器触发Android的<code>onClick</code>事件。</p>
<p>我们的<code>Adapter ViewHolder</code>指定这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OpenProfileListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(String url)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Activity</code>实现它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[https:<span class="comment">//github.com/yuxingxin/RxJava-Essentials-CN/raw/master.] implements SoAdapter.ViewHolder.OpenProfileListener &#123; [https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master.]</span></span><br><span class="line">    mAdapter.setOpenProfileListener(<span class="keyword">this</span>); </span><br><span class="line">[https:<span class="comment">//github.com/yuxingxin/RxJava-Essentials-CN/raw/master.]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    Intent i = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">    i.setData(Uri.parse(url)); </span><br><span class="line">    startActivity(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Activity</code>收到URL并用外部Android浏览器打开它。我们的<code>ViewHolder</code>负责在用户列表的每个卡片上创建<code>OnClickListener</code>并检查我们是打开Stack Overflow用户主页还是外部个人站：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mView.setOnClickListener(view -&gt; &#123; </span><br><span class="line">    <span class="keyword">if</span> (mProfileListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String url = user.getWebsiteUrl();</span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; !url.equals(<span class="string">""</span>) &amp;&amp; !url.contains(<span class="string">"search"</span>)) &#123;</span><br><span class="line">            mProfileListener.open(url); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mProfileListener.open(user.getLink()); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)&#125;；</span><br></pre></td></tr></table></figure>
<p>一旦我们点击了，我们将直接重定向到预期的网站。在Android上，我们可以用RxAndroid的一种特殊形式（ViewObservable）以更加响应式的方式实现同样的结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ViewObservable.clicks(mView)</span><br><span class="line">    .subscribe(onClickEvent -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (mProfileListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String url = user.getWebsiteUrl();</span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; !url.equals(<span class="string">""</span>) &amp;&amp; !url.contains(<span class="string">"search"</span>)) &#123; </span><br><span class="line">            mProfileListener.open(url);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mProfileListener.open(user.getLink());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面两块代码片段是等价的，你可以选择你最喜欢的那一种方式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们的旅程结束了。你已经准备好将你的Java应用带到一个新的代码质量水平。你可以享受一个新的编码模式并用更流畅的思维方式接触你的日常编码生活。RxJava提供这样一种机会来以面向时间的方式考虑数据：所有事情都是持续可变的，数据在更新，事件在触发，然后你可以创建基于这些事件响应的，灵活的，运行流畅的App。</p>
<p>刚开始切换到RxJava看起来难并且耗时，但是我们经历了如何用响应式的方式有效地处理日常问题。现在你可以把你的旧代码迁移到RxJava上:给这些同步<code>getters</code>一种新的响应式生活。</p>
<p>RxJava是一个正在不断发展和扩大的世界。还有许多方法我们还没有去探索。有些方法甚至还没有，因为RxJava，你可以创建你自己的操作符并把他们推得更远。</p>
<p>Android是一个好玩的地方，但是它也有局限性。作为一个Android开发者，你可以用RxJava和RxAndroid克服它们中许多部分。我们用AndroidScheduler只简单提了下RxAndroid,除了在最后一章，你了解了<code>ViewObservable</code>。RxAndroid给了你许多：例如，<code>WidgetObservable</code>，<code>LifecycleObservable</code>。现在要更多的推动它取决于你了。</p>
<p>记得可观测序列就像一条河：它们是流动的。你可以“过滤”一条河，你可以“转换”一条河，你可以将两条河合并成一个，然后它仍旧时流动的。最后，它将成为你想要的那条河。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RxJava开发精要7 - Schedulers-解决Android主线程问题]]></title>
      <url>http://yoursite.com/2016/06/08/chap7/</url>
      <content type="html"><![CDATA[<h1 id="RxJava开发精要7-Schedulers-解决Android主线程问题"><a href="#RxJava开发精要7-Schedulers-解决Android主线程问题" class="headerlink" title="RxJava开发精要7 - Schedulers-解决Android主线程问题"></a>RxJava开发精要7 - Schedulers-解决Android主线程问题</h1><blockquote>
<ul>
<li>原文出自《RxJava Essentials》</li>
<li>原文作者 : <a href="https://www.packtpub.com/books/info/authors/ivan-morgillo" target="_blank" rel="external">Ivan Morgillo</a></li>
<li>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>转载声明: 本译文已授权<a href="http://toutiao.io/download" target="_blank" rel="external">开发者头条</a>享有独家转载权，未经允许，不得转载!</li>
<li>译者 : <a href="https://github.com/yuxingxin" target="_blank" rel="external">yuxingxin</a> </li>
<li>项目地址 : <a href="https://github.com/yuxingxin/RxJava-Essentials-CN" target="_blank" rel="external">RxJava-Essentials-CN</a></li>
</ul>
</blockquote>
<p>前面一章是最后一章关于RxJava的Observable的创建和操作的章节。我们学习到了如何将两个或更多的Observables合并在一起，<code>join</code>它们，<code>zip</code>它们，<code>merge</code>它们以及如何创建一个新的Observable来满足我们特殊的需求。</p>
<p>本章中，我们提升标准看看如何使用RxJava的调度器来处理多线程和并发编程的问题。我们将学习到如何以响应式的方式创建网络操作，内存访问，以及耗时任务。</p>
<h2 id="StrictMode"><a href="#StrictMode" class="headerlink" title="StrictMode"></a>StrictMode</h2><p>为了获得更多出现在代码中的关于公共问题的信息，我们激活了<code>StrictMode</code>模式。</p>
<p><code>StrictMode</code>帮助我们侦测敏感的活动，如我们无意的在主线程执行磁盘访问或者网络调用。正如你所知道的，在主线程执行繁重的或者长时的任务是不可取的。因为Android应用的主线程时UI线程，它被用来处理和UI相关的操作：这也是获得更平滑的动画体验和响应式App的唯一方法。</p>
<p>为了在我们的App中激活<code>StrictMode</code>，我们只需要在<code>MainActivity</code>中添加几行代码，即<code>onCreate()</code>方法中这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    <span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</span><br><span class="line">        StrictMode.setThreadPolicy(<span class="keyword">new</span> StrictMode.ThreadPolicy.Builder().detectAll().penaltyLog().build()); </span><br><span class="line">        StrictMode.setVmPolicy(<span class="keyword">new</span> StrictMode.VmPolicy.Builder().detectAll().penaltyLog().build());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们并不想它总是激活着，因此我们只在debug构建时使用。这种配置将报告每一种关于主线程用法的违规做法，并且这些做法都可能与内存泄露有关：<code>Activities</code>、<code>BroadcastReceivers</code>、<code>Sqlite</code>等对象。</p>
<p>选择了<code>penaltyLog()</code>，当违规做法发生时，<code>StrictMode</code>将会在logcat打印一条信息。</p>
<h2 id="避免阻塞I-O的操作"><a href="#避免阻塞I-O的操作" class="headerlink" title="避免阻塞I/O的操作"></a>避免阻塞I/O的操作</h2><p>阻塞I/O的操作将使App能够进行下一步操作前会强制使其等待结果的返回。在UI线程上执行一个阻塞操作将强制使UI卡住，这将直接产生不好的用户体验。</p>
<p>我们激活<code>StrictMode</code>后，我们开始收到了关于我们的App错误操作磁盘I/O的不友好信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D/StrictMode  StrictMode policy violation; ~duration=<span class="number">998</span> ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=<span class="number">31</span> violation=<span class="number">2</span></span><br><span class="line">at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk (StrictMode.java:<span class="number">1135</span>)</span><br><span class="line">at libcore.io.BlockGuardOs.open(BlockGuardOs.java:<span class="number">106</span>) at libcore.io.IoBridge.open(IoBridge.java:<span class="number">393</span>)</span><br><span class="line">at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:<span class="number">88</span>) </span><br><span class="line">at android.app.ContextImpl.openFileOutput(ContextImpl.java:<span class="number">918</span>) </span><br><span class="line">at android.content.ContextWrapper.openFileOutput(ContextWrapper. java:<span class="number">185</span>)</span><br><span class="line">at com.packtpub.apps.rxjava_essentials.Utils.storeBitmap (Utils.java:<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>上一条信息告诉我们<code>Utils.storeBitmap()</code>函数执行完耗时998ms：在UI线程上近1秒的不必要的工作和App上近1秒不必要的迟钝。这是因为我们以阻塞的方式访问磁盘。我们的<code>storeBitmap()</code>函数包含了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fOut = context.openFileOutput(filename, Context.MODE_PRIVATE);</span><br></pre></td></tr></table></figure></p>
<p>它直接访问智能手机的固态存储然后就慢了。我们该如何提高访问速度呢？<code>storeBitmap()</code>函数保存了已安装App的图标。他返回了<code>void</code>，因此在执行下一个操作前我们毫无理由去等待直到它完成。我们可以启动它并让它执行在不同的线程。Android中这些年线程管理的变化产生了App诡异的行为。我们可以使用<code>AsyncTask</code>，但是我们要避免掉入前几章里的<code>onPrehttps://github.com/yuxingxin/RxJava-Essentials-CN/raw/master. onPosthttps://github.com/yuxingxin/RxJava-Essentials-CN/raw/master.doInBackGround</code>地狱。我们将使用RxJava的方式;万岁的调度器！</p>
<h2 id="Schedulers"><a href="#Schedulers" class="headerlink" title="Schedulers"></a>Schedulers</h2><p>调度器以一种最简单的方式将多线程用在你的Apps的中。它们时RxJava重要的一部分并能很好地与Observables协同工作。它们无需处理实现、同步、线程、平台限制、平台变化而可以提供一种灵活的方式来创建并发程序。</p>
<p>RxJava提供了5种调度器：</p>
<ul>
<li><code>.io()</code></li>
<li><code>.computation()</code></li>
<li><code>.immediate()</code></li>
<li><code>.newThread()</code></li>
<li><code>.trampoline()</code></li>
</ul>
<p>让我们一个一个的来看下它们：</p>
<h2 id="Schedulers-io"><a href="#Schedulers-io" class="headerlink" title="Schedulers.io()"></a>Schedulers.io()</h2><p>这个调度器时用于I/O操作。它基于根据需要，增长或缩减来自适应的线程池。我们将使用它来修复我们之前看到的<code>StrictMode</code>违规做法。由于它专用于I/O操作，所以并不是RxJava的默认方法；正确的使用它是由开发者决定的。</p>
<p>重点需要注意的是线程池是无限制的，大量的I/O调度操作将创建许多个线程并占用内存。一如既往的是，我们需要在性能和简捷两者之间找到一个有效的平衡点。</p>
<h2 id="Schedulers-computation"><a href="#Schedulers-computation" class="headerlink" title="Schedulers.computation()"></a>Schedulers.computation()</h2><p>这个是计算工作默认的调度器，它与I/O操作无关。它也是许多RxJava方法的默认调度器：<code>buffer()</code>,<code>debounce()</code>,<code>delay()</code>,<code>interval()</code>,<code>sample()</code>,<code>skip()</code>。</p>
<h2 id="Schedulers-immediate"><a href="#Schedulers-immediate" class="headerlink" title="Schedulers.immediate()"></a>Schedulers.immediate()</h2><p>这个调度器允许你立即在当前线程执行你指定的工作。它是<code>timeout()</code>,<code>timeInterval()</code>,以及<code>timestamp()</code>方法默认的调度器。</p>
<h2 id="Schedulers-newThread"><a href="#Schedulers-newThread" class="headerlink" title="Schedulers.newThread()"></a>Schedulers.newThread()</h2><p>这个调度器正如它所看起来的那样：它为指定任务启动一个新的线程。</p>
<h2 id="Schedulers-trampoline"><a href="#Schedulers-trampoline" class="headerlink" title="Schedulers.trampoline()"></a>Schedulers.trampoline()</h2><p>当我们想在当前线程执行一个任务时，并不是立即，我们可以用<code>.trampoline()</code>将它入队。这个调度器将会处理它的队列并且按序运行队列中每一个任务。它是<code>repeat()</code>和<code>retry()</code>方法默认的调度器。</p>
<h2 id="非阻塞I-O操作"><a href="#非阻塞I-O操作" class="headerlink" title="非阻塞I/O操作"></a>非阻塞I/O操作</h2><p>现在我们知道如何在一个指定I/O调度器上来调度一个任务，我们可以修改<code>storeBitmap()</code>函数并再次检查<code>StrictMode</code>的不合规做法。为了这个例子，我们可以在新的<code>blockingStoreBitmap()</code>函数中重排代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blockingStoreBitmap</span><span class="params">(Context context, Bitmap bitmap, String filename)</span> </span>&#123;</span><br><span class="line">    FileOutputStream fOut = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fOut = context.openFileOutput(filename, Context.MODE_PRIVATE);</span><br><span class="line">        bitmap.compress(Bitmap.CompressFormat.PNG, <span class="number">100</span>, fOut); </span><br><span class="line">        fOut.flush();</span><br><span class="line">        fOut.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fOut != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fOut.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以使用<code>Schedulers.io()</code>创建非阻塞的版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">storeBitmap</span><span class="params">(Context context, Bitmap bitmap, String filename)</span> </span>&#123;</span><br><span class="line">    Schedulers.io().createWorker().schedule(() -&gt; &#123;</span><br><span class="line">        blockingStoreBitmap(context, bitmap, filename);</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次我们调用<code>storeBitmap()</code>，RxJava处理创建所有它需要从I / O线程池一个特定的I/ O线程执行我们的任务。所有要执行的操作都避免在UI线程执行并且我们的App比之前要快上1秒：logcat上也不再有<code>StrictMode</code>的不合规做法。</p>
<p>下图展示了我们在<code>storeBitmap()</code>场景看到的两种方法的不同：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter7_1.png" alt=""></p>
<h2 id="SubscribeOn-and-ObserveOn"><a href="#SubscribeOn-and-ObserveOn" class="headerlink" title="SubscribeOn and ObserveOn"></a>SubscribeOn and ObserveOn</h2><p>我们学到了如何在一个调度器上运行一个任务。但是我们如何利用它来和Observables一起工作呢？RxJava提供了<code>subscribeOn()</code>方法来用于每个Observable对象。<code>subscribeOn()</code>方法用<code>Scheduler</code>来作为参数并在这个Scheduler上执行Observable调用。</p>
<p>在“真实世界”这个例子中，我们调整<code>loadList()</code>函数。首先，我们需要一个新的<code>getApps()</code>方法来检索已安装的应用列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;AppInfo&gt; <span class="title">getApps</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> Observable.create(subscriber -&gt; &#123;</span><br><span class="line">        List&lt;AppInfo&gt; apps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);</span><br><span class="line">        Type appInfoType = <span class="keyword">new</span> TypeToken&lt;List&lt;AppInfo&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">        String serializedApps = sharedPref.getString(<span class="string">"APPS"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">""</span>.equals(serializedApps)) &#123;</span><br><span class="line">            apps = <span class="keyword">new</span> Gson().fromJson(serializedApps,appInfoType); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (AppInfo app : apps) &#123;</span><br><span class="line">            subscriber.onNext(app);</span><br><span class="line">        &#125;</span><br><span class="line">        subscriber.onCompleted(); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getApps()</code>方法返回一个<code>AppInfo</code>的Observable。它先从Android的SharePreferences读取到已安装的应用程序列表。反序列化，并一个接一个的发射AppInfo数据。使用新的方法来检索列表，<code>loadList()</code>函数改成下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mRecyclerView.setVisibility(View.VISIBLE);</span><br><span class="line">    getApps().subscribe(<span class="keyword">new</span> Observer&lt;AppInfo&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"Here is the list!"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123;</span><br><span class="line">            mAddedApps.add(appInfo);</span><br><span class="line">                mAdapter.addApplication(mAddedApps.size() - <span class="number">1</span>, appInfo);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们运行代码，<code>StrictMode</code>将会报告一个不合规操作，这是因为<code>SharePreferences</code>会减慢I/O操作。我们所需要做的是指定<code>getApps()</code>需要在调度器上执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">getApps().subscribeOn(Schedulers.io())</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;AppInfo&gt;() &#123; [https:<span class="comment">//github.com/yuxingxin/RxJava-Essentials-CN/raw/master.]</span></span><br></pre></td></tr></table></figure>
<p><code>Schedulers.io()</code>将会去掉<code>StrictMode</code>的不合规操作，但是我们的App现在崩溃了是因为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.jav a:<span class="number">58</span>)</span><br><span class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors. java:<span class="number">422</span>)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">237</span>) </span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutu reTask.access$<span class="number">201</span>(ScheduledThreadPoolExecutor.java:<span class="number">152</span>)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutu reTask.run(ScheduledThreadPoolExecutor.java:<span class="number">265</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolEx ecutor.java:<span class="number">1112</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolE xecutor.java:<span class="number">587</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">841</span>) Caused by:</span><br><span class="line">    android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</span><br></pre></td></tr></table></figure></p>
<p>Only the original thread that created a view hierarchy can touch its views.</p>
<p>我们再次回到Android的世界。这条信息简单的告诉我们我们试图在一个非UI线程来修改UI操作。意思是我们需要在I/O调度器上执行我们的代码。因此我们需要和I/O调度器一起执行代码，但是当结果返回时我们需要在UI线程上操作。RxJava让你能够订阅一个指定的调度器并观察它。我们只需在<code>loadList()</code>函数添加几行代码，那么每一项就都准备好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getApps()</span><br><span class="line">.onBackpressureBuffer()</span><br><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line">.observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">.subscribe(<span class="keyword">new</span> Observer&lt;AppInfo&gt;() &#123; [https:<span class="comment">//github.com/yuxingxin/RxJava-Essentials-CN/raw/master.]</span></span><br></pre></td></tr></table></figure>
<p><code>observeOn()</code>方法将会在指定的调度器上返回结果：如例子中的UI线程。<code>onBackpressureBuffer()</code>方法将告诉Observable发射的数据如果比观察者消费的数据要更快的话，它必须把它们存储在缓存中并提供一个合适的时间给它们。做完这些工作之后，如果我们运行App，就会出现已安装的程序列表：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter7_2.png" width="240"></p>
<h2 id="处理耗时的任务"><a href="#处理耗时的任务" class="headerlink" title="处理耗时的任务"></a>处理耗时的任务</h2><p>我们已经知道如何处理缓慢的I/O操作。让我们看一个与I/O无关的耗时的任务。例如，我们修改<code>loadList()</code>函数并创建一个新的<code>slow</code>函数发射我们已安装的app数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;AppInfo&gt; <span class="title">getObservableApps</span><span class="params">(List&lt;AppInfo&gt; apps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable .create(subscriber -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> y = i * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (AppInfo app : apps) &#123;</span><br><span class="line">            subscriber.onNext(app);</span><br><span class="line">        &#125;</span><br><span class="line">        subscriber.onCompleted(); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你看到的，这个函数执行了一些毫无意义的计算，只是针对这个例子消耗时间，然后从<code>List&lt;AppInfo&gt;</code>对象中发射我们的<code>AppInfo</code>数据，现在，我们重排<code>loadList()</code>函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadList</span><span class="params">(List&lt;AppInfo&gt; apps)</span> </span>&#123;</span><br><span class="line">    mRecyclerView.setVisibility(View.VISIBLE);</span><br><span class="line">    getObservableApps(apps)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;AppInfo&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                Toast.makeText(getActivity(), <span class="string">"Here is the list!"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123; </span><br><span class="line">                mAddedApps.add(appInfo);  </span><br><span class="line">                mAdapter.addApplication(mAddedApps.size() - <span class="number">1</span>, appInfo);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们运行这段代码，当我们点击<code>Navigation Drawer</code>菜单项时App将会卡住一会，然后你能看到下图中半关闭的菜单:</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter7_3.png" width="240"></p>
<p>如果我们不够走运的话，我们可以看到下图中经典的ANR信息框：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter7_4.png" width="240"></p>
<p>可以确定的是，我们将会看到下面在logcat中不愉快的信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I/Choreographer  Skipped <span class="number">598</span> frames! The application may be doing too much work on its main thread.</span><br></pre></td></tr></table></figure>
<p>这条信息比较清楚，Android在告诉我们用户体验非常差的原因是我们用不必要的工作量阻塞了UI线程。但是我们已经知道了如何处理它：我们有调度器！我们只须添加几行代码到我们的Observable链中就能去掉加载慢和<code>Choreographer</code>信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getObservableApps(apps)</span><br><span class="line">    .onBackpressureBuffer()</span><br><span class="line">    .subscribeOn(Schedulers.computation())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observer&lt;AppInfo&gt;() &#123; [https:<span class="comment">//github.com/yuxingxin/RxJava-Essentials-CN/raw/master.]</span></span><br></pre></td></tr></table></figure>
<p>用这几行代码，我们将可以快速关掉<code>Navigation Drawer</code>,一个漂亮的进度条，一个工作在独立的线程缓慢执行的计算任务，并在主线程返回结果让我们更新已安装的应用列表。</p>
<h2 id="执行网络任务"><a href="#执行网络任务" class="headerlink" title="执行网络任务"></a>执行网络任务</h2><p>网络在今天是99%的移动应用的一部分：我们总是连接远端服务器来检索我们App需要的信息。</p>
<p>作为网络访问的第一个方法，我们将创建下面这样一个场景:</p>
<ul>
<li>加载一个进度条。</li>
<li>用一个按钮开始文件下载。</li>
<li>下载过程中更新进度条。</li>
<li>下载完后开始视频播放。</li>
</ul>
<p>我们的用户界面非常简单，我们只需要一个有趣的进度条和一个下载按钮。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter7_5.png" width="240"></p>
<p>首先，我们创建<code>mDownloadProgress</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PublishSubject&lt;Integer&gt;mDownloadProgress = PublishSubject.create();</span><br></pre></td></tr></table></figure>
<p>这个主题我们用来管理进度的更新，它和<code>download</code>函数协同工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">downloadFile</span><span class="params">(String source, String destination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    InputStream input = <span class="keyword">null</span>; </span><br><span class="line">    OutputStream output = <span class="keyword">null</span>; </span><br><span class="line">    HttpURLConnection connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(source);</span><br><span class="line">        connection = (HttpURLConnection) url.openConnection(); </span><br><span class="line">        connection.connect();</span><br><span class="line">        <span class="keyword">if</span> (connection.getResponseCode() != HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fileLength = connection.getContentLength();</span><br><span class="line">        input = connection.getInputStream();</span><br><span class="line">        output = <span class="keyword">new</span> FileOutputStream(destination);</span><br><span class="line">        <span class="keyword">byte</span> data[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count = input.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            total += count;</span><br><span class="line">            <span class="keyword">if</span> (fileLength &gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> percentage = (<span class="keyword">int</span>) (total * <span class="number">100</span> / fileLength);</span><br><span class="line">                mDownloadProgress.onNext(percentage);</span><br><span class="line">            &#125;</span><br><span class="line">            output.write(data, <span class="number">0</span>, count); </span><br><span class="line">        &#125;</span><br><span class="line">        mDownloadProgress.onCompleted(); </span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        mDownloadProgress.onError(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (output != <span class="keyword">null</span>) &#123; </span><br><span class="line">                output.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</span><br><span class="line">                input.close(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;    </span><br><span class="line">            mDownloadProgress.onError(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            connection.disconnect();</span><br><span class="line">            mDownloadProgress.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的这段代码将会触发<code>NetworkOnMainThreadException</code>异常。我们可以创建RxJava版本的函数进入我们挚爱的响应式世界来解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;Boolean&gt; <span class="title">obserbableDownload</span><span class="params">(String source, String destination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(subscriber -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> result = downloadFile(source, destination); </span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                subscriber.onNext(<span class="keyword">true</span>);</span><br><span class="line">                subscriber.onCompleted(); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                subscriber.onError(<span class="keyword">new</span> Throwable(<span class="string">"Download failed."</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">            subscriber.onError(e);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们需要触发下载操作，点击下载按钮:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnClick</span>(R.id.button_download)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">download</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mButton.setText(getString(R.string.downloading));</span><br><span class="line">    mButton.setClickable(<span class="keyword">false</span>);</span><br><span class="line">    mDownloadProgress.distinct()</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            App.L.debug(<span class="string">"Completed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            App.L.error(e.toString()); </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer progress)</span> </span>&#123;</span><br><span class="line">            mArcProgress.setProgress(progress);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    String destination = <span class="string">"sdcardsoftboy.avi"</span>;</span><br><span class="line">    obserbableDownload(<span class="string">"http://archive.blender.org/fileadmin/movies/softboy.avi"</span>, destination)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(success -&gt; &#123;</span><br><span class="line">            resetDownloadButton();</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(android.content.Intent.ACTION_VIEW);</span><br><span class="line">            File file = <span class="keyword">new</span> File(destination);</span><br><span class="line">            intent.setDataAndType(Uri.fromFile(file),<span class="string">"video/avi"</span>);</span><br><span class="line">            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); </span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125;, error -&gt; &#123;</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"Something went south"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            resetDownloadButton();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用Butter Knife的注解<code>@OnClick</code>来绑定按钮的方法并更新按钮信息和点击状态：我们不想让用户点击多次从而触发多次下载事件。</p>
<p>然后，我们创建一个subscription来观察下载进度并相应的更新进度条。很明显，我们我们观测主线程是因为进度条是UI元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obserbableDownload(<span class="string">"http://archive.blender.org/fileadmin/movies/softboy.avi"</span>, <span class="string">"sdcardsoftboy.avi"</span>;)</span><br></pre></td></tr></table></figure>
<p>这是一个下载Observable。网络调用是一个I/O任务和我们预料的那样使用I/O调度器。当下载完成时，我们在<code>onNext()</code>启动视频播放器，并且播放器将会在目的URL找到下载的文件.。</p>
<p>下图展示了下载进度和视频播放器对话框：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter7_6.png" width="240"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章中，我们学习了如何简单的将多线程应用在我们的App中。RxJava为此提供了极其有用的工具：调度器。调度器来自不同的指定优化场景并且我们也不避免了<code>StrictMode</code>不合法操作以及阻塞I/O函数。我们现在可以用简单的，响应式的并在整个App中保持一致的方式来访问内存和网络。</p>
<p>下一章中，我们将会提高风险并创建一个<code>真实世界</code>App，并使用Square公司开源的REST API库Retrofit从不同的远程资源获取数据来创建一个复杂的material design UI。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RxJava开发精要6 - 组合Observables]]></title>
      <url>http://yoursite.com/2016/06/08/chap6/</url>
      <content type="html"><![CDATA[<h1 id="RxJava开发精要6-组合Observables"><a href="#RxJava开发精要6-组合Observables" class="headerlink" title="RxJava开发精要6 - 组合Observables"></a>RxJava开发精要6 - 组合Observables</h1><blockquote>
<ul>
<li>原文出自《RxJava Essentials》</li>
<li>原文作者 : <a href="https://www.packtpub.com/books/info/authors/ivan-morgillo" target="_blank" rel="external">Ivan Morgillo</a></li>
<li>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>转载声明: 本译文已授权<a href="http://toutiao.io/download" target="_blank" rel="external">开发者头条</a>享有独家转载权，未经允许，不得转载!</li>
<li>译者 : <a href="https://github.com/yuxingxin" target="_blank" rel="external">yuxingxin</a> </li>
<li>项目地址 : <a href="https://github.com/yuxingxin/RxJava-Essentials-CN" target="_blank" rel="external">RxJava-Essentials-CN</a></li>
</ul>
</blockquote>
<p>上一章中，我们学到如何转换可观测序列。我们也看到了<code>map()</code>,<code>scan()</code>,<code>groupBY()</code>,以及更多有用的函数的实际例子，它们帮助我们操作Observable来创建我们想要的Observable。</p>
<p>本章中，我们将研究组合函数并学习如何同时处理多个Observables来创建我们想要的Observable。</p>
<h2 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h2><p>在异步的世界经常会创建这样的场景，我们有多个来源但是只想有一个结果：多输入，单输出。RxJava的<code>merge()</code>方法将帮助你把两个甚至更多的Observables合并到他们发射的数据里。下图给出了把两个序列合并在一个最终发射的Observable。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter6_1.png" alt=""></p>
<p>正如你看到的那样，发射的数据被交叉合并到一个Observable里面。注意如果你同步的合并Observable，它们将连接在一起并且不会交叉。</p>
<p>像通常一样，我们用我们的App和已安装的App列表来创建了一个“真实世界”的例子。我们还需要第二个Observable。我们可以创建一个单独的应用列表然后逆序。当然没有实际的意义，只是为了这个例子。第二个列表，我们的<code>loadList()</code>函数像下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadList</span><span class="params">(List&lt;AppInfo&gt; apps)</span> </span>&#123;</span><br><span class="line">    mRecyclerView.setVisibility(View.VISIBLE);</span><br><span class="line">    List reversedApps = Lists.reverse(apps);</span><br><span class="line">    Observable&lt;AppInfo&gt; observableApps =Observable.from(apps);</span><br><span class="line">    Observable&lt;AppInfo&gt; observableReversedApps =Observable.from(reversedApps);</span><br><span class="line">    Observable&lt;AppInfo&gt; mergedObserbable = Observable.merge(observableApps,observableReversedApps);</span><br><span class="line">    </span><br><span class="line">    mergedObserbable.subscribe(<span class="keyword">new</span> Observer&lt;AppInfo&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"Here is the list!"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"One of the two Observable threw an error!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfoappInfo)</span> </span>&#123;</span><br><span class="line">            mAddedApps.add(appInfo);</span><br><span class="line">            mAdapter.addApplication(mAddedApps.size() - <span class="number">1</span>, appInfo);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们创建了Observable和observableApps数据以及新的observableReversedApps逆序列表。使用<code>Observable.merge()</code>，我们可以创建新的<code>ObservableMergedObservable</code>在单个可观测序列中发射源Observables发出的所有数据。</p>
<p>正如你能看到的,每个方法签名都是一样的，因此我们的观察者无需在意任何不同就可以复用代码。结果如下：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter6_2.png" width="240"></p>
<p>注意错误时的toast消息，你可以认为每个Observable抛出的错误将会打断合并。如果你需要避免这种情况，RxJava提供了<code>mergeDelayError()</code>，它能从一个Observable中继续发射数据即便是其中有一个抛出了错误。当所有的Observables都完成时，<code>mergeDelayError()</code>将会发射<code>onError()</code>，如下图所示：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter6_3.png" alt=""></p>
<h2 id="ZIP"><a href="#ZIP" class="headerlink" title="ZIP"></a>ZIP</h2><p>我们在处理多源时可能会带来这样一种场景：多从个Observables接收数据，处理它们，然后将它们合并成一个新的可观测序列来使用。RxJava有一个特殊的方法可以完成：<code>zip()</code>合并两个或者多个Observables发射出的数据项，根据指定的函数<code>Func*</code>变换它们，并发射一个新值。下图展示了<code>zip()</code>方法如何处理发射的“numbers”和“letters”然后将它们合并一个新的数据项：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter6_4.png" alt=""></p>
<p>对于“真实世界”的例子来说，我们将使用已安装的应用列表和一个新的动态的Observable来让例子变得有点有趣味。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Long&gt; tictoc = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p><code>tictoc</code>Observable变量使用<code>interval()</code>函数每秒生成一个Long类型的数据：简单且高效，正如之前所说的，我们需要一个<code>Func</code>对象。因为它需要传两个参数，所以是<code>Func2</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AppInfo <span class="title">updateTitle</span><span class="params">(AppInfoappInfo, Long time)</span> </span>&#123;</span><br><span class="line">    appInfo.setName(time + <span class="string">" "</span> + appInfo.getName());</span><br><span class="line">    <span class="keyword">return</span> appInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们的<code>loadList()</code>函数变成这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadList</span><span class="params">(List&lt;AppInfo&gt; apps)</span> </span>&#123;</span><br><span class="line">    mRecyclerView.setVisibility(View.VISIBLE);</span><br><span class="line">    Observable&lt;AppInfo&gt; observableApp = Observable.from(apps);</span><br><span class="line">    </span><br><span class="line">    Observable&lt;Long&gt; tictoc = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    </span><br><span class="line">    Observable.zip(observableApp, tictoc,</span><br><span class="line">    (AppInfo appInfo, Long time) -&gt; updateTitle(appInfo, time))</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observer&lt;AppInfo&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"Here is the list!"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfoappInfo)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mSwipeRefreshLayout.isRefreshing()) &#123;</span><br><span class="line">                mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            mAddedApps.add(appInfo);</span><br><span class="line">            <span class="keyword">int</span> position = mAddedApps.size() - <span class="number">1</span>;</span><br><span class="line">            mAdapter.addApplication(position, appInfo);</span><br><span class="line">            mRecyclerView.smoothScrollToPosition(position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正如你看到的那样，<code>zip()</code>函数有三个参数：两个Observables和一个<code>Func2</code>。</p>
<p>仔细一看会发现<code>observeOn()</code>函数。它将在下一章中讲解：现在我们可以小试一下。</p>
<p>结果如下：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter6_5.png" width="320"></p>
<h2 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h2><p>前面两个方法，<code>zip()</code>和<code>merge()</code>方法作用在发射数据的范畴内，在决定如何操作值之前有些场景我们需要考虑时间的。RxJava的<code>join()</code>函数基于时间窗口将两个Observables发射的数据结合在一起。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter6_6.png" alt=""></p>
<p>为了正确的理解上一张图，我们解释下<code>join()</code>需要的参数：</p>
<ul>
<li>第二个Observable和源Observable结合。</li>
<li><code>Func1</code>参数：在指定的由时间窗口定义时间间隔内，源Observable发射的数据和从第二个Observable发射的数据相互配合返回的Observable。</li>
<li><code>Func1</code>参数：在指定的由时间窗口定义时间间隔内，第二个Observable发射的数据和从源Observable发射的数据相互配合返回的Observable。</li>
<li><code>Func2</code>参数：定义已发射的数据如何与新发射的数据项相结合。</li>
<li>如下练习的例子，我们可以修改<code>loadList()</code>函数像下面这样：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadList</span><span class="params">(List&lt;AppInfo&gt; apps)</span> </span>&#123;</span><br><span class="line">    mRecyclerView.setVisibility(View.VISIBLE);</span><br><span class="line">    </span><br><span class="line">    Observable&lt;AppInfo&gt; appsSequence =</span><br><span class="line">    Observable.interval(<span class="number">1000</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">                .map(position -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> apps.get(position.intValue());</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">    Observable&lt;Long&gt; tictoc = Observable.interval(<span class="number">1000</span>,TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    appsSequence.join(</span><br><span class="line">        tictoc, </span><br><span class="line">        appInfo -&gt; Observable.timer(<span class="number">2</span>,TimeUnit.SECONDS),</span><br><span class="line">        time -&gt; Observable.timer(<span class="number">0</span>, TimeUnit.SECONDS),</span><br><span class="line">        <span class="keyword">this</span>::updateTitle)</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .take(<span class="number">10</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;AppInfo&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Toast.makeText(getActivity(), <span class="string">"Here is the list!"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>); </span><br><span class="line">                Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfoappInfo)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mSwipeRefreshLayout.isRefreshing()) &#123;</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                mAddedApps.add(appInfo);</span><br><span class="line">                <span class="keyword">int</span> position = mAddedApps.size() - <span class="number">1</span>;</span><br><span class="line">                mAdapter.addApplication(position, appInfo);</span><br><span class="line">                mRecyclerView.smoothScrollToPosition(position);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们有一个新的对象<code>appsSequence</code>，它是一个每秒从我们已安装的app列表发射app数据的可观测序列。<code>tictoc</code>这个Observable数据每秒只发射一个新的<code>Long</code>型整数。为了合并它们，我们需要指定两个<code>Func1</code>变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appInfo -&gt; Observable.timer(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line"></span><br><span class="line">time -&gt; Observable.timer(<span class="number">0</span>, TimeUnit.SECONDS)</span><br></pre></td></tr></table></figure>
<p>上面描述了两个时间窗口。下面一行描述我们如何使用<code>Func2</code>将两个发射的数据结合在一起。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>::updateTitle</span><br></pre></td></tr></table></figure></p>
<p>结果如下：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter6_7.png" width="240"></p>
<p>它看起来有点乱，但是注意app的名字和我们指定的时间窗口，我们可以看到：一旦第二个数据发射了我们就会将它与源数据结合，但我们用同一个源数据有2秒钟。这就是为什么标题重复数字累加的原因。</p>
<p>值得一提的是，为了简单起见，也有一个<code>join()</code>操作符作用于字符串然后简单的和发射的字符串连接成最终的字符串。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter6_8.png" alt=""></p>
<h2 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h2><p>RxJava的<code>combineLatest()</code>函数有点像<code>zip()</code>函数的特殊形式。正如我们已经学习的，<code>zip()</code>作用于最近未打包的两个Observables。相反，<code>combineLatest()</code>作用于最近发射的数据项：如果<code>Observable1</code>发射了A并且<code>Observable2</code>发射了B和C，<code>combineLatest()</code>将会分组处理AB和AC，如下图所示：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter6_9.png" alt=""></p>
<p><code>combineLatest()</code>函数接受二到九个Observable作为参数，如果有需要的话或者单个Observables列表作为参数。</p>
<p>从之前的例子中把<code>loadList()</code>函数借用过来，我们可以修改一下来用于<code>combineLatest()</code>实现“真实世界”这个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadList</span><span class="params">(List&lt;AppInfo&gt; apps)</span> </span>&#123;</span><br><span class="line">    mRecyclerView.setVisibility(View.VISIBLE);</span><br><span class="line">    Observable&lt;AppInfo&gt; appsSequence = Observable.interval(<span class="number">1000</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">              .map(position -&gt;apps.get(position.intValue()));</span><br><span class="line">    Observable&lt;Long&gt; tictoc = Observable.interval(<span class="number">1500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    Observable.combineLatest(appsSequence, tictoc,</span><br><span class="line">               <span class="keyword">this</span>::updateTitle)</span><br><span class="line">       .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;AppInfo&gt;() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"Here is the list!"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfoappInfo)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mSwipeRefreshLayout.isRefreshing()) &#123;</span><br><span class="line">                mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            mAddedApps.add(appInfo);</span><br><span class="line">            <span class="keyword">int</span> position = mAddedApps.size() - <span class="number">1</span>;</span><br><span class="line">            mAdapter.addApplication(position, appInfo);</span><br><span class="line">            mRecyclerView.smoothScrollToPosition(position);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这我们使用了两个Observables：一个是每秒钟从我们已安装的应用列表发射一个App数据，第二个是每隔1.5秒发射一个<code>Long</code>型整数。我们将他们结合起来并执行<code>updateTitle()</code>函数，结果如下：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter6_10.png" width="240"></p>
<p>正如你看到的，由于不同的时间间隔，<code>AppInfo</code>对象如我们所预料的那样有时候会重复。</p>
<h2 id="And-Then和When"><a href="#And-Then和When" class="headerlink" title="And,Then和When"></a>And,Then和When</h2><p>在将来还有一些<code>zip()</code>满足不了的场景。如复杂的架构，或者是仅仅为了个人爱好，你可以使用And/Then/When解决方案。它们在RxJava的joins包下，使用Pattern和Plan作为中介，将发射的数据集合并到一起。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter6_11.png" alt=""></p>
<p>我们的<code>loadList()</code>函数将会被修改从这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadList</span><span class="params">(List&lt;AppInfo&gt; apps)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    mRecyclerView.setVisibility(View.VISIBLE);</span><br><span class="line"></span><br><span class="line">    Observable&lt;AppInfo&gt; observableApp = Observable.from(apps);</span><br><span class="line">    </span><br><span class="line">    Observable&lt;Long&gt; tictoc = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    </span><br><span class="line">    Pattern2&lt;AppInfo, Long&gt; pattern = JoinObservable.from(observableApp).and(tictoc); </span><br><span class="line">    </span><br><span class="line">    Plan0&lt;AppInfo&gt; plan = pattern.then(<span class="keyword">this</span>::updateTitle);</span><br><span class="line">    </span><br><span class="line">    JoinObservable</span><br><span class="line">        .when(plan)</span><br><span class="line">        .toObservable()</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;AppInfo&gt;() &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Toast.makeText(getActivity(), <span class="string">"Here is the list!"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>); </span><br><span class="line">                Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfoappInfo)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mSwipeRefreshLayout.isRefreshing()) &#123; </span><br><span class="line">                mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                mAddedApps.add(appInfo);</span><br><span class="line">                <span class="keyword">int</span> position = mAddedApps.size() - <span class="number">1</span>;</span><br><span class="line">                mAdapter.addApplication(position, appInfo); mRecyclerView.smoothScrollToPosition(position);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和通常一样，我们有两个发射的序列，<code>observableApp</code>，发射我们安装的应用列表数据，<code>tictoc</code>每秒发射一个<code>Long</code>型整数。现在我们用<code>and()</code>连接源Observable和第二个Observable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JoinObservable.from(observableApp).and(tictoc);</span><br></pre></td></tr></table></figure>
<p>这里创建一个<code>pattern</code>对象，使用这个对象我们可以创建一个<code>Plan</code>对象:”我们有两个发射数据的Observables,<code>then()</code>是做什么的？”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern.then(<span class="keyword">this</span>::updateTitle);</span><br></pre></td></tr></table></figure></p>
<p>现在我们有了一个<code>Plan</code>对象并且当plan发生时我们可以决定接下来发生的事情。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.when(plan).toObservable()</span><br></pre></td></tr></table></figure></p>
<p>这时候，我们可以订阅新的Observable，正如我们总是做的那样。</p>
<h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>有这样一个复杂的场景就是在一个<code>subscribe-unsubscribe</code>的序列里我们能够从一个Observable自动取消订阅来订阅一个新的Observable。</p>
<p>RxJava的<code>switch()</code>，正如定义的，将一个发射多个Observables的Observable转换成另一个单独的Observable，后者发射那些Observables最近发射的数据项。</p>
<p>给出一个发射多个Observables序列的源Observable，<code>switch()</code>订阅到源Observable然后开始发射由第一个发射的Observable发射的一样的数据。当源Observable发射一个新的Observable时，<code>switch()</code>立即取消订阅前一个发射数据的Observable（因此打断了从它那里发射的数据流）然后订阅一个新的Observable，并开始发射它的数据。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter6_12.png" alt=""></p>
<h2 id="StartWith"><a href="#StartWith" class="headerlink" title="StartWith"></a>StartWith</h2><p>我们已经学到如何连接多个Observables并追加指定的值到一个发射序列里。RxJava的<code>startWith()</code>是<code>concat()</code>的对应部分。正如<code>concat()</code>向发射数据的Observable追加数据那样，在Observable开始发射他们的数据之前， <code>startWith()</code>通过传递一个参数来先发射一个数据序列。  </p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter6_13.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这章中，我们学习了如何将两个或者更多个Observable结合来创建一个新的可观测序列。我们将能够<code>merge</code> Observable，<code>join</code> Observables ，<code>zip</code> Observables 并在几种情况下把他们结合在一起。</p>
<p>下一章，我们将介绍调度器，它将很容易的帮助我们创建主线程以及提高我们应用程序的性能。我们也将学习如何正确的执行长任务或者I/O任务来获得更好的性能。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RxJava开发精要5 - Observables变换]]></title>
      <url>http://yoursite.com/2016/06/08/chap5/</url>
      <content type="html"><![CDATA[<h1 id="RxJava开发精要5-Observables变换"><a href="#RxJava开发精要5-Observables变换" class="headerlink" title="RxJava开发精要5 - Observables变换"></a>RxJava开发精要5 - Observables变换</h1><blockquote>
<ul>
<li>原文出自《RxJava Essentials》</li>
<li>原文作者 : <a href="https://www.packtpub.com/books/info/authors/ivan-morgillo" target="_blank" rel="external">Ivan Morgillo</a></li>
<li>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>转载声明: 本译文已授权<a href="http://toutiao.io/download" target="_blank" rel="external">开发者头条</a>享有独家转载权，未经允许，不得转载!</li>
<li>译者 : <a href="https://github.com/yuxingxin" target="_blank" rel="external">yuxingxin</a> </li>
<li>项目地址 : <a href="https://github.com/yuxingxin/RxJava-Essentials-CN" target="_blank" rel="external">RxJava-Essentials-CN</a></li>
</ul>
</blockquote>
<p>在上一章中，我们探索了RxJava通用过滤方法。我们学习了如何使用<code>filter()</code>方法过滤我们不需要的值，如何使用<code>take()</code>得到发射元素的子集，如何使用<code>distinct()</code>函数来去除重复的。我们学习了如何使用<code>timeout()</code>，<code>sample()</code>，以及<code>debounce()</code>来利用时间。</p>
<p>这一章中，我们将学习如何变换可观测序列来创建一个更好满足我们需求的序列。</p>
<h2 id="map家族"><a href="#map家族" class="headerlink" title="*map家族"></a>*map家族</h2><p>RxJava提供了几个mapping函数：<code>map()</code>,<code>flatMap()</code>,<code>concatMap()</code>,<code>flatMapIterable()</code>以及<code>switchMap()</code>.所有这些函数都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。让我们用“真实世界”合适的例子一个个的学习下。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>RxJava的<code>map</code>函数接收一个指定的<code>Func</code>对象然后将它应用到每一个由Observable发射的值上。下图展示了如何将一个乘法函数应用到每个发出的值上以此创建一个新的Observable来发射转换的数据。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_1.png" alt=""></p>
<p>考虑我们已安装的应用列表。我们怎么才能够显示同样的列表，但是所有的名字都是小写。</p>
<p>我们的<code>loadList()</code>函数可以改成这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadList</span><span class="params">(List&lt;AppInfo&gt; apps)</span> </span>&#123;</span><br><span class="line">    mRecyclerView.setVisibility(View.VISIBLE);</span><br><span class="line">    Observable.from(apps)</span><br><span class="line">        .map(<span class="keyword">new</span> Func1&lt;AppInfo,AppInfo&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Appinfo <span class="title">call</span><span class="params">(AppInfo appInfo)</span></span>&#123;</span><br><span class="line">                String currentName = appInfo.getName();</span><br><span class="line">                String lowerCaseName = currentName.toLowerCase();</span><br><span class="line">                appInfo.setName(lowerCaseName);</span><br><span class="line">                <span class="keyword">return</span> appInfo;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observable&lt;AppInfo&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123;</span><br><span class="line">                mAddedApps.add(appInfo); </span><br><span class="line">                mAdapter.addApplication(mAddedApps.size() - <span class="number">1</span>,appInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正如你看到的，像往常一样创建我们发射的Observable，我们加一个<code>map</code>调用，我们可以创建一个简单的函数来更新<code>AppInfo</code>对象并提供一个名字小写的新版本给观察者。</p>
<h2 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h2><p>在复杂的场景中，我们有一个这样的Observable：它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的<code>flatMap()</code>函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_2.png" alt=""></p>
<p>当我们在处理可能有大量的Observables时，重要是记住任何一个Observables发生错误的情况，<code>flatMap()</code>函数将会触发它自己的<code>onError()</code>函数并放弃整个链。</p>
<p>重要的一点是关于合并部分：它允许交叉。正如上图所示，这意味着<code>flatMap()</code>函数在最后的Observable中不能够保证源Observables确切的发射顺序。</p>
<h2 id="ConcatMap"><a href="#ConcatMap" class="headerlink" title="ConcatMap"></a>ConcatMap</h2><p>RxJava的<code>concatMap()</code>函数解决了<code>flatMap()</code>的交叉问题，提供了一种能够把发射的值连续在一起的铺平函数，而不是合并它们，如下图所示：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_3.png" alt=""></p>
<h2 id="FlatMapIterable"><a href="#FlatMapIterable" class="headerlink" title="FlatMapIterable"></a>FlatMapIterable</h2><p>作为*map家族的一员，<code>flatMapInterable()</code>和<code>flatMap()</code>很像。仅有的本质不同是它将源数据两两结成对，然后生成Iterable而不是原始数据和生成的Observables。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_4.png" alt=""></p>
<h2 id="SwitchMap"><a href="#SwitchMap" class="headerlink" title="SwitchMap"></a>SwitchMap</h2><p>如下图所示，<code>switchMap()</code>和<code>flatMap()</code>很像，除了一点：当原始Observable发射一个新的数据（Observable）时，它将取消订阅并停止监视之前那个数据的Observable产生的Observable，并开始监视当前这一个。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_5.png" alt=""></p>
<h2 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h2><p>RxJava的<code>scan()</code>函数可以看做是一个累加器函数。<code>scan()</code>函数对原始Observable发射的每一项数据都应用一个函数，它将函数的结果填充回可观测序列，等待和下一次发射的数据一起使用。</p>
<p>作为一个通用的例子，给出一个累加器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">        .scan((sum,item) -&gt; sum + item)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(<span class="string">"RXJAVA"</span>, <span class="string">"Sequence completed."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.e(<span class="string">"RXJAVA"</span>, <span class="string">"Something went south!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer item)</span> </span>&#123;</span><br><span class="line">                Log.d(<span class="string">"RXJAVA"</span>, <span class="string">"item is: "</span> + item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们得到的结果是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RXJAVA: item is: <span class="number">1</span></span><br><span class="line">RXJAVA: item is: <span class="number">3</span></span><br><span class="line">RXJAVA: item is: <span class="number">6</span></span><br><span class="line">RXJAVA: item is: <span class="number">10</span></span><br><span class="line">RXJAVA: item is: <span class="number">15</span></span><br><span class="line">RXJAVA: Sequence completed.</span><br></pre></td></tr></table></figure></p>
<p>我们也可以创建一个新版本的<code>loadList()</code>函数用来比较每个安装应用的名字从而创建一个名字长度递增的列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadList</span><span class="params">(List&lt;AppInfo&gt; apps)</span> </span>&#123;</span><br><span class="line">    mRecyclerView.setVisibility(View.VISIBLE);</span><br><span class="line">    Observable.from(apps)</span><br><span class="line">            .scan((appInfo,appInfo2) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(appInfo.getName().length &gt; appInfo2.getName().length())&#123;</span><br><span class="line">                    <span class="keyword">return</span> appInfo;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> appInfo2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .distinct()</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Observable&lt;AppInfo&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                    Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123;</span><br><span class="line">                    mAddedApps.add(appInfo); </span><br><span class="line">                    mAdapter.addApplication(mAddedApps.size() - <span class="number">1</span>,appInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_6.png" width="240"></p>
<p>有一个<code>scan()</code>函数的变体，它用初始值作为第一个发射的值，方法特征就像：<code>scan(R,Func2)</code>，就像下图中的例子这样：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_7.png"></p>
<h2 id="GroupBy"><a href="#GroupBy" class="headerlink" title="GroupBy"></a>GroupBy</h2><p>拿第一个例子开始，我们安装的应用程序列表按照字母表的顺序排序。然而，如果现在我们想按照最近更新日期来排序我们的App时该怎么办？RxJava提供了一个有用的函数从列表中按照指定的规则：<code>groupBy()</code>来分组元素。下图中的例子展示了<code>groupBy()</code>如何将发射的值根据他们的形状来进行分组。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_8.png" alt=""></p>
<p>这个函数将源Observable变换成一个发射Observables的新的Observable。它们中的每一个新的Observable都发射一组指定的数据。</p>
<p>为了创建一个分组了的已安装应用列表，我们在<code>loadList()</code>函数中引入了一个新的元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;GroupedObservable&lt;String,AppInfo&gt;&gt; groupedItems = Observable.from(apps)</span><br><span class="line">    .groupBy(<span class="keyword">new</span> Func1&lt;AppInfo,String&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(AppInfo appInfo)</span></span>&#123;</span><br><span class="line">            SimpleDateFormat formatter = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"MM/yyyy"</span>);</span><br><span class="line">            <span class="keyword">return</span> formatter.format(<span class="keyword">new</span> Date(appInfo.getLastUpdateTime()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>现在我们创建了一个新的Observable，<code>groupedItems</code>，将会发射一个带有<code>GroupedObservable</code>的序列。<code>GroupedObservable</code>是一个特殊的Observable，它源自一个分组的key。在这个例子中，key就是<code>String</code>，代表的意思是<code>Month/Year</code>格式化的最近更新日期。</p>
<p>这一点，我们已经创建了几个发射<code>AppInfo</code>数据的Observable，用来填充我们的列表。我们想保留字母排序和分组排序。我们将创建一个新的Observable将所有的联系起来，像通常一样然后订阅它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable.concat(groupedItems)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observable&lt;AppInfo&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123;</span><br><span class="line">            mAddedApps.add(appInfo); </span><br><span class="line">            mAdapter.addApplication(mAddedApps.size() - <span class="number">1</span>,appInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>我们的<code>loadList()</code>函数完成了，结果是：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_9.png" width="240"></p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>RxJava中的<code>buffer()</code>函数将源Observable变换一个新的Observable，这个新的Observable每次发射一组列表值而不是一个一个发射。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_10.png" alt=""></p>
<p>上图中展示了<code>buffer()</code>如何将<code>count</code>作为一个参数来指定有多少数据项被包在发射的列表中。实际上，<code>buffer()</code>函数有几种变体。其中有一个时允许你指定一个<code>skip</code>值：此后每当收到skip项数据，用count项数据就填充缓存。如下图所示：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_11.png" alt=""></p>
<p><code>buffer()</code>带一个<code>timespan</code>的参数，会创建一个每隔timespan时间段就会发射一个列表的Observable。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_12.png" alt=""></p>
<h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><p>RxJava的<code>window()</code>函数和<code>buffer()</code>很像，但是它发射的时Observable而不是列表。下图展示了<code>window()</code>如何缓存3个数据项并把它们作为一个新的Observable发射出去。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_13.png" alt=""></p>
<p>这些Observables中的每一个都发射原始Observable数据的一个子集，数量由<code>count</code>指定,最后发射一个<code>onCompleted()</code>结束。正如<code>buffer()</code>一样,<code>window()</code>也有一个<code>skip</code>变体,如下图所示：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_14.png" alt=""></p>
<h2 id="Cast"><a href="#Cast" class="headerlink" title="Cast"></a>Cast</h2><p>RxJava的<code>cast()</code>函数是本章中最后一个操作符。它是<code>map()</code>操作符的特殊版本。它将源Observable中的每一项数据都转换为新的类型，把它变成了不同的<code>Class</code>。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter5_15.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章中，我们学习了RxJava时如何控制和转换可观测序列。用我们现在所学的知识，我们可以创建、过滤、转换我们所想要的任何种类的可观测序列。</p>
<p>下一章，我们将学习如何组合Observable，合并它们，连接它们，再或者打包它们。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RxJava开发精要4 - Observables过滤]]></title>
      <url>http://yoursite.com/2016/06/08/chap4/</url>
      <content type="html"><![CDATA[<h1 id="RxJava开发精要4-Observables过滤"><a href="#RxJava开发精要4-Observables过滤" class="headerlink" title="RxJava开发精要4 - Observables过滤"></a>RxJava开发精要4 - Observables过滤</h1><blockquote>
<ul>
<li>原文出自《RxJava Essentials》</li>
<li>原文作者 : <a href="https://www.packtpub.com/books/info/authors/ivan-morgillo" target="_blank" rel="external">Ivan Morgillo</a></li>
<li>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>转载声明: 本译文已授权<a href="http://toutiao.io/download" target="_blank" rel="external">开发者头条</a>享有独家转载权，未经允许，不得转载!</li>
<li>译者 : <a href="https://github.com/yuxingxin" target="_blank" rel="external">yuxingxin</a> </li>
<li>项目地址 : <a href="https://github.com/yuxingxin/RxJava-Essentials-CN" target="_blank" rel="external">RxJava-Essentials-CN</a></li>
</ul>
</blockquote>
<h2 id="过滤Observables"><a href="#过滤Observables" class="headerlink" title="过滤Observables"></a>过滤Observables</h2><p>在上一章中，我们学习了使用RxJava创建一个Android工程以及如何创建一个可观测的列表来填充RecyclerView。我们现在知道了如何从头、从列表、从一个已存在的传统Java函数来创建Observable。</p>
<p>这一章中，我们将研究可观测序列的本质：过滤。我们将学到如何从发射的Observable中选取我们想要的值，如何获取有限个数的值，如何处理溢出的场景，以及更多的有用的技巧。</p>
<h2 id="过滤序列"><a href="#过滤序列" class="headerlink" title="过滤序列"></a>过滤序列</h2><p>RxJava让我们使用<code>filter()</code>方法来过滤我们观测序列中不想要的值，在上一章中，我们在几个例子中使用了已安装的应用列表，但是我们只想展示以字母<code>C</code>开头的已安装的应用该怎么办呢？在这个新的例子中，我们将使用同样的列表，但是我们会过滤它，通过把合适的谓词传给<code>filter()</code>函数来得到我们想要的值。</p>
<p>上一章中<code>loadList()</code>函数可以改成这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadList</span><span class="params">(List&lt;AppInfo&gt; apps)</span> </span>&#123;</span><br><span class="line">    mRecyclerView.setVisibility(View.VISIBLE);</span><br><span class="line">    Observable.from(apps)</span><br><span class="line">            .filter((appInfo) -&gt;</span><br><span class="line">            appInfo.getName().startsWith(<span class="string">"C"</span>))</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Observable&lt;AppInfo&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                    Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123;</span><br><span class="line">                    mAddedApps.add(appInfo); </span><br><span class="line">                    mAdapter.addApplication(mAddedApps.size() - <span class="number">1</span>,appInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们从上一章中的<code>loadList()</code>函数中添加下面一行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.fliter((appInfo -&gt; appInfo.getName().startsWith(<span class="string">"C"</span>))</span><br></pre></td></tr></table></figure></p>
<p>创建Observable完以后，我们从发出的每个元素中过滤掉开头字母不是C的。为了让这里更清楚一些，我们用Java 7的语法来实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.filter(<span class="keyword">new</span> Func1&lt;AppInfo,Boolean&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(AppInfo appInfo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> appInfo.getName().startsWith(<span class="string">"C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我们传一个新的<code>Func1</code>对象给<code>filter()</code>函数，即只有一个参数的函数。<code>Func1</code>有一个<code>AppInfo</code>对象来作为它的参数类型并且返回<code>Boolean</code>对象。只要条件符合<code>filter()</code>函数就会返回<code>true</code>。此时，值会发射出去并且所有的观察者都会接收到。</p>
<p>正如你想的那样，从一个我们得到的可观测序列中创建一个我们需要的序列<code>filter()</code>是很好用的。我们不需要知道可观测序列的源或者为什么发射这么多不同的数据。我们只是想要这些元素的子集来创建一个可以在应用中使用的新序列。这种思想促进了我们编码中的分离性与抽象性。</p>
<p><code>filter()</code>函数最常用的用法之一时过滤<code>null</code>对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.filter(<span class="keyword">new</span> Func1&lt;AppInfo,Boolean&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(AppInfo appInfo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> appInfo != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这看起来简单，对于简单的事情有许多模板代码，但是它帮我们免去了在<code>onNext()</code>函数调用中再去检测<code>null</code>值，让我们把注意力集中在应用业务逻辑上。</p>
<p>下图展示了过滤出的C字母开头的已安装的应用列表。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter4_1.png" width="240"></p>
<h2 id="获取我们需要的数据"><a href="#获取我们需要的数据" class="headerlink" title="获取我们需要的数据"></a>获取我们需要的数据</h2><p>当我们不需要整个序列时，而是只想取开头或结尾的几个元素，我们可以用<code>take()</code>或<code>takeLast()</code>。</p>
<h2 id="Take"><a href="#Take" class="headerlink" title="Take"></a>Take</h2><p>如果我们只想要一个可观测序列中的前三个元素那将会怎么样，发射它们，然后让Observable完成吗？<code>take()</code>函数用整数N来作为一个参数，从原始的序列中发射前N个元素，然后完成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadList</span><span class="params">(List&lt;AppInfo&gt; apps)</span> </span>&#123;</span><br><span class="line">    mRecyclerView.setVisibility(View.VISIBLE);</span><br><span class="line">    Observable.from(apps)</span><br><span class="line">            .take(<span class="number">3</span>)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Observable&lt;AppInfo&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                    Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123;</span><br><span class="line">                    mAddedApps.add(appInfo); </span><br><span class="line">                    mAdapter.addApplication(mAddedApps.size() - <span class="number">1</span>,appInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下图中展示了发射数字的一个可观测序列。我们对这个可观测序列应用<code>take(2)</code>函数，然后我们创建一个只发射可观测源的第一个和第二个数据的新序列。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter4_2.png" alt=""></p>
<h2 id="TakeLast"><a href="#TakeLast" class="headerlink" title="TakeLast"></a>TakeLast</h2><p>如果我们想要最后N个元素，我们只需使用<code>takeLast()</code>函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(apps)</span><br><span class="line">        .takeLast(<span class="number">3</span>)</span><br><span class="line">        .subscribe(https:<span class="comment">//github.com/yuxingxin/RxJava-Essentials-CN/raw/master.);</span></span><br></pre></td></tr></table></figure></p>
<p>正如听起来那样不值一提，重点注意<code>takeLast()</code>函数由于用一组有限的发射数的本质使得它仅可用于完成的序列。</p>
<p>下图中展示了如何从可观测源中发射最后一个元素来创建一个新的序列：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter4_3.png" alt=""></p>
<p>下图中展示了我们在已安装的应用列表使用<code>take()</code>和<code>takeLast()</code>函数后发生的结果：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter4_4.png" alt=""></p>
<h2 id="有且仅有一次"><a href="#有且仅有一次" class="headerlink" title="有且仅有一次"></a>有且仅有一次</h2><p>一个可观测序列会在出错时重复发射或者被设计成重复发射。<code>distinct()</code>和<code>distinctUntilChanged()</code>函数可以方便的让我们处理这种重复问题。</p>
<h2 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h2><p>如果我们想对一个指定的值仅处理一次该怎么办？我们可以对我们的序列使用<code>distinct()</code>函数去掉重复的。就像<code>takeLast()</code>一样，<code>distinct()</code>作用于一个完整的序列，然后得到重复的过滤项，它需要记录每一个发射的值。如果你在处理一大堆序列或者大的数据记得关注内存使用情况。</p>
<p>下图展示了如何在一个发射1和2两次的可观测源上创建一个无重的序列：<br><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter4_5.png" alt=""></p>
<p>为了创建我们例子中序列，我们将使用我们至今已经学到的几个方法：</p>
<ul>
<li><code>take()</code>：它有一小组的可识别的数据项。</li>
<li><code>repeat()</code>：创建一个有重复的大的序列。</li>
</ul>
<p>然后，我们将应用<code>distinct()</code>函数来去除重复。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>我们用程序实现一个重复的序列，然后过滤出它们。这听起来时不可思议的，但是为了实现这个例子来使用我们至今为止已学习到的东西则是个不错的练习。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;AppInfo&gt; fullOfDuplicates = Observable.from(apps)</span><br><span class="line">    .take(<span class="number">3</span>)</span><br><span class="line">    .repeat(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p><code>fullOfDuplicates</code>变量里把我们已安装应用的前三个重复了3次：有9个并且许多重复的。然后，我们使用<code>distinct()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fullOfDuplicates.distinct()</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Observable&lt;AppInfo&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                    Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123;</span><br><span class="line">                    mAddedApps.add(appInfo); </span><br><span class="line">                    mAdapter.addApplication(mAddedApps.size() - <span class="number">1</span>,appInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果，很明显，我们得到：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter4_6.png" width="240"></p>
<h2 id="DistinctUntilsChanged"><a href="#DistinctUntilsChanged" class="headerlink" title="DistinctUntilsChanged"></a>DistinctUntilsChanged</h2><p>如果在一个可观测序列发射一个不同于之前的一个新值时让我们得到通知这时候该怎么做？我们猜想一下我们观测的温度传感器，每秒发射的室内温度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21°https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master.21°https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master.21°https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master.21°https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master.22°https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master.</span><br></pre></td></tr></table></figure></p>
<p>每次我们获得一个新值，我们都会更新当前正在显示的温度。我们出于系统资源保护并不想在每次值一样时更新数据。我们想忽略掉重复的值并且在温度确实改变时才想得到通知。<code>ditinctUntilChanged()</code>过滤函数能做到这一点。它能轻易的忽略掉所有的重复并且只发射出新的值。</p>
<p>下图用图形化的方式展示了我们如何将<code>distinctUntilChanged()</code>函数应用在一个存在的序列上来创建一个新的不重复发射元素的序列。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter4_7.png" alt=""></p>
<h2 id="First-and-last"><a href="#First-and-last" class="headerlink" title="First and last"></a>First and last</h2><p>下图展示了如何从一个从可观测源序列中创建只发射第一个元素的序列。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter4_8.png" alt=""></p>
<p><code>first()</code>方法和<code>last()</code>方法很容易弄明白。它们从Observable中只发射第一个元素或者最后一个元素。这两个都可以传<code>Func1</code>作为参数，：一个可以确定我们感兴趣的第一个或者最后一个的谓词：</p>
<p>下图展示了<code>last()</code>应用在一个完成的序列上来创建一个仅仅发射最后一个元素的新的Observable。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter4_9.png" alt=""></p>
<p>与<code>first()</code>和<code>last()</code>相似的变量有：<code>firstOrDefault()</code>和<code>lastOrDefault()</code>.这两个函数当可观测序列完成时不再发射任何值时用得上。在这种场景下，如果Observable不再发射任何值时我们可以指定发射一个默认的值</p>
<h2 id="Skip-and-SkipLast"><a href="#Skip-and-SkipLast" class="headerlink" title="Skip and SkipLast"></a>Skip and SkipLast</h2><p>下图中展示了如何使用<code>skip(2)</code>来创建一个不发射前两个元素而是发射它后面的那些数据的序列。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter4_10.png" alt=""></p>
<p><code>skip()</code>和<code>skipLast()</code>函数与<code>take()</code>和<code>takeLast()</code>相对应。它们用整数N作参数，从本质上来说，它们不让Observable发射前N个或者后N个值。如果我们知道一个序列以没有太多用的“可控”元素开头或结尾时我们可以使用它。</p>
<p>下图与前一个场景相对应：我们创建一个新的序列，它会跳过后面两个元素从源序列中发射剩下的其他元素。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter4_11.png" alt=""></p>
<h2 id="ElementAt"><a href="#ElementAt" class="headerlink" title="ElementAt"></a>ElementAt</h2><p>如果我们只想要可观测序列发射的第五个元素该怎么办？<code>elementAt()</code>函数仅从一个序列中发射第n个元素然后就完成了。</p>
<p>如果我们想查找第五个元素但是可观测序列只有三个元素可供发射时该怎么办？我们可以使用<code>elementAtOrDefault()</code>。下图展示了如何通过使用<code>elementAt(2)</code>从一个序列中选择第三个元素以及如何创建一个只发射指定元素的新的Observable。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter4_12.png" alt=""></p>
<h2 id="Sampling"><a href="#Sampling" class="headerlink" title="Sampling"></a>Sampling</h2><p>让我们再回到那个温度传感器。它每秒都会发射当前室内的温度。说实话，我们并不认为温度会变化这么快，我们可以使用一个小的发射间隔。在Observable后面加一个<code>sample()</code>，我们将创建一个新的可观测序列，它将在一个指定的时间间隔里由Observable发射最近一次的数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; sensor = [...]</span><br><span class="line"></span><br><span class="line">sensor.sample(<span class="number">30</span>,TimeUnit.SECONDS)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observable&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer currentTemperature)</span> </span>&#123;</span><br><span class="line">            updateDisplay(currentTemperature)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>例子中Observable将会观测温度Observable然后每隔30秒就会发射最后一个温度值。很明显，<code>sample()</code>支持全部的时间单位：秒，毫秒，天，分等等。</p>
<p>下图中展示了一个间隔发射字母的Observable如何采样一个发射数字的Observable。Observable的结果将会发射每个已发射字母的最后一组数据：1，4，5.</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter4_13.png" alt=""></p>
<p>如果我们想让它定时发射第一个元素而不是最近的一个元素，我们可以使用<code>throttleFirst()</code>。</p>
<h2 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h2><p>假设我们工作的是一个时效性的环境，我们温度传感器每秒都在发射一个温度值。我们想让它每隔两秒至少发射一个，我们可以使用<code>timeout()</code>函数来监听源可观测序列,就是在我们设定的时间间隔内如果没有得到一个值则发射一个错误。我们可以认为<code>timeout()</code>为一个Observable的限时的副本。如果在指定的时间间隔内Observable不发射值的话，它监听的原始的Observable时就会触发<code>onError()</code>函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Subscription subscription = getCurrentTemperature()</span><br><span class="line">    .timeout(<span class="number">2</span>,TimeUnit.SECONDS)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observable&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"RXJAVA"</span>,<span class="string">"You should go check the sensor, dude"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer currentTemperature)</span> </span>&#123;</span><br><span class="line">            updateDisplay(currentTemperature)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>和<code>sample()</code>一样，<code>timeout()</code>使用<code>TimeUnit</code>对象来指定时间间隔。</p>
<p>下图中展示了一旦Observable超过了限时就会触发<code>onError()</code>函数：因为超时后它才到达，所以最后一个元素将不会发射出去。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter4_14.png" alt=""></p>
<h2 id="Debounce"><a href="#Debounce" class="headerlink" title="Debounce"></a>Debounce</h2><p><code>debounce()</code>函数过滤掉由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。</p>
<p>就像<code>sample()</code>和<code>timeout()</code>函数一样，<code>debounce()</code>使用<code>TimeUnit</code>对象指定时间间隔。</p>
<p>下图展示了多久从Observable发射一次新的数据，<code>debounce()</code>函数开启一个内部定时器，如果在这个时间间隔内没有新的数据发射，则新的Observable发射出最后一个数据：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter4_15.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章中，我们学习了如何过滤一个可观测序列。我们现在可以使用<code>filter()</code>，<code>skip()</code>，和<code>sample()</code>来创建我们想要的Observable。</p>
<p>下一章中，我们将学习如何转换一个序列，将函数应用到每个元素，给它们分组和扫描来创建我们所需要的能完成目标的特定Observable。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RxJava开发精要3-向响应式世界问好]]></title>
      <url>http://yoursite.com/2016/06/08/chap3/</url>
      <content type="html"><![CDATA[<h1 id="RxJava开发精要3-向响应式世界问好"><a href="#RxJava开发精要3-向响应式世界问好" class="headerlink" title="RxJava开发精要3-向响应式世界问好"></a>RxJava开发精要3-向响应式世界问好</h1><blockquote>
<ul>
<li>原文出自《RxJava Essentials》</li>
<li>原文作者 : <a href="https://www.packtpub.com/books/info/authors/ivan-morgillo" target="_blank" rel="external">Ivan Morgillo</a></li>
<li>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>转载声明: 本译文已授权<a href="http://toutiao.io/download" target="_blank" rel="external">开发者头条</a>享有独家转载权，未经允许，不得转载!</li>
<li>译者 : <a href="https://github.com/yuxingxin" target="_blank" rel="external">yuxingxin</a> </li>
<li>项目地址 : <a href="https://github.com/yuxingxin/RxJava-Essentials-CN" target="_blank" rel="external">RxJava-Essentials-CN</a></li>
</ul>
</blockquote>
<h2 id="向响应式世界问好"><a href="#向响应式世界问好" class="headerlink" title="向响应式世界问好"></a>向响应式世界问好</h2><p>在上一章中，我们对观察者模式有个理论上的快速概述。我们也看了从头开始、从列表、或者从已经存在的函数来创建Observables。在本章中，我们将用我们学到的来创建我们第一个响应式Android应用程序。首先，我们需要搭建环境，导入需要的库和有用的库。然后我们将创建一个简单的应用程序，在不同的flavors中包含几个用RxJava填充的RecycleView items。</p>
<h2 id="启动引擎"><a href="#启动引擎" class="headerlink" title="启动引擎"></a>启动引擎</h2><p>我们将使用IntelliJ IDEA/Android Studio来创建这个工程，因此你会对截图看起来比较熟悉。</p>
<p>让我们开始创建一个新的Android工程。你可以创建你自己的工程或者用本书中提供的导入。选择你自己喜欢的创建方式这取决于你。</p>
<p>如果你想用Android Studio创建一个新的工程，通常你可以参考官方文档：<a href="http://developer.android.com/intl/zh-cn/training/basics/firstapp/creating-project.html" target="_blank" rel="external">http://developer.android.com/intl/zh-cn/training/basics/firstapp/creating-project.html</a></p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter3_1.png" alt=""></p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>很明显，我们将使用<strong>Gradle</strong>来管理我们的依赖列表。我们的build.gradble文件看起来像这样：<br> <img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter3_2.png" alt=""><br> <img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter3_3.png" alt=""><br>正如你看到的我们引入了RxAndroid。RxAndroid是RxJava的增强版，尤其是针对Android设计的。</p>
<h3 id="RxAndroid"><a href="#RxAndroid" class="headerlink" title="RxAndroid"></a>RxAndroid</h3><p>RxAndroid是RxJava家族的一部分。它基于RxJava1.0.x,在普通的RxJava基础上添加了几个有用的类。大多数情况下，它为Android添加了特殊的调度器。我们将在第七章Schedulers-Defeating the Android MainThread Issue再讨论它。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>出于实用，我们引入了Lombok 和 Butter Knife。这两个可以帮助我们在Android应用程序中少写许多模板类代码。</p>
<h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p>Lombok使用注解的方式为你生成许多代码。我们将使用它老生成<code>getter/setter</code>、<code>toString()</code>、<code>equals()</code>、<code>hashCode()</code>。它借助于Gradle依赖和一个Android Studio插件。</p>
<h3 id="Butter-Knife"><a href="#Butter-Knife" class="headerlink" title="Butter Knife"></a>Butter Knife</h3><p>Butter Knife使用注解的方式来帮助我们免去写<code>findViewById()</code>和设置点击监听的痛苦。至于Lombok,我们可以通过导入依赖和安装Android Studio插件来获得更好的体验。</p>
<h3 id="Retrolambda"><a href="#Retrolambda" class="headerlink" title="Retrolambda"></a>Retrolambda</h3><p>最后，我们导入Retrolambda，是因为我们开发的Android是基于Java 1.6，然后我们可以借助它来实现Java 8 Lambda函数从而减少许多模板代码。</p>
<h2 id="我们的第一个Observable"><a href="#我们的第一个Observable" class="headerlink" title="我们的第一个Observable"></a>我们的第一个Observable</h2><p>在我们的第一个列子里，我们将检索安装的应用列表并填充RecycleView的item来展示它们。我们也设想一个下拉刷新的功能和一个进度条来告知用户当前任务正在执行。</p>
<p>首先，我们创建Observable。我们需要一个函数来检索安装的应用程序列表并把它提供给我们的观察者。我们一个接一个的发射这些应用程序数据，将它们分组到一个单独的列表中，以此来展示响应式方法的灵活性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;AppInfo&gt; <span class="title">getApps</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(subscriber -&gt; &#123;</span><br><span class="line">        List&lt;AppInfoRich&gt; apps = <span class="keyword">new</span> ArrayList&lt;AppInfoRich&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Intent mainIntent = <span class="keyword">new</span> Intent(Intent.ACTION_MAIN,<span class="keyword">null</span>);</span><br><span class="line">        mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);</span><br><span class="line"></span><br><span class="line">        List&lt;ResolveInfo&gt; infos = getActivity().getPackageManager().queryIntentActivities(mainIntent, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(ResolveInfo info : infos)&#123;</span><br><span class="line">            apps.add(<span class="keyword">new</span> AppInfoRich(getActivity(),info));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (AppInfoRich appInfo:apps) &#123;</span><br><span class="line">            Bitmap icon = Utils.drawableToBitmap(appInfo.getIcon());</span><br><span class="line">            String name = appInfo.getName();</span><br><span class="line">            String iconPath = mFilesDir + <span class="string">"/"</span> + name;</span><br><span class="line">            Utils.storeBitmap(App.instance, icon,name);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (subscriber.isUnsubscribed())&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            subscriber.onNext(<span class="keyword">new</span> AppInfo(name,iconPath,appInfo.getLastUpdateTime()));                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!subscriber.isUnsubscribed())&#123;</span><br><span class="line">            subscriber.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AppInfo对象如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(prefix = <span class="string">"m"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInfo</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> mLastUpdateTime;</span><br><span class="line">    String mName;</span><br><span class="line">    String mIcon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppInfo</span><span class="params">(String nName, <span class="keyword">long</span> lastUpdateTime, String icon)</span> </span>&#123;</span><br><span class="line">        mName = nName;</span><br><span class="line">        mIcon = icon;</span><br><span class="line">        mLastUpdateTime = lastUpdateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object another)</span> </span>&#123;</span><br><span class="line">        AppInfo f = (AppInfo)another;</span><br><span class="line">        <span class="keyword">return</span> getName().compareTo(f.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要重点注意的是在发射新的数据或者完成序列之前要检测观察者的订阅情况。这样的话代码会更高效，因为如果没有观察者等待时我们就不生成没有必要的数据项。</p>
<p>此时，我们可以订阅Observable并观察它。订阅一个Observable意味着当我们需要的数据进来时我们必须提供对应的操作来执行它。</p>
<p>当前的场景是什么？我们展示一个进度条来等待数据。当数据到来时，我们需要隐藏掉进度条,填充list,最终展示列表。现在，我们知道当一切都准备好了该做什么。那么错误的场景呢？对于错误这种情况，我们仅仅是用Toast展示一个错误的信息。</p>
<p>使用Butter Knife,我们得到list和下拉刷新组件的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InjetcView</span>(R.id.fragment_first_example_list)</span><br><span class="line">RecyclerView mRecycleView;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@InjectView</span>(R.id.fragment_first_example_swipe_container)</span><br><span class="line">SwipeRefreshLayout mSwipeRefreshLayout;</span><br></pre></td></tr></table></figure>
<p>我们使用Android 5的标准组件：RecyclerView和SwipeRefreshLayout。截屏展示了我们这个简单App的list Fragment的layout文件：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter3_4.png" alt=""></p>
<p>我们使用一个下拉刷新方法，因此列表数据可以来自初始化加载，或由用户触发的一个刷新动作。针对这两个场景，我们用同样的行为，因此我们把我们的观察者放在一个易被复用的函数里面。下面是我们的观察者，定义了成功、失败、完成要做的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshTheList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getApps().toSortedList()</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Observable&lt;List&lt;AppInfo&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Toast.makeText(getActivity(), <span class="string">"Here is the list!"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                    Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(List&lt;AppInfo&gt; appInfos)</span> </span>&#123;</span><br><span class="line">                    mRecyclerView.setVisibility(View.VISIBLE);</span><br><span class="line">                    mAdapter.addApplications(appInfos);</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个函数使我们能够用同样一个block来处理两种场景成为了可能。当fragment加载时我们只需调用<code>refreshTheList()</code>方法并设置<code>refreshTheList()</code>方法作为用户下拉这一行为所触发的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSwipeRefreshLayout.setOnRefreshListener(<span class="keyword">this</span>::refreshTheList);</span><br></pre></td></tr></table></figure>
<p>我们第一个例子现在完成了，运行跑一下。</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter3_5.png" alt=""></p>
<h2 id="从列表创建一个Observable"><a href="#从列表创建一个Observable" class="headerlink" title="从列表创建一个Observable"></a>从列表创建一个Observable</h2><p>在这个例子中，我们将引入<code>from()</code>函数。使用这个特殊的“创建”函数，我们可以从一个列表中创建一个Observable。Observable将发射出列表中的每一个元素，我们可以通过订阅它们来对这些发出的元素做出响应。</p>
<p>为了实现和第一个例子同样的结果，我们在每一个<code>onNext()</code>函数更新我们的适配器，添加元素并通知插入。</p>
<p>我们将复用和第一个例子同样的结构。主要的不同的是我们不再检索已安装的应用列表。列表由外部实体提供：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mApps = ApplicationsList.getInstance().getList();</span><br></pre></td></tr></table></figure>
<p>获得列表后，我们仅需将它响应化并填充RecyclerView的item:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadList</span><span class="params">(List&lt;AppInfo&gt; apps)</span> </span>&#123;</span><br><span class="line">    mRecyclerView.setVisibility(View.VISIBLE);</span><br><span class="line">    Observable.from(apps)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Observable&lt;AppInfo&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                    Toast.makeText(getActivity(), <span class="string">"Here is the list!"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                    Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123;</span><br><span class="line">                    mAddedApps.add(appInfo); </span><br><span class="line">                    mAdapter.addApplication(mAddedApps.size() - <span class="number">1</span>,appInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正如你看到的，我们将已安装的应用程序列表作为参数传进<code>from()</code>函数，然后我们订阅生成的Observable。观察者和我们第一个例子中的观察者十分相像。一个主要的不同是我们在<code>onCompleted()</code>函数中停掉进度条是因为我们一个一个的发射元素；第一个例子中的Observable发射的是整个list,因此在<code>onNext()</code>函数中停掉进度条的做法是安全的。</p>
<h2 id="再多几个例子"><a href="#再多几个例子" class="headerlink" title="再多几个例子"></a>再多几个例子</h2><p>在这一节中，我们将基于RxJava的<code>just()</code>,<code>repeat()</code>,<code>defer()</code>,<code>range()</code>,<code>interval()</code>,和<code>timer()</code>方法展示一些例子。</p>
<h3 id="just"><a href="#just" class="headerlink" title="just()"></a>just()</h3><p>假如我们只有3个独立的AppInfo对象并且我们想把他们转化为Observable并填充到RecyclerView的item中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;AppInfo&gt; apps = ApplicationsList.getInstance().getList();</span><br><span class="line"></span><br><span class="line">AppInfo appOne = apps.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">AppInfo appTwo = apps.get(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">AppInfo appThree = apps.get(<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">loadApps(appOne,appTwo,appThree);</span><br></pre></td></tr></table></figure></p>
<p>我们可以像我们之前的例子那样检索列表并提取出这三个元素。然后我们将他们传到这个<code>loadApps()</code>函数里面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadApps</span><span class="params">(AppInfo appOne,AppInfo appTwo,AppInfo appThree)</span> </span>&#123;</span><br><span class="line">    mRecyclerView.setVisibility(View.VISIBLE);</span><br><span class="line">    Observable.just(appOne,appTwo,appThree)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Observable&lt;AppInfo&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                    Toast.makeText(getActivity(), <span class="string">"Here is the list!"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                    Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123;</span><br><span class="line">                    mAddedApps.add(appInfo); </span><br><span class="line">                    mAdapter.addApplication(mAddedApps.size() - <span class="number">1</span>,appInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正如你看到的，代码和之前的例子很像。这种方法让我们有机会来考虑一下代码的复用。</p>
<p>你可以将一个函数作为参数传给<code>just()</code>方法，你将会得到一个已存在代码的原始Observable版本。在一个新的响应式架构的基础上迁移已存在的代码，这个方法可能是一个有用的开始点。</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>假如你想对一个Observable重复发射三次数据。例如，我们用<code>just()</code>例子中的Observable：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadApps</span><span class="params">(AppInfo appOne,AppInfo appTwo,AppInfo appThree)</span> </span>&#123;</span><br><span class="line">    mRecyclerView.setVisibility(View.VISIBLE);</span><br><span class="line">    Observable.just(appOne,appTwo,appThree)</span><br><span class="line">            .repeat(<span class="number">3</span>)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Observable&lt;AppInfo&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                    Toast.makeText(getActivity(), <span class="string">"Here is the list!"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                    Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    mSwipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123;</span><br><span class="line">                    mAddedApps.add(appInfo); </span><br><span class="line">                    mAdapter.addApplication(mAddedApps.size() - <span class="number">1</span>,appInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你看到的，我们在<code>just()</code>创建Observable后追加了<code>repeat(3)</code>，它将会创建9个元素的序列，每一个都单独发射。</p>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer()"></a>defer()</h3><p>有这样一个场景，你想在这声明一个Observable但是你又想推迟这个Observable的创建直到观察者订阅时。看下面的<code>getInt()</code>函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;Integer&gt; <span class="title">getInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(subscriber -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(subscriber.isUnsubscribed())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        App.L.debug(<span class="string">"GETINT"</span>);</span><br><span class="line">        subscriber.onNext(<span class="number">42</span>);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这比较简单，并且它没有做太多事情，但是它正好为我们服务。现在，我们可以创建一个新的Observable并且应用<code>defer()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; deferred = Observable.defer(<span class="keyword">this</span>::getInt);</span><br></pre></td></tr></table></figure>
<p>这次，<code>deferred</code>存在，但是<code>getInt()</code> <code>create()</code>方法还没有调用:logcat日志也没有“GETINT”打印出来:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deferred.subscribe(number -&gt; &#123;</span><br><span class="line">    App.L.debug(String.valueOf(number));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是一旦我们订阅了，<code>create()</code>方法就会被调用并且我们也可以在logcat日志中得到下卖弄两个：GETINT和42。</p>
<h3 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h3><p>你需要从一个指定的数字X开始发射N个数字吗？你可以用<code>range</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(<span class="number">10</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observable&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"Yeaaah!"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"I say "</span> + number, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>range()</code>函数用两个数字作为参数：第一个是起始点，第二个是我们想发射数字的个数。</p>
<h3 id="interval"><a href="#interval" class="headerlink" title="interval()"></a>interval()</h3><p><code>interval()</code>函数在你需要创建一个轮询程序时非常好用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Subscription stopMePlease = Observable.interval(<span class="number">3</span>,TimeUnit.SECONDS)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observable&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"Yeaaah!"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"Something went wrong!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(getActivity(), <span class="string">"I say "</span> + number, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>interval()</code>函数的两个参数：一个指定两次发射的时间间隔，另一个是用到的时间单位。</p>
<h3 id="timer"><a href="#timer" class="headerlink" title="timer()"></a>timer()</h3><p>如果你需要一个一段时间之后才发射的Observable，你可以像下面的例子使用<code>timer()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable.timer(<span class="number">3</span>,TimeUnit.SECONDS)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observable&lt;Long&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long number)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"RXJAVA"</span>, <span class="string">"I say "</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>它将3秒后发射0,然后就完成了。让我们使用<code>timer()</code>的第三个参数，就像下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable.timer(<span class="number">3</span>,<span class="number">3</span>,TimeUnit.SECONDS)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observable&lt;Long&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long number)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"RXJAVA"</span>, <span class="string">"I say "</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>用这个代码，你可以创建一个以初始值来延迟（上一个例子是3秒）执行的<code>interval()</code>版本，然后每隔N秒就发射一个新的数字（前面的例子是3秒）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本章中，我们创建了第一个由RxJava强化的Android应用程序。我们从头、从已有的列表、从已有的函数来创建Observable。我们也学习了如何创建重复发射的Observables，间隔发射的Observables以及延迟发射的Observables。</p>
<p>在下一章中，我们将掌握过滤操作，能够从我们接收到的序列中创建我们需要的序列。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RxJava开发精要2-为什么是Observables?]]></title>
      <url>http://yoursite.com/2016/06/08/chap2/</url>
      <content type="html"><![CDATA[<h1 id="RxJava开发精要2-为什么是Observables"><a href="#RxJava开发精要2-为什么是Observables" class="headerlink" title="RxJava开发精要2-为什么是Observables?"></a>RxJava开发精要2-为什么是Observables?</h1><blockquote>
<ul>
<li>原文出自《RxJava Essentials》</li>
<li>原文作者 : <a href="https://www.packtpub.com/books/info/authors/ivan-morgillo" target="_blank" rel="external">Ivan Morgillo</a></li>
<li>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>转载声明: 本译文已授权<a href="http://toutiao.io/download" target="_blank" rel="external">开发者头条</a>享有独家转载权，未经允许，不得转载!</li>
<li>译者 : <a href="https://github.com/yuxingxin" target="_blank" rel="external">yuxingxin</a> </li>
<li>项目地址 : <a href="https://github.com/yuxingxin/RxJava-Essentials-CN" target="_blank" rel="external">RxJava-Essentials-CN</a></li>
</ul>
</blockquote>
<h2 id="为什么是Observables"><a href="#为什么是Observables" class="headerlink" title="为什么是Observables?"></a>为什么是Observables?</h2><p>在面向对象的架构中，开发者致力于创建一组解耦的实体。这样的话，实体就可以在不用妨碍整个系统的情况下可以被测试、复用和维护。设计这种系统就带来一个棘手的负面影响：维护相关对象之间的统一。</p>
<p>在Smalltalk MVC架构中，创建模式的第一个例子就是用来解决这个问题的。用户界面框架提供一种途径使UI元素与包含数据的实体对象相分离，并且同时，它提供一种灵活的方法来保持它们之间的同步。</p>
<p>在这本畅销的四人组编写的《设计模式——可复用面向对象软件的基础》一书中，观察者模式是最有名的设计模式之一。它是一种行为模式并提供一种以一对多的依赖来绑定对象的方法：即当一个对象发生变化时，依赖它的所有对象都会被通知并且会自动更新。</p>
<p>在本章中，我们将会对观察者模式有一个概述，它是如何实现的以及如何用RxJava来扩展，Observable是什么，以及Observables如何与Iterables相关联。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>在今天，观察者模式是出现的最常用的软件设计模式之一。它基于subject这个概念。subject是一种特殊对象，当它改变时，那些由它保存的一系列对象将会得到通知。而这一系列对象被称作Observers,它们会对外暴漏了一个通知方法,当subject状态发生变化时会调用的这个方法。</p>
<p>在上一章中，我们看到了电子表单的例子。现在我们可以展开这个例子讲，展示一个更复杂的场景。让我们考虑这样一个填着账户数据的电子表单。我们可以把这些数据比作一张表，或者是3D柱状图，或者是饼状图。它们中每一个代表的意义都取决于同一组要展示的数据。每一个都是一个观察者，都依赖于那一个subject，维护着全部信息。</p>
<p>3D柱状图这个类、饼状图类、表这个类以及维护这些数据的类是完全解耦的：它们彼此相互独立复用，但也能协同工作。这些表示类彼此不清楚对方，但是正如它们所做的：它们知道在哪能找到它们需要展示的信息，它们也知道一旦数据发生变化就通知需要更新数据表示的那个类。</p>
<p>这有一张图描述了Subject/Observer的关系是怎样的一对多的关系：</p>
<p><img src="https://github.com/yuxingxin/RxJava-Essentials-CN/raw/master/images/chapter2_1.png" alt=""></p>
<p>上面这张图展示了一个Subject为3个Observers提供服务。很明显，没有理由去限制Observers的数量：如果有需要，一个Subject可以有无限多个Observers,当subject状态发生变化时，这些Observers中的每一个都会收到通知。</p>
<h2 id="你什么时候使用观察者模式？"><a href="#你什么时候使用观察者模式？" class="headerlink" title="你什么时候使用观察者模式？"></a>你什么时候使用观察者模式？</h2><p>观察者模式很适合下面这些场景中的任何一个：</p>
<ul>
<li>当你的架构有两个实体类，一个依赖另一个，你想让它们互不影响或者是独立复用它们时。</li>
<li>当一个变化的对象通知那些与它自身变化相关联的未知数量的对象时。</li>
<li>当一个变化的对象通知那些无需推断具体类型的对象时。</li>
</ul>
<h2 id="RxJava观察者模式工具包"><a href="#RxJava观察者模式工具包" class="headerlink" title="RxJava观察者模式工具包"></a>RxJava观察者模式工具包</h2><p>在RxJava的世界里，我们有四种角色：</p>
<ul>
<li>Observable</li>
<li>Observer</li>
<li>Subscriber</li>
<li>Subjects</li>
</ul>
<p>Observables和Subjects是两个“生产”实体，Observers和Subscribers是两个“消费”实体。</p>
<h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>当我们异步执行一些复杂的事情，Java提供了传统的类，例如Thread、Future、FutureTask、CompletableFuture来处理这些问题。当复杂度提升，这些方案就会变得麻烦和难以维护。最糟糕的是，它们都不支持链式调用。</p>
<p>RxJava Observables被设计用来解决这些问题。它们灵活，且易于使用，也可以链式调用，并且可以作用于单个结果程序上，更有甚者，也可以作用于序列上。无论何时你想发射单个标量值，或者一连串值，甚至是无穷个数值流，你都可以使用Observable。</p>
<p>Observable的生命周期包含了三种可能的易于与Iterable生命周期事件相比较的事件，下表展示了如何将Observable async/push 与 Iterable sync/pull相关联起来。</p>
<table>
<thead>
<tr>
<th>Event</th>
<th style="text-align:center">Iterable(pull)</th>
<th style="text-align:right">Observable(push)</th>
</tr>
</thead>
<tbody>
<tr>
<td>检索数据</td>
<td style="text-align:center"><code>T next()</code></td>
<td style="text-align:right"><code>onNext(T)</code></td>
</tr>
<tr>
<td>发现错误</td>
<td style="text-align:center"><code>throws Exception</code></td>
<td style="text-align:right"><code>onError(Throwable)</code></td>
</tr>
<tr>
<td>完成</td>
<td style="text-align:center"><code>!hasNext()</code></td>
<td style="text-align:right"><code>onCompleted()</code></td>
</tr>
</tbody>
</table>
<p>使用Iterable时，消费者从生产者那里以同步的方式得到值，在这些值得到之前线程处于阻塞状态。相反，使用Observable时，生产者以异步的方式把值推给观察者，无论何时，这些值都是可用的。这种方法之所以更灵活是因为即便值是同步或异步方式到达，消费者在这两种场景都可以根据自己的需要来处理。</p>
<p>为了更好地复用Iterable接口，RxJava Observable类扩展了GOF观察者模式的语义。引入了两个新的接口：</p>
<ul>
<li>onCompleted() 即通知观察者Observable没有更多的数据。</li>
<li>onError() 即观察者有错误出现了。</li>
</ul>
<h3 id="热Observables和冷Observables"><a href="#热Observables和冷Observables" class="headerlink" title="热Observables和冷Observables"></a>热Observables和冷Observables</h3><p>从发射物的角度来看，有两种不同的Observables:热的和冷的。一个”热”的Observable典型的只要一创建完就开始发射数据，因此所有后续订阅它的观察者可能从序列中间的某个位置开始接受数据（有一些数据错过了）。一个”冷”的Observable会一直等待，直到有观察者订阅它才开始发射数据，因此这个观察者可以确保会收到整个数据序列。</p>
<h3 id="创建一个Observable"><a href="#创建一个Observable" class="headerlink" title="创建一个Observable"></a>创建一个Observable</h3><p>在接下来的小节中将讨论Observables提供的两种创建Observable的方法。</p>
<h4 id="Observable-create"><a href="#Observable-create" class="headerlink" title="Observable.create()"></a>Observable.create()</h4><p>create()方法使开发者有能力从头开始创建一个Observable。它需要一个OnSubscribe对象,这个对象继承Action1,当观察者订阅我们的Observable时，它作为一个参数传入并执行call()函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Object&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Object&gt; subscriber)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Observable通过使用subscriber变量并根据条件调用它的方法来和观察者通信。让我们看一个“现实世界”的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observableString = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; observer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                observer.onNext(i);</span><br><span class="line">            &#125;</span><br><span class="line">            observer.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Subscription subscriptionPrint = observableString.subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Observable completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Oh,no! Something wrong happened！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer item)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Item is "</span> + item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>例子故意写的简单，是因为即便是你第一次见到RxJava的操作，我想让你明白接下来要发生什么。</p>
<p>我们创建一个新的<code>Observable&lt;Integer&gt;</code>,它执行了5个元素的for循环，一个接一个的发射他们，最后完成。</p>
<p>另一方面，我们订阅了Observable，返回一个Subscription<br>。一旦我们订阅了，我们就开始接受整数，并一个接一个的打印出它们。我们并不知道要接受多少整数。事实上，我们也无需知道是因为我们为每种场景都提供对应的处理操作：</p>
<ul>
<li>如果我们接收到了整数，那么就打印它。</li>
<li>如果序列结束，我们就打印一个关闭的序列信息。</li>
<li>如果错误发生了，我们就打印一个错误信息。</li>
</ul>
<h4 id="Observable-from"><a href="#Observable-from" class="headerlink" title="Observable.from()"></a>Observable.from()</h4><p>在上一个例子中，我们创建了一个整数序列并一个一个的发射它们。假如我们已经有一个列表呢？我们是不是可以不用for循环而也可以一个接一个的发射它们呢？</p>
<p>在下面的例子代码中，我们从一个已有的列表中创建一个Observable序列：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; items = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">items.add(<span class="number">1</span>);</span><br><span class="line">items.add(<span class="number">10</span>);</span><br><span class="line">items.add(<span class="number">100</span>);</span><br><span class="line">items.add(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">Observable&lt;Integer&gt; observableString = Observable.from(items);</span><br><span class="line">Subscription subscriptionPrint = observableString.subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Observable completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Oh,no! Something wrong happened！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer item)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Item is "</span> + item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>输出的结果和上面的例子绝对是一样的。</p>
<p><code>from()</code>创建符可以从一个列表/数组来创建Observable,并一个接一个的从列表/数组中发射出来每一个对象，或者也可以从Java <code>Future</code>类来创建Observable，并发射Future对象的<code>.get()</code>方法返回的结果值。传入<code>Future</code>作为参数时，我们可以指定一个超时的值。Observable将等待来自<code>Future</code>的结果；如果在超时之前仍然没有结果返回，Observable将会触发<code>onError()</code>方法通知观察者有错误发生了。</p>
<h4 id="Observable-just"><a href="#Observable-just" class="headerlink" title="Observable.just()"></a>Observable.just()</h4><p>如果我们已经有了一个传统的Java函数，我们想把它转变为一个Observable又改怎么办呢？我们可以用<code>create()</code>方法，正如我们先前看到的，或者我们也可以像下面那样使用以此来省去许多模板代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; observableString = Observable.just(helloWorld());</span><br><span class="line"></span><br><span class="line">Subscription subscriptionPrint = observableString.subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Observable completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Oh,no! Something wrong happened!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>helloWorld()</code>方法比较简单，像这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不管怎样，它可以是我们想要的任何函数。在刚才的例子中，我们一旦创建了Observable，<code>just()</code>执行函数，当我们订阅Observable时，它就会发射出返回的值。</p>
<p><code>just()</code>方法可以传入一到九个参数，它们会按照传入的参数的顺序来发射它们。<code>just()</code>方法也可以接受列表或数组，就像<code>from()</code>方法，但是它不会迭代列表发射每个值,它将会发射整个列表。通常，当我们想发射一组已经定义好的值时会用到它。但是如果我们的函数不是时变性的，我们可以用just来创建一个更有组织性和可测性的代码库。</p>
<p>最后注意<code>just()</code>创建符，它发射出值后，Observable正常结束，在上面那个例子中，我们会在控制台打印出两条信息：“Hello World”和“Observable completed”。</p>
<h4 id="Observable-empty-Observable-never-和Observable-throw"><a href="#Observable-empty-Observable-never-和Observable-throw" class="headerlink" title="Observable.empty(),Observable.never(),和Observable.throw()"></a>Observable.empty(),Observable.never(),和Observable.throw()</h4><p>当我们需要一个Observable毫无理由的不再发射数据正常结束时，我们可以使用<code>empty()</code>。我们可以使用<code>never()</code>创建一个不发射数据并且也永远不会结束的Observable。我们也可以使用<code>throw()</code>创建一个不发射数据并且以错误结束的Observable。</p>
<h2 id="Subject-Observable-Observer"><a href="#Subject-Observable-Observer" class="headerlink" title="Subject = Observable + Observer"></a>Subject = Observable + Observer</h2><p><code>subject</code>是一个神奇的对象，它可以是一个Observable同时也可以是一个Observer：它作为连接这两个世界的一座桥梁。一个Subject可以订阅一个Observable，就像一个观察者，并且它可以发射新的数据，或者传递它接受到的数据，就像一个Observable。很明显，作为一个Observable，观察者们或者其它Subject都可以订阅它。</p>
<p>一旦Subject订阅了Observable，它将会触发Observable开始发射。如果原始的Observable是“冷”的，这将会对订阅一个“热”的Observable变量产生影响。</p>
<p>RxJava提供四种不同的Subject：</p>
<ul>
<li>PublishSubject</li>
<li>BehaviorSubject</li>
<li>ReplaySubject.</li>
<li>AsyncSubject</li>
</ul>
<h3 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h3><p>Publish是Subject的一个基础子类。让我们看看用PublishSubject实现传统的Observable <code>Hello World</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PublishSubject&lt;String&gt; stringPublishSubject = PublishSubject.create();</span><br><span class="line">Subscription subscriptionPrint = stringPublishSubject.subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Observable completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Oh,no!Something wrong happened!"</span>);                </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">stringPublishSubject.onNext(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure></p>
<p>在刚才的例子中，我们创建了一个<code>PublishSubject</code>，用<code>create()</code>方法发射一个<code>String</code>值，然后我们订阅了PublishSubject。此时，没有数据要发送，因此我们的观察者只能等待，没有阻塞线程，也没有消耗资源。就在这随时准备从subject接收值，如果subject没有发射值那么我们的观察者就会一直在等待。再次声明的是，无需担心：观察者知道在每个场景中该做什么，我们不用担心什么时候是因为它是响应式的：系统会响应。我们并不关心它什么时候响应。我们只关心它响应时该做什么。</p>
<p>最后一行代码展示了手动发射字符串“Hello World”,它触发了观察者的<code>onNext()</code>方法，让我们在控制台打印出“Hello World”信息。</p>
<p>让我们看一个更复杂的例子。话说我们有一个<code>private</code>声明的Observable，外部不能访问。Observable在它生命周期内发射值，我们不用关心这些值，我们只关心他们的结束。</p>
<p>首先，我们创建一个新的PublishSubject来响应它的<code>onNext()</code>方法，并且外部也可以访问它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> PublishSubject&lt;Boolean&gt; subject = PublishSubject.create();</span><br><span class="line">        </span><br><span class="line">subject.subscribe(<span class="keyword">new</span> Observer&lt;Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Boolean aBoolean)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Observable Completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然后，我们创建“私有”的Observable，只有subject才可以访问的到。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            subscriber.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).doOnCompleted(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subject.onNext(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe();</span><br></pre></td></tr></table></figure></p>
<p><code>Observable.create()</code>方法包含了我们熟悉的for循环，发射数字。<code>doOnCompleted()</code>方法指定当Observable结束时要做什么事情：在subject上发射true。最后，我们订阅了Observable。很明显，空的<code>subscribe()</code>调用仅仅是为了开启Observable，而不用管已发出的任何值，也不用管完成事件或者错误事件。为了这个例子我们需要它像这样。</p>
<p>在这个例子中，我们创建了一个可以连接Observables并且同时可被观测的实体。当我们想为公共资源创建独立、抽象或更易观测的点时，这是极其有用的。</p>
<h3 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h3><p>简单的说，BehaviorSubject会首先向他的订阅者发送截至订阅前最新的一个数据对象（或初始值）,然后正常发送订阅后的数据流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BehaviorSubject&lt;Integer&gt; behaviorSubject = BehaviorSubject.create(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>在这个短例子中，我们创建了一个能发射整形(Integer)的BehaviorSubject。由于每当Observes订阅它时就会发射最新的数据，所以它需要一个初始值。</p>
<h3 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h3><p>ReplaySubject会缓存它所订阅的所有数据,向任意一个订阅它的观察者重发:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReplaySubject&lt;Integer&gt; replaySubject = ReplaySubject.create();</span><br></pre></td></tr></table></figure></p>
<h3 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h3><p>当Observable完成时AsyncSubject只会发布最后一个数据给已经订阅的每一个观察者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsyncSubject&lt;Integer&gt; asyncSubject = AsyncSubject.create();</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章中，我们了解到了什么是观察者模式，为什么Observables在今天的编程场景中如此重要，以及如何创建Observables和subjects。</p>
<p>下一章中，我们将创建第一个基于RxJava的Android应用程序，学习如何检索数据来填充listview，以及探索如何创建一个基于RxJava的响应式UI。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RxJava开发精要1-从.NET到RxJava ]]></title>
      <url>http://yoursite.com/2016/06/08/chap1/</url>
      <content type="html"><![CDATA[<h1 id="RxJava开发精要1-从-NET到RxJava"><a href="#RxJava开发精要1-从-NET到RxJava" class="headerlink" title="RxJava开发精要1-从.NET到RxJava"></a>RxJava开发精要1-从.NET到RxJava</h1><blockquote>
<ul>
<li>原文出自《RxJava Essentials》</li>
<li>原文作者 : <a href="https://www.packtpub.com/books/info/authors/ivan-morgillo" target="_blank" rel="external">Ivan Morgillo</a></li>
<li>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>转载声明: 本译文已授权<a href="http://toutiao.io/download" target="_blank" rel="external">开发者头条</a>享有独家转载权，未经允许，不得转载!</li>
<li>译者 : <a href="https://github.com/yuxingxin" target="_blank" rel="external">yuxingxin</a> </li>
<li>项目地址 : <a href="https://github.com/yuxingxin/RxJava-Essentials-CN" target="_blank" rel="external">RxJava-Essentials-CN</a></li>
</ul>
</blockquote>
<h2 id="RX-从-NET到RxJava"><a href="#RX-从-NET到RxJava" class="headerlink" title="RX - 从.NET到RxJava"></a>RX - 从.NET到RxJava</h2><p>响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。</p>
<p>响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们更改电子表（变化的传播）中的一些数值时，我们需要更新整个表格或者我们的机器人碰到墙时会转弯（响应事件）。</p>
<p>今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。</p>
<h2 id="微软响应式扩展"><a href="#微软响应式扩展" class="headerlink" title="微软响应式扩展"></a>微软响应式扩展</h2><p>函数响应式编程是一个来自90年代后期受微软的一名计算机科学家Erik Meijer启发的思想，用来设计和开发微软的Rx库。</p>
<p>Rx 是微软.NET的一个响应式扩展。Rx借助可观测的序列提供一种简单的方式来创建异步的，基于事件驱动的程序。开发者可以使用Observables模拟异步数据流，使用LINQ语法查询Observables，并且很容易管理调度器的并发。</p>
<p>Rx让众所周知的概念变得易于实现和消费，例如<strong>push方法</strong>。在响应式的世界里，我们不能假装作用户不关注或者是不抱怨它而一味的等待函数的返回结果，网络调用，或者数据库查询的返回结果。我们时刻都在等待某些东西，这就让我们失去了并行处理其他事情的机会，提供更好的用户体验，让我们的软件免受顺序链的影响，而阻塞编程。</p>
<p>下表列出的与.NET 枚举相关的.NET Observable</p>
<table>
<thead>
<tr>
<th>.NET Observable</th>
<th style="text-align:center">一个返回值</th>
<th style="text-align:right">多个返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pull/Synchronous/Interactive</td>
<td style="text-align:center"><code>T</code></td>
<td style="text-align:right"><code>IEnumerable&lt;T&gt;</code></td>
</tr>
<tr>
<td>Push/Asynchronous/Reactive</td>
<td style="text-align:center"><code>Task&lt;T&gt;</code></td>
<td style="text-align:right"><code>IObservable&lt;T&gt;</code></td>
</tr>
</tbody>
</table>
<p>push方法把这个问题逆转了：取而代之的是不再等待结果，开发者只是简单的请求结果，而当它返回时得到一个通知即可。开发者对即将发生的事件提供一个清晰的响应链。对于每一个事件，开发者都作出相应的响应；例如，用户被要求登录的时候，提交一个携带他的用户名和密码的表单。应用程序执行登录的网络请求，接下来将要发生的情况有：</p>
<ul>
<li>显示一个成功的信息，并保存用户的个人信息。</li>
<li>显示一个错误的信息</li>
</ul>
<p>正如你用push方法所看到的，开发者不需要等待结果。而是在结果返回时通知他。在这期间，他可以做他想做的任何事情：</p>
<ul>
<li>显示一个进度对话框</li>
<li>为下次登录保存用户名和密码</li>
<li>预加载一些他认为登录成功后需要耗时处理的事情</li>
</ul>
<h2 id="来到Java世界-Netflix-RxJava"><a href="#来到Java世界-Netflix-RxJava" class="headerlink" title="来到Java世界 - Netflix RxJava"></a>来到Java世界 - Netflix RxJava</h2><p>Netflix在2012年开始意识到他们的架构要满足他们庞大的用户群体已经变得步履维艰。因此他们决定重新设计架构来减少REST调用的次数。取代几十次的REST调用，而是让客户端自己处理需要的数据，他们决定基于客户端需求创建一个专门优化过的REST调用。</p>
<p>为了实现这一目标，他们决定尝试响应式，开始将.NET Rx迁移到JVM上面。他们不想只基于Java语言；而是整个JVM，从而有可能为市场上的每一种基于JVM的语言：如Java、Closure、Groovy、Scala等等提供一种新的工具。</p>
<p>2013年二月份,Ben Christensen 和 Jafar Husain发在Netflix技术博客的一篇文章第一次向世界展示了RxJava。</p>
<p>主要特点有：</p>
<ul>
<li>易于并发从而更好的利用服务器的能力。</li>
<li>易于有条件的异步执行。</li>
<li>一种更好的方式来避免回调地狱。</li>
<li>一种响应式方法。</li>
</ul>
<p>正如.NET,RxJava Observable 是push 迭代的等价体，即pull。pull方法是阻塞并等待的方法：消费者从源头pull值，并阻塞线程直到生产者提供新的值。</p>
<p>push方法作用于订阅和响应：消费者订阅新值的发射，当它们可用时生产者push这些新值并通知消费者。在这一点上，消费者消费了它们。push方法很明显更灵活，因为从逻辑和实践的观点来看，开发者只需忽略他需要的数据是来自同步还是异步；他的代码将仍然起作用。</p>
<h2 id="RxJava的与众不同之处"><a href="#RxJava的与众不同之处" class="headerlink" title="RxJava的与众不同之处"></a>RxJava的与众不同之处</h2><p>从纯Java的观点看，RxJava Observable类源自于经典的Gang Of Four的观察者模式。</p>
<p>它添加了三个缺少的功能：</p>
<ul>
<li>生产者在没有更多数据可用时能够发出信号通知：onCompleted()事件。</li>
<li>生产者在发生错误时能够发出信号通知：onError()事件。</li>
<li>RxJava Observables 能够组合而不是嵌套，从而避免开发者陷入回调地狱。</li>
</ul>
<p>Observables和Iterables共用一个相似的API：我们在Iterable可以执行的许多操作也都同样可以在Observables上执行。当然，由于Observables流的本质，没有如Iterable.remove()这样相应的方法。</p>
<table>
<thead>
<tr>
<th>Pattern</th>
<th style="text-align:center">一个返回值</th>
<th style="text-align:right">多个返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Synchronous</td>
<td style="text-align:center"><code>T getData()</code></td>
<td style="text-align:right"><code>Iterable&lt;T&gt;</code></td>
</tr>
<tr>
<td>Asynchronous</td>
<td style="text-align:center"><code>Future&lt;T&gt; getData()</code></td>
<td style="text-align:right"><code>Observable&lt;T&gt; getData()</code></td>
</tr>
</tbody>
</table>
<p>从语义的角度来看，RxJava就是.NET Rx。从语法的角度来看，Netflix考虑到了对应每个Rx方法,保留了Java代码规范和基本的模式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章中，我们初步探索了响应式的世界。从微软的.NET到Netflix的RxJava，我们了解了Rx是如何诞生的，我们也了解到传统的方法与响应式方法相比之间的相似和不同。</p>
<p>下一章，我们将学习到Observables是什么，以及如何创建它并把响应式编程应用到我们的日常编码中去。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2016 Googel I/O —人工智能、VR、智能家居、可穿戴型都拿下 ]]></title>
      <url>http://yoursite.com/2016/05/22/2016-Googel-I-O-%E2%80%94%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E3%80%81VR%E3%80%81%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E3%80%81%E5%8F%AF%E7%A9%BF%E6%88%B4%E5%9E%8B%E9%83%BD%E6%8B%BF%E4%B8%8B/</url>
      <content type="html"><![CDATA[<p><img src="http://img.leikeji.com/resource/img/22cc74620f4549bd8e36bcaff34c2fef.jpg@0-0-1400-840a" alt=""></p>
<h1 id="AI、VR、智能家居、可穿戴全都拿下"><a href="#AI、VR、智能家居、可穿戴全都拿下" class="headerlink" title="AI、VR、智能家居、可穿戴全都拿下"></a>AI、VR、智能家居、可穿戴全都拿下</h1><p>Google I/O大会在全球开发者、谷歌粉丝、安卓厂商和竞争对手的翘首以盼中开幕了。I/O大会已连续举办到第9届，在历史上曾发布过Android、Chrome、ChromeBook、Nexus 7、Google Glass、Cardboard等大家耳熟能详的产品。雷小编印象最深刻的就是当年谷歌员工在I/O大会上，戴着Google Glass从天而降、抵达舞台的惊艳之举，简直不能更酷。</p>
<p>2016年的I/O大会，更是意义非凡。     </p>
<p>VR、无人车等产业新浪潮方兴未艾，而面临瓶颈的手机业则亟待老大哥Google前来指明方向…而谷歌对这一次I/O大会也是前所未有地重视，将举办地点搬到了谷歌总部的大门口：山景城的海岸线圆形剧场，并且从室内搬到了露天场地。</p>
<p>事实证明，Google又一次不负众望，满足了大家的部分期待。尽管有一些产品并未如预期到来，但谷歌用别的产品进行了弥补。</p>
<p>先来看看Google I/O大会上的重磅发布：</p>
<h3 id="Google助理：更智能的Google-Now"><a href="#Google助理：更智能的Google-Now" class="headerlink" title="Google助理：更智能的Google Now"></a>Google助理：更智能的Google Now</h3><p>或许Google 认为Google Now不够智能，无法满足人们与机器自然交互的所有需求，因此对其进行了升级，推出了Google Assistant，即谷歌助理。</p>
<p><img src="http://img.leikeji.com/resource/img/9aed1d0d4b70413f8bc459789b26605a.png" alt=""></p>
<p>谷歌已有60%的搜索来自移动设备，20%的搜索来自语音（其中国跟随者百度公布过移动搜索比例，与之相仿，但并未公布过语音搜索比例，谷歌应该领先）。谷歌助理主要针对语音搜索进行处理，其能做的事情更多，正如其名，它可以像助理一样，与你对话交互，而不再是单次的语音识别和响应。它更加聪明，能完成更多事情。除了支持安卓手机之外，谷歌助理还能应用在智能家居、智能手表、智能汽车等场景之中——依然是对标Apple Siri、Amazon Alexa（原名Echo）和微软Cortana，中国厂商百度则有度秘。</p>
<p><img src="http://img.leikeji.com/resource/img/78d9d2f149cc41ef9d542ddea277cbec.png" alt="谷歌助理 已支持的服务"><br>语音助手最先是被Apple通过Siri带到世人面前的。不得不说最初几年Siri并不算“智能”，它许多时候成为用户调戏的玩具，识别能力差，能做的事情少，能查到天气就不错了。这些年随着语音技术和人工智能技术的发展，Siri越来越聪明，能识别更多语音，能进行多轮对话，还能完成许多任务，开始有实用性了。</p>
<p>Google旗下AlphaGo战胜顶级围棋选手表明其在人工智能上的领先者地位，将AI成果与语音和搜索结合，谷歌助理未来可期。</p>
<h3 id="Google-Home：硬件版的Google助理"><a href="#Google-Home：硬件版的Google助理" class="headerlink" title="Google Home：硬件版的Google助理"></a>Google Home：硬件版的Google助理</h3><p>Google发布了全新的智能家居产品：Google Home。这是一款内置了谷歌助理的家居硬件，就像Amazon的Echo一样，它即是一款智能音箱，也是一个可购物、能开灯的硬件助理，内置了名为Alexa的语音助理软件。</p>
<p><img src="http://img.leikeji.com/resource/img/1c8851d5ed1c4461bd797eca1669eec6.png" alt=""></p>
<p>Google Home能叫出租车、订外卖，可进行语音搜索并得到语音结果，未来应该还能开灯，做饭，下片，Google Home开放给智能家居和软件服务厂商进而实现丰富的功能…总之，与Amazon Alexa思路差不多，就是让用户在家里时可从键盘和屏幕解脱出来，一边做饭一边上网，一边XXOO一边回老板邮件（好污）……</p>
<p>在此之前，Google在智能家居上进行了许多探索。</p>
<ul>
<li>2011年的I/O大会上发布了Android@Home，几无进展； </li>
<li>2012年 I/O大会上发布Nexus Q客厅娱乐中心，同样失败； </li>
<li>2013年发布电视棒ChormeCast大获成功，今年一季度市场份额已超过Apple TV，成为全美第二受欢迎的智能电视设备，第一是老牌机顶盒厂商Roku，在I/O大会上谷歌宣布ChromeCast是其卖得最多的智能家居设备； </li>
<li>2014年，Google 32亿美金大手笔收购智能家居佼佼者Nest，这家公司除了帮Google买了一个Dropcam智能摄像头之外，其余方面并无太大起色，未能承载谷歌智能家居的重托；  </li>
<li>2015年I/O大会上，Google再战智能家居，发布了Brillo智能家居端到端系统和Weave跨平台协议，希望从系统和协议层完善智能家居；</li>
</ul>
<p>现在Google Home来了，搜索起家的谷歌，在智能家居上回到搜索（语音助理本质是移动搜索），谋求拿下家庭入口。从Amazon Alexa的成功经历来看，Google Home还是蛮有机会的，基于人工智能的优势，与ChromeCast、Nest、Dropcam等业已普及的设备配合将会对Amazon Alexa构成威胁。</p>
<h3 id="Google-Allo：会假装聊天的微信"><a href="#Google-Allo：会假装聊天的微信" class="headerlink" title="Google Allo：会假装聊天的微信"></a>Google Allo：会假装聊天的微信</h3><p>Google Allo（跟我读：爱喽）可视作是Messenger的升级版。其基于谷歌联系人实现即时通信，支持表情，图片等。最大亮点是整合了谷歌智能技术，比如收到朋友发来的小狗图片，Allo可“假装”评价说“一只可爱的小狗”（貌似很无聊）。还能根据你收到的消息上下文自动推送一些常用回答方式，提升你聊天的效率…</p>
<p><img src="http://img.leikeji.com/resource/img/423b73934fab45c894d4917c96ebdea1.png" alt=""><br><strong>Google Allo与Google助理进行了整合，用户可通过语音唤醒Allo并发送消息。</strong></p>
<p>与此同时谷歌还推出了一个搭配Allo的视频应用Duo（在英语中是二重唱的意思，读成杜-欧，而不是多），一款没有太大亮点的视频聊天应用。今年夏天Android和iOS用户可使用Duo。<br><img src="http://img.leikeji.com/resource/img/7c7f32469f614c86a1c2bece9a668a2d.png" alt=""></p>
<p>总的来说，Allo这款产品还是秉承了谷歌一贯的风格：希望帮你完成尽可能多的事情。之所以要这样干，因为谷歌一直都强调对人工智能技术的应用。谷歌创始人在创立公司时就说过，谷歌不是一家搜索公司，而是一家“人工智能公司”。</p>
<h3 id="Android-N：我们真的努力在创新（cry）！"><a href="#Android-N：我们真的努力在创新（cry）！" class="headerlink" title="Android N：我们真的努力在创新（cry）！"></a>Android N：我们真的努力在创新（cry）！</h3><p>Android N并未成为本次I/O大会的重点，早在今年3月，Android N的首个预览版本就和我们见面，今天谷歌又公布了少量信息：</p>
<p>1、在性能方面，Android N集成了Vulkan，这是OpenGL的升级版，将减少游戏对GPU的要求，提升游戏性能；增加了JIT编译器，编译性能增加75%，进而使得安装程序快了75%；</p>
<p>2、在安全性上，Android N加入了文件加密功能，移动版Chrome能识别恶意网站（这个功能似乎不太好用，误识别率高，许多时候访问成人网站不方便），还有就是Google Play打造了一个SafetyNet安全网，从云端来确保App的安全可靠性；</p>
<p>3、在生产效率上，Android N也有所作为，支持双击界面切换App，支持画中画功能，支持应用分屏功能，通知中心能够实现快速回复（iOS早已支持）；</p>
<p><img src="http://img.leikeji.com/resource/img/cc227de17a334653abd0b5842ce3e392.png" alt=""><br><strong>Android N的看点不多，毕竟之前已经发布了预览版。</strong></p>
<p>作为安卓的第七个大版本，其在“功能”上已经很难大幅创新了，更多是集中在性能和安全上，而“生产效率”优化是所有移动OS都在打的牌，生活场景很好满足了就抢工作场景。</p>
<p>相对于iPad Pro和Surface这两款基于“触控笔+实体键盘”的生产力工具而言，Android N的进步太小，在Windows的Continuum模式（将手机变身电脑主机）面前也是小巫见大巫。在生产力工具这个事情上，谷歌应该还在憋大招吧，或许寄望于ChremeOS？</p>
<p>有意思的是，谷歌强调Android N的灵感主要来自用户的信息反馈，今年的Android版本最难的就是取名，将基于用户投票得出……这个做法，让雷小编（微信ID：leitech)一下就想到了小米，这不就是中国厂商鼓吹的互联网思维嘛。</p>
<p><img src="http://img.leikeji.com/resource/img/b4dd938ebe5d45d7becfc5ef0f64a1b8.png" alt=""></p>
<h3 id="Android-VR落空，但有Daydream-VR平台"><a href="#Android-VR落空，但有Daydream-VR平台" class="headerlink" title="Android VR落空，但有Daydream.VR平台"></a>Android VR落空，但有Daydream.VR平台</h3><p>I/O大会之前，国外知名科技媒体信誓旦旦地说，谷歌确定会发布一款中端VR设备——Android VR。</p>
<p>今天答案揭晓：骗人的。</p>
<p>谷歌I/O大会确实涉及到VR。其公布CardBoard这款廉价版的VR设备应用安装超过5000万，Android N已明确会加入VR模式，更重要的是，谷歌发布了VR平台Daydream.VR（白日梦）。</p>
<p>与Oculus Home等VR平台不同，Daydream不是VR内容平台，而是一套基于Android的制作VR内容和应用的标准解决方案。</p>
<p>其能有效降低延迟、减少眩晕感，支持智能手机，并可以将性能表现降低到20ms以下。基于Android N，它适用大量的手机品牌，这样以后用户通过VR盒子在这些手机上选择“VR模式”，在收看VR内容时体验就更好了——不过2K这个硬条件还是要手机厂商自己努力。</p>
<blockquote>
<p><strong>小米之前造势说会出现在Google I/O，确实出现了，见下图：</strong>      </p>
</blockquote>
<p><img src="http://img.leikeji.com/resource/img/e92c0cbc149f41d58998ff92edf910a7.png" alt=""><br><strong>Daydream.VR会支持的手机厂商</strong></p>
<p>目前，Daydream已有不少合作App，HULU、Netflix等知名内容平台加入其中，同时谷歌街景等App支持Daydream.VR。用户通过兼容Daydream.VR的App，搭载Android N手机，可以看电影、玩游戏、看街景等，会有更好的VR体验。</p>
<p>Daydream VR是一个开放式的VR解决方案。它并不是一个针对VR设备的OS，因为这套方案是基于Android N的。不过，未来Daydream VR或许会演进出一套更独立的系统，类似于Android Wear。Daydream.VR将在今年秋天正式推出。</p>
<p><img src="http://img.leikeji.com/resource/img/f43bd2244218473aa4346ba833ffdc8d.png" alt=""></p>
<p>Daydream.VR支持头戴设备，谷歌提供了关于此的参考产品（类似于Nexus产品之于Android的价值），这是一个纯白色的产品，具有简单的控制器，应该就是传说中的Android VR了，比CardBoard确实要精致点，但感觉还是比较简陋的。</p>
<p>谷歌并未正式发布这款产品，亮相应该还要等些时间。</p>
<p><img src="http://img.leikeji.com/resource/img/c54f0c1629cc45e990f9fa9e7ae9f5d3.gif" alt=""></p>
<h3 id="Android-Wear-2-0发布，可独立于手机使用"><a href="#Android-Wear-2-0发布，可独立于手机使用" class="headerlink" title="Android Wear 2.0发布，可独立于手机使用"></a>Android Wear 2.0发布，可独立于手机使用</h3><p>2014年，Android Wear正式发布，这个系统并未普及开来，除了Moto360和华为Watch支持之外，另一个明星智能手表即三星Gear采取了自家的Tizen系统。并且相对于智能手环和智能手机而言，智能手表市场一直没被打开，老大哥Apple Watch好不容易卖到千万台，今年一季度又迎来了超过60%的大幅下滑。</p>
<p>所以，智能手表何去何从，大家还是挺迷茫的。在去年I/O大会上有过小幅更新之后，Android Wear在I/O大会上发布了2.0版本。在发布时，谷歌表示，有了过去两年的教训之后，终于了解了人们对智能手表的需求。好吧，这个速度真的有点慢啊。</p>
<p>在新版中，增加了智能回复、手写识别以及全新的自动键盘。智能回复是本次I/O大会上不断强调的点，不便于输入的手表更有这样的需求，所以这个功能还是挺有吸引力的。就算要输入，通过Android Wear2.0的手写或自动键盘效率可更好，因为它们底层都应用了机器学习技术。</p>
<p>最大亮点则是，Android Wear 2.0 的手表可独立于手机使用了。它支持手表自己使用蜂窝网络和WIFI网络，还能独立播放本地音乐，独立记录运动数据，优化了运动记录算法，并与Google Fit API接口打通，可支持营养应用和蓝牙音乐。</p>
<p>Android Wear 2.0开发者预览版已经上线，正式版需要到今年秋天才会向用户推送。</p>
<p>除了谷歌助理、谷歌Home、谷歌Allo（以及Duo）、Android N、DayDream.VR和Android Wear 2.0 这6个与消费者息息相关的产品之外，谷歌针对开发者还发布了Studio2.0、Firebase等工具，以及将较多篇幅放在了基于H5技术的App形态即Android Instant Apps上，这一应用基于云端，无需安装，所见即所得，是ChromeOS的核心理念，未来或许在Android上会越来越多，而这一切对用户是透明的。</p>
<p>Google I/O 2016年虽然没有类似于Google Glass、Google无人驾驶汽车这样的“全新产品”惊艳亮相，但依然还是十分赞的，从这个大会可以看到谷歌未来的侧重点：</p>
<blockquote>
<p><strong> 1、人工智能将成为谷歌业务的“血液”。</strong>   </p>
</blockquote>
<p>这一届I/O大会让用户能够深切感知到AI技术的应用，比如谷歌助理、谷歌Home均是典型的人工智能应用。而谷歌Allo，以及Android Wear2.0都开始引入“助理”概念，谷歌正在想办法帮用户做更多的事情。AlphaGo将谷歌推上人工智能的神坛，现在谷歌正在将掌握的前沿人工各种技术应用到更多产品，造福用户。日前，桑达•劈材在最近的公开信中说，这个世界将从“移动设备优先”变为“人工智能优先”，I/O大会表明谷歌对这一世界观正在快速行动。</p>
<p><img src="http://img.leikeji.com/resource/img/dc8abc799bc94e73a72eafd6799e8201.png" alt=""></p>
<blockquote>
<p><strong>2、谷歌对待VR的态度是做标准缔造者。</strong></p>
</blockquote>
<p>谷歌对VR非常积极，去年I/O大会就推出了CardBoard并开源，以帮助VR快速普及，与Amazon、Apple的观望态度，以及微软押宝AR（增强现实）的态度，完全不同。</p>
<p>本次I/O大会虽然谷歌并未如外界期望那样做重度VR产品，但推出Daydream.VR这样的标准解决方案，对VR行业比做一款设备更具现实意义。安卓还是Nexus手机重要？答案显然是安卓。做VR设备只会是谷歌推标准的手段，而不是目的，这与Facebook押宝Oculus有巨大不同。因此，虽然Android VR没来，但做了“白日梦”的谷歌并未让人失望，它将VR当做长期投资在做，将在一起起到安卓之于智能手机行业的角色。</p>
<blockquote>
<p><strong>3、为什么没有汽车？因为I/O大会不吹牛。</strong></p>
</blockquote>
<p>这次谷歌并未如许多人预期那样发布与谷歌无人驾驶汽车相关的消息——而是聚焦在四大领域：手机、家居、可穿戴和VR，并且AI技术被贯穿其中。关于汽车几乎只字未提，是谷歌不重视汽车吗？答案是否定的，谷歌是无人驾驶汽车最激进的玩家，没有谈无人驾驶汽车或许是因为这个业务距离消费者还有很远的距离，并且I/O大会的背景是开发者大会，谷歌公布的事情与开发者均是息息相关的，现在开发者能够针对无人车做什么呢？什么都不能做。所以，谷歌在I/O大会不提汽车就不见怪了。</p>
<h3 id="小结一下："><a href="#小结一下：" class="headerlink" title="小结一下："></a>小结一下：</h3><p>谷歌I/O大会并未带来太大惊喜，但依然体现了浓浓的谷歌风格。这次大会发布了比设备更重要的VR解决方案，发布了与人工智能息息相关的软硬件，还有Android Wear 2.0、Android N以及大量的开发者工具，均表明谷歌的野心从来都不是一款产品，而是一个大家都能一起玩儿的真生态，从安卓到Chrome再到Daydream.VR，透露着浓浓的谷歌情怀</p>
<p><strong>原文链接：<a href="http://www.leikeji.com/article/5763" target="_blank" rel="external">雷科技-2016 Google IO 大会</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用Git Command 秀操作啦 ]]></title>
      <url>http://yoursite.com/2016/05/18/2016-05-16-git/</url>
      <content type="html"><![CDATA[<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><h2 id="将远程的git仓库关联到本地"><a href="#将远程的git仓库关联到本地" class="headerlink" title="将远程的git仓库关联到本地"></a>将远程的git仓库关联到本地</h2><ul>
<li>首先我们需要在远程(github)仓库创建一个仓库，这里的测试仓库是base_project</li>
<li>就需要将远程的仓库和本地关联<br>  a. 需要在本地创建一个和服务器一样的文件夹（base_project）<br>  b. 在这个文件夹下打开git命令窗口<br>  c. 初始化git ： </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    $ git init</span><br><span class="line">    Initialized empty Git repository in D:/android project/test/base_project/.git/</span><br><span class="line"></span><br><span class="line">    <span class="number">10142</span><span class="meta">@DESKTOP</span>-<span class="number">21</span>D76NU MINGW64 /d/android project/test/base_project (master)</span><br><span class="line"></span><br><span class="line">~~~     </span><br><span class="line"></span><br><span class="line">我们能够发现在当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。       </span><br><span class="line">    d. 将本地的仓库和远程的仓库进行关联     </span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">    <span class="number">10142</span><span class="meta">@DESKTOP</span>-<span class="number">21</span>D76NU MINGW64 /d/android project/test/base_project (master)</span><br><span class="line">    $ git remote add origin https:<span class="comment">//github.com/lipengfeng/base_project.git</span></span><br></pre></td></tr></table></figure>
<p>这时将可以查看远程仓库了 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p><strong>备注</strong>:<strong>origin</strong>就是我们的远程库的名字，这是Git默认的叫法，也可以改成别的;<br><strong><a href="https://github.com/lipengfeng/base_project.git" target="_blank" rel="external">https://github.com/lipengfeng/base_project.git</a></strong>是我们远程仓库的路径(这里我们使用的github)</p>
<h2 id="创建文件并提交到远程仓库"><a href="#创建文件并提交到远程仓库" class="headerlink" title="创建文件并提交到远程仓库"></a>创建文件并提交到远程仓库</h2><ul>
<li><p>这样我们就可以开始在本地的文件夹中做事了,这里我们先创建一个MainActivity.java文件</p>
</li>
<li><p>创建文件 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch MainActivity.java</span><br></pre></td></tr></table></figure>
<ul>
<li>将文件添加到本地仓库       </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add MainActivity.java</span><br></pre></td></tr></table></figure>
<ul>
<li>将文件提交到本地缓存区</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"书写提交信息"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将文件推送到远程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -<span class="function">u origin <span class="title">master</span><span class="params">(分支)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>将远程的文件下拉到本地</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
<p>注意如果想添加不同目录下的文件：那么我们要修改目录</p>
<ul>
<li>添加不同路径的文件（<strong>ps:其他的保持不变就可以将其提交上去</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add read/read.txt</span><br></pre></td></tr></table></figure>
<h2 id="分支-branch-操作相关命令"><a href="#分支-branch-操作相关命令" class="headerlink" title="分支(branch)操作相关命令"></a>分支(branch)操作相关命令</h2><ul>
<li>查看本地分支</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 举个例子 下面就是返回了一个master分支</span><br><span class="line">10142@DESKTOP-21D76NU MINGW64 /d/android project/test/base_project (master)</span><br><span class="line">$ git branch</span><br><span class="line">master</span><br><span class="line"></span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看远程分支  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    git branch -r</span><br><span class="line"><span class="comment">/*</span><br><span class="line">    git branch -r</span><br><span class="line">    origin/master</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p><em>创建本地分支（<em>*ps:该命令创建本地分支后并不会切换到该分支</em></em>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch dev[分支名]</span><br><span class="line"><span class="comment">/* 我们可以看到当前的分支已经有两个了</span><br><span class="line">$ git branch</span><br><span class="line">dev</span><br><span class="line">master</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>切换分支<br>在切换分支之前，先查看一下当前处于哪个分支？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 可以看到当前仍然处于 master分支上</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with 'origin/master'.</span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line"></span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev[分支名]</span><br><span class="line"><span class="comment">/* 我们可以看到，当执行切换分支的命令之后，就会将分支切换到另一个分支</span><br><span class="line"></span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch 'dev'</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line"></span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建分支并立即切换到新分支</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    git </span><br><span class="line">    $ git checkout -b other[分支名]</span><br><span class="line">    Switched to a <span class="keyword">new</span> branch <span class="string">'other'</span></span><br><span class="line">~~~     </span><br><span class="line"></span><br><span class="line">* 删除分支</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">    git branch -d other[分支名]</span><br><span class="line">    <span class="comment">/* 可以看到这里报错了，这是因为， 删除的时候我们需要</span><br><span class="line">    切换到其他分支才能删除该分支</span><br><span class="line">    $ git branch -d other</span><br><span class="line">    error: Cannot delete the branch 'other' which you are currently on.</span><br><span class="line">    $ git checkout dev</span><br><span class="line">    Switched to branch 'dev'</span><br><span class="line"></span><br><span class="line">    $ git branch -d other</span><br><span class="line">    Deleted branch other (was 0e7e027).</span><br><span class="line"></span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>本地分支push到远程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    git push origin dev[分支名]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">    $ git push origin dev</span><br><span class="line">    Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">    git To https://github.com/lipengfeng/base_project.git</span><br><span class="line">    * [new branch]      </span><br><span class="line">    dev -&gt; dev</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除远程分支</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin:heads/dev 或者 git push origin:dev</span><br></pre></td></tr></table></figure>
<ul>
<li>合并分支</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git merge dev -----将名为dev的分支与当前分支合并</span><br><span class="line">$ git merge dev</span><br><span class="line">Already up-to-date.</span><br></pre></td></tr></table></figure>
<h2 id="git-远程仓库管理"><a href="#git-远程仓库管理" class="headerlink" title="git 远程仓库管理"></a>git 远程仓库管理</h2><ul>
<li>查看远程服务地址和名称</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    git remote -v <span class="comment">//查看远程服务地址和仓库名称</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    $ git remote -v</span><br><span class="line">    origin  https://github.com/lipengfeng/base_project.git (fetch)</span><br><span class="line">    origin  https://github.com/lipengfeng/base_project.git (push)</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看远程服务器仓库状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line"><span class="comment">/*</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/lipengfeng/base_project.git</span><br><span class="line">  Push  URL: https://github.com/lipengfeng/base_project.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    dev    tracked</span><br><span class="line">    master tracked</span><br><span class="line">  Local branch configured for 'git pull':</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local refs configured for 'git push':</span><br><span class="line">    dev    pushes to dev    (up to date)</span><br><span class="line">    master pushes to master (up to date)</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>克隆远程仓库到本地</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/lipengfeng/base_project.git</span></span><br><span class="line"></span><br><span class="line">$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br><span class="line"><span class="comment">/*该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>添加远程仓库地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@ github:robbin/robbin_site.git</span><br><span class="line"><span class="comment">//这一点在关联远程仓库的时候已经说过了，所以这里不再赘述</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改远程仓库地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@ github.com:robbin/robbin_site.git </span><br><span class="line"><span class="comment">//设置远程仓库地址(用于修改远程仓库地址)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除远程仓库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm &lt;repository&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git暂存管理"><a href="#git暂存管理" class="headerlink" title="git暂存管理"></a>git暂存管理</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash                        # 暂存  </span><br><span class="line">git stash list                   # 列所有stash  </span><br><span class="line">git stash apply                  # 恢复暂存的内容  </span><br><span class="line">git stash drop                   # 删除暂存区</span><br></pre></td></tr></table></figure>
<h2 id="其他一些命令"><a href="#其他一些命令" class="headerlink" title="其他一些命令"></a>其他一些命令</h2><p><strong>git log:</strong>查看历史日志<br><strong>git rm:</strong>从当前工作空间/索引中删除文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm app/model/user.rb</span><br></pre></td></tr></table></figure>
<p><strong>git revert:</strong>git revert：还原一个版本的修改，必须提供一个具体的Git版本号，Git的版本号都是生成的一个哈希值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert bbaf6fb5060b4875b18ff9ff637ce118256d6f20</span><br></pre></td></tr></table></figure>
<p><strong>git checkout</strong>：Git的checkout有两个作用，其一是在不同的branch之间进行切换，例如’git checkout new_branch’就会切换到new_branch的分支上去；另一个功能是还原代码的作用，例如’git checkout app/model/user.rb’就会将user.rb文件从上一个已提交的版本中更新回来，<br>未提交的内容全部会回滚<br><strong>git rebase:</strong>用下面两幅图解释会比较清楚一些，rebase命令执行后，实际上是将分支点从C移到了G，这样分支也就具有了从C到G的功能<br><img src="http://my.csdn.net/uploads/201205/02/1335955913_5248.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ToolBar简单的使用 ]]></title>
      <url>http://yoursite.com/2016/05/16/2016-05-14-ToolBar/</url>
      <content type="html"><![CDATA[<h1 id="ToolBar简介"><a href="#ToolBar简介" class="headerlink" title="ToolBar简介"></a>ToolBar简介</h1><p><strong>导语:</strong></p>
<p>ToolBar是android5.0推出的新的导航控件，用于取代以前的actioBar,由于其高度的可定制性、灵活性、具有Material Design风格等优点，越来越多的应用也用上了ToolBar,比如常用的知乎软件其顶部导航栏正是使用ToolBar。官方考虑到有一部分的手机版本号低于5.0，所以，ToolBar也放进了support v7包内，使得低版本的系统也能够使用ToolBar。本文将使用support v7支持包的ToolBar来进行讲解，包括其基本用法样式定制等之时点。</p>
<h2 id="ToolBar的基本使用"><a href="#ToolBar的基本使用" class="headerlink" title="ToolBar的基本使用"></a>ToolBar的基本使用</h2><blockquote>
<p>引入support v7支持包</p>
</blockquote>
<p>在你的项目中的build.gradle内输入如下代码，即可引入支持包，该支持包内有向下兼容的ToolBar:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">    compile fileTree(<span class="symbol">dr:</span> <span class="string">'libs'</span> , <span class="symbol">include:</span>[<span class="string">'*.jar'</span>])</span><br><span class="line">    compile <span class="string">'com.android.support:appcompat-v7:23.1.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h2><p>为了能够正常使用ToolBar，我们需要隐藏原来的ActionBar,这个可以在主题中修改，在values/styles.xml中做出如下修改：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"AppTheme"</span> parent=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>
<p>继承了<strong>Theme.Appcompat.Light.NoActionBar</strong>主题，这里提一下，这个Theme.Appcompat是支持包内的主题，对应着5.0版本的Theme.Material主题。然后在Manifest文件中引用这个主题。</p>
<p>##在布局文件中创建这个控件</p>
<blockquote>
<p>activity_main.xml文件中，代码如下：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"</span><br><span class="line">    android:layout_width="match_parent"</span><br><span class="line">    android:layout_height="match_parent"</span><br><span class="line">    android:orientation="vertical"&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id="@+id/toolbar"</span><br><span class="line">        android:layout_width="match_parent"</span><br><span class="line">        android:background="?attr/colorPrimary"</span><br><span class="line">        android:layout_height="wrap_content"&gt;</span><br><span class="line"></span><br><span class="line">       &lt;TextView</span><br><span class="line">          android:layout_width="match_parent"</span><br><span class="line">          android:layout_height="wrap_content"</span><br><span class="line">          android:textColor="@color/color_edebeb"</span><br><span class="line">          android:text="标题"</span><br><span class="line">          android:textSize="20sp"/&gt;</span><br><span class="line">    &lt;/android.support.v7.widget.Toolbar&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure>
<p>在上面，创建了android.support.v7.widgt.ToolBar,同时我们在内部放了一个TextView,这是与ActionBar最大的不同，因为ToolBar实际上是一个ViewGroup，支持在其内放子View。ok，我们运行程序，得到如下结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1734948-400fe8513b394718.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看出ToolBar正常显示，当然了，这只是最简单的用法，接下来我们逐步添加内容、样式，使它看起开更加美，功能更加完善。</p>
<h2 id="ToolBar的完善"><a href="#ToolBar的完善" class="headerlink" title="ToolBar的完善"></a>ToolBar的完善</h2><ul>
<li><strong>首先我们考虑改变ToolBar的颜色</strong></li>
</ul>
<p>要想改变toolbar的颜色很简单，直接在布局文件中添加一个backgroud属性指定颜色就可以了，但是为了全局考虑，我们可以这样：在values/styles.xml文件中做出如下修改：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;</span><br><span class="line">    &lt;!-- Customize your theme here. --&gt;</span><br><span class="line">    &lt;item name="colorPrimary"&gt;#2e8abb&lt;/item&gt; &lt;!--浅蓝色--&gt;</span><br><span class="line">    &lt;item name="colorPrimaryDark"&gt;#3A5FCD&lt;/item&gt; &lt;!--深蓝色--&gt;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<p>然后在布局文件中，添加如下属性：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">android:</span>background=<span class="string">"?attr/colorPrimary"</span></span><br></pre></td></tr></table></figure>
<p>这样，就能方便对每一个toolbar引用同样的颜色了，我们先看看现在的效果是怎样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1734948-232e075f427b1ed5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到，颜色已经改变，同时我们注意到，顶部状态栏的颜色也变成了深蓝色，这是因为添加了”colorPrimaryDark”的属性，使得顶部状态栏随之改变，利用这一特性，我们可以轻松实现“状态栏沉浸”的效果了。当然，这只适用于Android 5.0以上，如果在低版本则这个属性无效。这里再附上一张图（图片来自<a href="http://blog.csdn.net/bbld_/article/details/41439715" target="_blank" rel="external">http://blog.csdn.net/bbld_/article/details/41439715</a>）：</p>
<p><img src="http://img.blog.csdn.net/20141122125624647" alt=""></p>
<p>根据图中的说明，我们可以轻松地在styles.xml文件中定制我们的样式，如果想要改变toolbar的<em>title</em>、<em>subtitle</em>以及<em>menu</em>中文字的颜色，可以利用“textColorPrimary”属性等。</p>
<ul>
<li><strong>添加title、subtitle、logo、导航栏图标</strong></li>
</ul>
<p>在MainActivity文件先获取控件的实例，接着通过一系列的set方法即可设置，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Toolbar toolbar;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">      toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">      toolbar.setTitle(<span class="string">"Title"</span>);</span><br><span class="line">      toolbar.setSubtitle(<span class="string">"SubTitle"</span>);</span><br><span class="line">      toolbar.setLogo(R.mipmap.ic_launcher);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//设置导航图标要在setSupportActionBar方法之后</span></span><br><span class="line">      setSupportActionBar(toolbar);</span><br><span class="line">      toolbar.setNavigationIcon(R.mipmap.ic_drawer_home);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1734948-2adaca43f1c531b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如果你想修改标题和子标题的字体大小、颜色等，可以调用 <strong>setTitleTextColor</strong> 、 <strong>setTitleTextAppearance</strong> 、 <strong>setSubtitleTextColor</strong> 、 <strong>setSubtitleTextAppearance</strong> 这些API。当然，这些设置都是支持在xml布局中直接添加的，但是用的不是android:命名空间，而是自定义命名空间，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"</span><br><span class="line">  xmlns:toolbar="http://schemas.android.com/apk/res-auto"</span><br><span class="line">  ...&gt;</span><br><span class="line">  &lt;android.support.v7.widget.Toolbar</span><br><span class="line">      ...</span><br><span class="line">      toolbar:logo="@mipmap/ic_launcher"</span><br><span class="line">      toolbar:title="Title"</span><br><span class="line">      toolbar:subtitle="Sub Title"</span><br><span class="line">      toolbar:titleTextColor="#ffffff"&gt;</span><br><span class="line">  &lt;/android.support.v7.widget.Toolbar&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>添加菜单选项图标及点击事件</strong></li>
</ul>
<p>3.1 添加菜单选项图标</p>
<p>一般导航条，在其右侧都会有菜单选项，当然ToolBar也是支持自定义菜单的，首先我们在菜单文件中，修改如下：res/menu/menu_main.xml:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"</span><br><span class="line">    xmlns:app="http://schemas.android.com/apk/res-auto"</span><br><span class="line">    xmlns:tools="http://schemas.android.com/tools" tools:context=".MainActivity"&gt;</span><br><span class="line">    &lt;item android:id="@+id/action_search"</span><br><span class="line">        android:title="Search"</span><br><span class="line">        android:icon="@mipmap/ic_search"</span><br><span class="line">        app:showAsAction="ifRoom"/&gt;</span><br><span class="line">    &lt;item android:id="@+id/action_notifications"</span><br><span class="line">        android:title="notifications"</span><br><span class="line">        android:icon="@mipmap/ic_notifications"</span><br><span class="line">        app:showAsAction="ifRoom"/&gt;</span><br><span class="line">    &lt;item android:id="@+id/action_settings"</span><br><span class="line">        android:title="@string/action_settings"</span><br><span class="line">        android:orderInCategory="100"</span><br><span class="line">        android:icon="@mipmap/ic_launcher"</span><br><span class="line">        app:showAsAction="never"/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>
<p>这里用了这样一个熟悉：app:showAsAction=”ifRoom”/“never”，app是自定义的命名空间，因为我们的activity继承的是AppCompatActivity，是support v7包的，并不是原生sdk内部的，因此不能使用android:showAsAction，否则会报错。然后ifRoom表示有空间则显示，never表示从不显示，而是会通过overflowwindow显示。<br>接着我们在Activity中，要重写onCreateOptionsMenu()方法，把这个菜单加载进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Overridepublic</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123; </span><br><span class="line">       getMenuInflater().inflate(R.menu.menu_main, menu);   </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.2 添加点击事件</p>
<p>菜单有了，我们要为菜单添加点击事件，这样菜单才会有实际用途,添加点击事件也很方便，可以这样操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置导航图标、添加菜单点击事件要在setSupportActionBar方法之后</span></span><br><span class="line">      setSupportActionBar(toolbar);</span><br><span class="line">      toolbar.setNavigationIcon(R.mipmap.ic_drawer_home);</span><br><span class="line"></span><br><span class="line">      toolbar.setOnMenuItemClickListener(<span class="keyword">new</span> Toolbar.OnMenuItemClickListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMenuItemClick</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">                  <span class="keyword">case</span> R.id.action_search:</span><br><span class="line">                      Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"Search !"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">case</span> R.id.action_notifications:</span><br><span class="line">                      Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"Notificationa !"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">case</span> R.id.action_settings:</span><br><span class="line">                      Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"Settings !"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1734948-5e259fffe328a60e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到，菜单选项图标正常显示，以及点击事件都正常触发，但是还有一点瑕疵的地方，那就是右上角的三个圆点，是黑色的，与图标格格不入，有没有什么办法改变它呢？答案是有的，可以通过添加样式改变，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  &lt;resources&gt;</span><br><span class="line">    &lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;item name="android:textColorSecondary"&gt;#ffffff&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<p>“android:textColorSecondary”属性对应的就是右上角三个圆点的颜色了。改变之后将会变成你要的颜色。</p>
<p>3.3 其他样式修改</p>
<p><em>修改Toolbar popup menu样式</em></p>
<p>我们先点击右上角的三个点，会弹出一个popup menu，如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1734948-7ba30760a0cc8c55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到右上角的popup menu是白底黑字，那么有没有什么办法改变它的背景颜色，使菜单显示为黑底白字呢呢？答案是有的，我们可以这样设置：<br>首先在styles.xml文件中，新建一个主题：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  &lt;!-- toolbar弹出菜单样式 --&gt;</span><br><span class="line">&lt;style name="ToolbarPopupTheme" parent="@style/ThemeOverlay.AppCompat.Dark"&gt;   </span><br><span class="line">     &lt;item name="android:colorBackground"&gt;#000000&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到这个主题的parent是直接继承自ThemeOverlay.AppCompat.Dark，是支持包的一个主题，并且我们在内部声明了“android:colorBackground”这个属性，我们只要更改这个属性就能变更菜单的背景颜色了。接下来我们在布局文件中引入这个主题，这也很简单，为toolbar添加额外的属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolbar:popupTheme=<span class="string">"@style/ToolbarPopupTheme"</span></span><br></pre></td></tr></table></figure>
<p>这样，改几行代码即可修改popup menu的背景颜色了，如下面所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1734948-d08d2fa17f674de1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>修改Toolbar popup menu 弹出位置</strong></p>
<p>我们可以看到，popup menu的位置是过于偏上的，我们还可以修改它的位置，使它处于Toolbar之下，这样看起来可能更美观：<br>修改styles.xml文件如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">style name="ToolbarPopupTheme" parent="@style/ThemeOverlay.AppCompat.Dark"&gt;    </span><br><span class="line">    &lt;item name="android:colorBackground"&gt;#000000&lt;/item&gt;    </span><br><span class="line">    &lt;item name="actionOverflowMenuStyle"&gt;@style/OverflowMenuStyle&lt;/item&gt; &lt;!--新增一个item，用于控制menu--&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;style name="OverflowMenuStyle" parent="Widget.AppCompat.Light.PopupMenu.Overflow"&gt;   </span><br><span class="line">     &lt;item name="overlapAnchor"&gt;false&lt;/item&gt;  &lt;!--把该属性改为false即可使menu位置位于toolbar之下--&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>效果如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1734948-bfdac39320195e5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>那么到目前为止，对于toolbar的相关使用意见讲述完毕，可以看出toolbar的灵活性很高，能自定义很多样式，我们平常开发也会遇到各种不同的样式，因此toolbar用于取代actionbar是非常合适的。以后如果还有遇到别的样式，我也会分享出来，谢谢。</p>
<blockquote>
<p>参考文档：<br><a href="http://www.aichengxu.com/view/2559126" target="_blank" rel="external">Toolbar-5.0新特性</a><br><a href="http://blog.csdn.net/bbld_/article/details/41439715" target="_blank" rel="external">Android Material Design之Toolbar与Palette实践</a><br><a href="http://www.jianshu.com/p/79604c3ddcae" target="_blank" rel="external">Android开发：最详细的 Toolbar 开发实践总结</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[github关联远程仓库 ]]></title>
      <url>http://yoursite.com/2016/05/14/2016-05-14-github/</url>
      <content type="html"><![CDATA[<h1 id="github关联远程仓库"><a href="#github关联远程仓库" class="headerlink" title="github关联远程仓库"></a>github关联远程仓库</h1><h2 id="一-本机远程仓库进行关联"><a href="#一-本机远程仓库进行关联" class="headerlink" title="一. 本机远程仓库进行关联"></a>一. 本机远程仓库进行关联</h2><p>1.1. 在本机创建SSH Key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"eksliang@163.com"</span></span><br></pre></td></tr></table></figure>
<p>一直回车，会在本地生产~/.ssh文件夹，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
<p>1.2.    登录github让本机与github进行关联<br><img src="http://dl2.iteye.com/upload/attachment/0112/3536/318a624c-b3d3-34f3-b26c-80d948a6a8dd.png" alt=""></p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容；<br>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。<br>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<h2 id="二-在github上新建仓库（repository）"><a href="#二-在github上新建仓库（repository）" class="headerlink" title="二.在github上新建仓库（repository）"></a>二.在github上新建仓库（repository）</h2><p><img src="http://dl2.iteye.com/upload/attachment/0112/3540/f81a6b04-be1b-3901-ac3a-0fd984a6896b.png" alt=""><br>此时仓库还是空的，GitHub告诉我们，可以有2种方式进行创建，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。如下所示：</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0112/3542/7f184069-47fd-3313-9bc7-b930d94ff1c6.png" alt=""></p>
<p>现在，我们根据GitHub的提示，在本地仓库下运行命令，把本地仓库的内容推送到GitHub仓库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git<span class="meta">@github</span>.com:ickess/demo.git  </span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p><strong>命令解释如下：</strong></p>
<p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库（建议不要改动，跟整个行业同步起来）<br>本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，以后的推送时可以去掉-u参数。推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。</p>
<p>从现在起，只要本地作了提交，就可以通过命令，将本地的最新代码推送至远程仓库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<h2 id="三-github删除仓库"><a href="#三-github删除仓库" class="headerlink" title="三.github删除仓库"></a>三.github删除仓库</h2><p><img src="http://dl2.iteye.com/upload/attachment/0112/3546/97f6c95e-15db-33d7-9944-466d01ee5f57.png" alt=""><br><img src="http://dl2.iteye.com/upload/attachment/0112/3548/4fd3ec72-7be4-3bdf-b0e5-23d91f877462.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MVP的简单介绍(内含第三方demo)]]></title>
      <url>http://yoursite.com/2016/05/06/MVP%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D(%E5%86%85%E5%90%AB%E7%AC%AC%E4%B8%89%E6%96%B9demo)/</url>
      <content type="html"><![CDATA[<h1 id="MVP的简单介绍"><a href="#MVP的简单介绍" class="headerlink" title="MVP的简单介绍"></a>MVP的简单介绍</h1><h2 id="一、什么是-MVP"><a href="#一、什么是-MVP" class="headerlink" title="一、什么是 MVP"></a>一、什么是 MVP</h2><h3 id="1-MVP-的定义"><a href="#1-MVP-的定义" class="headerlink" title="1. MVP 的定义"></a>1. MVP 的定义</h3><p>MVP，全称 Model-View-Presenter<br>MVP（Model-View-Presenter，模型-视图-表示器）模式则是由IBM开发出来的一个针对C++和Java的编程模型，大概出现于2000年，是MVC模式的一个变种，主要用来隔离UI、UI逻辑和业务逻辑、数据。也就是说，MVP 是从经典的模式MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。</p>
<p>说明：按照View和Presenter之间的交互方式以及View本身的职责范围，Martin Folwer将MVP可分为PV（Passive View）和SoC（Supervising Controller）两种模式。</p>
<p><strong>Passive View</strong><br>顾名思义，PV（Passive View）是一个被动的View，针对包含其中的UI元素（比如控件）的操作不是由View自身来操作，而交给Presenter来操控。</p>
<p><strong>Supervising Controller</strong><br>在SoC（Supervising Controller）模式下，为了降低Presenter的复杂度，将诸如数据绑定和格式化这样简单的UI处理逻辑逻辑转移到View中，这些处理逻辑会体现在View实现的接口中。</p>
<h3 id="2-为什么使用MVP"><a href="#2-为什么使用MVP" class="headerlink" title="2. 为什么使用MVP"></a>2. 为什么使用MVP</h3><p>现在大部分的android程序只是使用了model-view的结构。<br>那么我们更多的是和view打交道，而不是解决业务逻辑。<br>当我们在代码中使用m-v的时候，到最后会发现所以的事物被连到了一起。</p>
<p><img src="http://lookcode-wordpress.stor.sinaapp.com/uploads/2016/01/16.png" alt=""></p>
<p>那么，这样之后，我们的测试或者调试将变得异常的复杂。</p>
<p><strong>With MVP</strong><br>使用MVP</p>
<p><img src="http://lookcode-wordpress.stor.sinaapp.com/uploads/2016/01/22.png" alt=""></p>
<p>复杂的任务被分成细小的任务，并且很容易解决。越小的东西，bug越少，越容易debug，更好测试。在MVP模式下的View层将会变得简单，所以即便是他请求数据的时候也不需要回调函数。View逻辑变成十分直接。</p>
<h3 id="3-MVP的优缺点"><a href="#3-MVP的优缺点" class="headerlink" title="3.MVP的优缺点"></a>3.MVP的优缺点</h3><p>任何事务都存在两面性，MVP当然也不列外，我们来看看MVP的优缺点。<br><strong>优点：</strong><br>1.降低耦合度，实现了Model和View真正的完全分离，可以修改View而不影响Modle  </p>
<ol>
<li>模块职责划分明显，层次清晰（下面会介绍Bob大叔的Clean Architecture）     </li>
<li>隐藏数据     </li>
<li>Presenter可以复用，一个Presenter可以用于多个View，而不需要更改Presenter的逻辑（当然是在View的改动不影响业务逻辑的前提下）       </li>
<li>利于测试驱动开发。以前的Android开发是难以进行单元测试的（虽然很多Android开发者都没有写过测试用例，但是随着项目变得越来越复杂，没有测试是很难保证软件质量的；而且近几年来Android上的测试框架已经有了长足的发展——开始写测试用例吧），在使用MVP的项目中Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。       </li>
<li>View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。              </li>
<li>代码灵活性<br><strong>缺点：</strong>     </li>
<li>Presenter中除了应用逻辑以外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。    </li>
<li>由于对视图的渲染放在了Presenter中，所以视图和Presenter的交互会过于频繁。    </li>
<li>如果Presenter过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更，那么Presenter也需要变更了。  </li>
<li>额外的代码复杂度及学习成本。<br><strong>在MVP模式里通常包含4个要素：</strong></li>
</ol>
<p>(1) View :负责绘制UI元素、与用户进行交互(在Android中体现为Activity);<br>(2) View interface :需要View实现的接口，View通过View      interface与Presenter进行交互，降低耦合，方便进行单元测试;<br>(3) Model :负责存储、检索、操纵数据(有时也实现一个Model    interface用来降低耦合);<br>(4) Presenter :作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。</p>
<p><img src="http://new.51cto.com/files/uploadimg/20090430/1559491.jpg" alt=""></p>
<h3 id="4-Android-上-MVP-的几种实现"><a href="#4-Android-上-MVP-的几种实现" class="headerlink" title="4.Android 上 MVP 的几种实现"></a>4.Android 上 MVP 的几种实现</h3><p><strong>4.1 存取用户信息的demo：<br>原文：</strong><br><a href="http://blog.csdn.net/vector_yi/article/details/24719873" target="_blank" rel="external">MVP模式在Android开发中的应用 </a><br><strong>github</strong>:<a href="https://github.com/VectorYi/MVPSample" target="_blank" rel="external">https://github.com/VectorYi/MVPSample</a></p>
<p><img src="http://img.blog.csdn.net/20140429154522203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdmVjdG9yX3lp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从这其中的目录结构我们可以看出，将MVP分的很清楚，而且可以发现，<strong>Presenter</strong>与<strong>Model</strong>、<strong>View</strong>都是通过接口来进行交互的，既降低耦合也方便进行单元测试。<br>(1) 首先我们需要一个UserBean，用来保存用户信息<br>(2) 再来看看View接口：<br>        View可以对<strong>ID</strong>、<strong>FirstName</strong>、<strong>LastName</strong>这三个EditText进行读操作，对FirstName和LastName进行写操作，由此定义IUserView接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserView</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">getFristName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">getLastName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3) Model接口：<br>     同样，Model也需要对这三个字段进行读写操作，并存储在某个载体内(这不是我们所关心的，可以存在内存、文件、数据库或者远程服务器，但对于Presenter及View无影响),定义IUserModel接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserModel</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">UserBean <span class="title">load</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4) Presenter:<br>     至此，Presenter就能通过接口与View及Model进行交互了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPresenter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> IUserView mUserView;</span><br><span class="line">	<span class="keyword">private</span> IUserModel mUserModel;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserPresenter</span><span class="params">(IUserView view)</span> </span>&#123;</span><br><span class="line">		mUserView = view;</span><br><span class="line">		mUserModel = <span class="keyword">new</span> UserModel();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(<span class="keyword">int</span> id, String firstName, String lastName)</span> </span>&#123;</span><br><span class="line">		mUserModel.setID(id);</span><br><span class="line">		mUserModel.setFirstName(firstName);</span><br><span class="line">		mUserModel.setLastName(lastName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		UserBean user = mUserModel.load(id);</span><br><span class="line">		mUserView.setFirstName(user.getFirstName());</span><br><span class="line">		mUserView.setLastName(user.getLastName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(5)UserActivity:<br>     UserActivity实现了IUserView接口，同时有一个UserPresenter成员变量：<br>可以看到，View只负责处理与用户进行交互，并把数据相关的逻辑操作都扔给了Presenter去做。而Presenter调用Model处理完数据之后，再通过IUserView更新View显示的信息。</p>
<p><strong>4.2 天气查询的 MVP 小 Demo</strong><br>原文：<a href="http://rocko.xyz/2015/02/06/Android%E4%B8%AD%E7%9A%84MVP/" target="_blank" rel="external">Android中的MVP</a><br>github:<a href="https://github.com/zhengxiaopeng/Rocko-Android-Demos/tree/master/architecture/android-mvp" target="_blank" rel="external">https://github.com/zhengxiaopeng/Rocko-Android-Demos/tree/master/architecture/android-mvp</a></p>
<p><strong>包结构</strong></p>
<p><img src="http://rocko-blog.qiniudn.com/Android%E4%B8%AD%E7%9A%84MVP_2.png?imageView2/2/w/450/h/450/q/100" alt=""></p>
<p>包图中明显的三层：Model包、Presenter包、UI包，其中，三者都实现各自的结构，Model为WeatherModel、Presenter为WeatherPresenter、View为Weather，那么具体实现类就是impl包里的了，View层的即为Activity。     </p>
<p><strong>View里面的接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WeatherView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showLoading</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hideLoading</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showError</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWeatherInfo</span><span class="params">(Weather weather)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WeatherPresenter的接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WeatherPresenter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 获取天气的逻辑</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getWeather</span><span class="params">(String cityNO)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WeatherModel接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WeatherModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadWeather</span><span class="params">(String cityNO, OnWeatherListener listener)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prestener里面还有个<strong>OnWeatherListener</strong>，其在Presenter层实现，给Model层回调，更改View层的状态，确保Model层不直接操作View层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnWeatherListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 成功时回调</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> weather</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Weather weather)</span></span>;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 失败时回调，简单处理，没做什么</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.3. 使用 Activity/Fragment 作为 Presenter 的探索</strong></p>
<p>上面的示例 View 都是 Activity 来承担的，Presenter 是一个普通的类，Android 在不同场景下会进入不同的生命周期，这将可能导致 Presenter 也随着其生命周期需要做出响应。从这个角度考虑，有不少开发者提出了 MVP 实现的其他思路，接下来我们要探讨的就是<strong>使用 Activity/Fragment 作为 Presenter 的一些实现方案</strong>。</p>
<p><strong>4.3.1 一种实现MVP模式的新思路</strong><br><strong>原文</strong>：<a href="https://github.com/bboyfeiyu/android-tech-frontier/tree/master/androidweekly/%E4%B8%80%E7%A7%8D%E5%9C%A8android%E4%B8%AD%E5%AE%9E%E7%8E%B0MVP%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B0%E6%80%9D%E8%B7%AF" target="_blank" rel="external">一种在android中实现MVP模式的新思路</a><br><strong>源码</strong>：<a href="https://github.com/wongcain/MVP-Simple-Demo" target="_blank" rel="external">GitHub 地址</a>     </p>
<p>贴上作者对activity和fragment作为（View层）的见解：<br><strong>使用Activity和Fragment作为视图层(View)真的合适么?</strong></p>
<p>目前很多使用了MVP模式的android 项目,基本上都是将activity和fragment作为视图层来进行处理的.而presenters通常是通过继承自被视图层实例化或者注入的对象来得到的. 诚然,我同意说,这种方式可以节省掉很多让人厌烦的”import android..”语句, 并且将presenters从activity的生命周期中分割出来以后, 项目后续的维护会变得简便很多.这种思路是正确的， 但是,从另一个角度来说, activity 有一个很复杂的生命周期(fragment的生命周期可能会更复杂), 而这些生命周期很有可能对你项目的业务逻辑有非常重大的影响. Activity 可以获取上下文环境和多种android系统服务. Activity中发送Intent，启动Service和执行FragmentTransisitons等。而这些特性在我看来绝不应该是视图层应该涉及的领域(视图的功能就是现实数据和从用户那里获取输入数据，在理想的情况下，视图应该避免业务逻辑).      </p>
<p>基于上述的原因，我对目前的主流做法并不赞同，所以我在尝试使用Activity和Fragment作为Presenters。</p>
<p><strong>1. 去除所有的view</strong></p>
<p>将Activity和Fragment作为presenter最大的困难就是如何将关于UI的逻辑抽取出来.我的解决方案是: 让需要作为presenter的activity 或者 fragment来继承一个抽象的类(或者叫”基类”), 这样关于View 各种组件的初始化以及逻辑,都可以在继承了抽象类的方法中进行操作，而当继承了该抽象类的class需要对某些组件进行操作的时候，只需要调用继承自抽象类的方法，就可以了。<br>那么抽象类怎么获取到的view组件呢？在抽象类里面会有一个实例化的接口，这个接口里面的init()方法就会对view进行实例化，这个接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(LayoutInflater inflater, ViewGroup container)</span></span>;</span><br><span class="line">    <span class="function">View <span class="title">getView</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所见，Vu定义了一个通用的初始化例程，我可以通过它来实现一个容器视图，它也有一个方法来获得一个View的实例，每一个presenter将会和它自己的Vu关联，这个presenter将会继承这个接口（直接或者间接的去继承一个来自Vu的接口）</p>
<p><strong>2. 创建一个presenter基类 (Activity)</strong></p>
<p>有了Vu接口，我们可以通过构建一系列的class来操纵很多不同的view组件，这些class 使用Vu接口来初始化View组件，并通过继承的方式给子类以操纵view组件的方法，以此来达到将ui 逻辑剥离出activity的目的。</p>
<p>在下面的代码中，你可以看到，我覆写了activity的onCreate 、 onCreateView、onDestroy 、 onDestroyView，通过对这些方法的覆写，就可以对Vu的实例化和销毁进行精确的控制（vu.init()就是实例化一个view组件）。</p>
<p>onBindVu() 和onDestoryVu()是控制view生命周期的两个方法。通过对actiivty中相关方法的覆写达到控制组件的生命周期的目的（具体看下面的代码，你就明白了）， 这样做的好处就是无论是activity 还是 fragment， 其用与控制view组件创建和销毁的语句是一样的（尽量避免定义多余的函数）。这样的话，二者之间的切换也会减少一定的阻力（也许你今天的需求是用fragment实现的，但是第二天发现使用fragment会有一个惊天bug，译者本人就遇到过）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePresenterActivity</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">Vu</span>&gt; <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> V vu;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            vu = getVuClass().newInstance();</span><br><span class="line">            vu.init(getLayoutInflater(), <span class="keyword">null</span>);</span><br><span class="line">            setContentView(vu.getView());</span><br><span class="line">            onBindVu();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        onDestroyVu();</span><br><span class="line">        vu = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;V&gt; <span class="title">getVuClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onBindVu</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroyVu</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 创建一个基本的presenter(Fragment)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePresenterFragment</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">Vu</span>&gt; <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> V vu;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View view = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            vu = getVuClass().newInstance();</span><br><span class="line">            vu.init(inflater, container);</span><br><span class="line">            onBindVu();</span><br><span class="line">            view = vu.getView();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onDestroyView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        onDestroyVu();</span><br><span class="line">        vu = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroyVu</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onBindVu</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;V&gt; <span class="title">getVuClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 一个简单的例子</strong></p>
<p>如前文所述，我们已经确定了一个框架，现在就来写一个简单的例子来进一步的说明. 为了避免篇幅过长，我就写一个“hello world”的例子。首先要有一个实现Vu接口的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloVu</span> <span class="keyword">implements</span> <span class="title">Vu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">View view;</span><br><span class="line">TextView helloView;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(LayoutInflater inflater, ViewGroup container)</span> </span>&#123;</span><br><span class="line">    view = inflater.inflate(R.layout.hello, container, <span class="keyword">false</span>);</span><br><span class="line">    helloView = (TextView) view.findViewById(R.id.hello);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHelloMessage</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    helloView.setText(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>下一步</strong>，创建一个presenter来操作这个TextView</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloActivity</span> <span class="keyword">extends</span> <span class="title">BasePresenterActivity</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onBindVu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vu.setHelloMessage(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Class&lt;HelloVu&gt; <span class="title">getVuClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HelloVu.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK,这样就大功告成了！！是不是很简便！<br><strong>等等…耦合警告!</strong></p>
<p>你可能注意到我的HelloVu类直接实现了Vu接口，我的<strong>Presenter</strong>的<strong>getVuClass</strong>方法直接引用了实现类。传统的MVP模式中，Presenter是要通过接口与他们的View解耦合的。因此，你也可以这么做。避免直接实现Vu接口，我们可以创建一个扩展了Vu的<strong>IHelloView</strong>接口，然后使用这个接口作为Presenter的泛型类型。这样Presenter看起来应该是如下这样的 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloActivity</span> <span class="keyword">extends</span> <span class="title">BasePresenterActivity</span>&lt;<span class="title">IHelloVu</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onBindVu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vu.setHelloMessage(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Class&lt;HelloVuImpl&gt; <span class="title">getVuClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HelloVuImpl.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我使用强大的模拟工具过程中，我个人并没有看到在一个接口下面实现Vu所带来的好处。但是对于我来说一个好的方面是，有没有Vu接口它都能够工作，唯一的需求就是最终你会实现Vu。<br>使用adapter作为presenter</p>
<p>将Activity作为presente已经足够狡猾了吧？使用adapter作为presenter，你想过没有？ 好吧，请看如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePresenterAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> V vu;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        LayoutInflater inflater = (LayoutInflater) parent.getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            vu = (V) getVuClass().newInstance();</span><br><span class="line">            vu.init(inflater, parent);</span><br><span class="line">            convertView = vu.getView();</span><br><span class="line">            convertView.setTag(vu);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vu = (V) convertView.getTag();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(convertView!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        onBindListItemVu(position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> convertView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onBindListItemVu</span><span class="params">(<span class="keyword">int</span> position)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;V&gt; <span class="title">getVuClass</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.3.2. TheMVP 介绍</strong></p>
<p><strong>TheMVP</strong>使用Activity作为Presenter层来处理代码逻辑，通过让Activity包含一个<strong>ViewDelegate</strong>对象来间接操作View层对外提供的方法，从而做到完全解耦视图层。</p>
<p><strong>原文</strong>：<a href="http://www.kymjs.com/code/2015/11/09/01/" target="_blank" rel="external">用MVP架构开发Android应用</a><br><strong>源码</strong>：<a href="https://github.com/kymjs/TheMVP" target="_blank" rel="external">GitHub 地址</a></p>
<p><strong>TheMVP</strong>使用Activity作为Presenter层来处理代码逻辑，通过让Activity包含一个<strong>ViewDelegate</strong>对象来间接操作View层对外提供的方法，从而做到完全解耦视图层。如下图：<br><strong>TheMVP架构图</strong><br><img src="http://kymjs.com/images/blog_image/20151029_1.png" alt=""></p>
<p>要将Activity作为Presenter来写，需要让View变得可复用，必须解决的一个问题就是setContentView()如何调用，因为它是Activity(Fragment有类似)的方法。<br>我们需要把视图抽离出来独立实现。可以定义一个接口，来限定View层必须实现的方法(这个接口定义，也就是View层的代理对象)，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(LayoutInflater i, ViewGroup v, Bundle b)</span></span>;</span><br><span class="line">    <span class="function">View <span class="title">getRootView</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过<strong>inflater</strong>一个布局，将这个布局转换成<strong>View</strong>，再用g<strong>etRootView()</strong>方法把这个<strong>View</strong>返回给<strong>Presenter</strong>层，让<strong>setContentView(view)</strong>去调用，这样就实现了<strong>rootView</strong>的独立。<br>所以，在Presenter层，我们的实现应该是：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取到视图层对象</span></span><br><span class="line">    IDelegate viewDelegate = xxx;</span><br><span class="line">    <span class="comment">//让视图层初始化(如果是Fragment，就需要传递onCreateView方法中的三个参数)</span></span><br><span class="line">    viewDelegate.create(getLayoutInflater(), <span class="keyword">null</span>, savedInstanceState);</span><br><span class="line">    <span class="comment">//拿到初始化以后的rootview，并设置content</span></span><br><span class="line">    setContentView(viewDelegate.getRootView());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用泛型解耦</strong></p>
<p>现在我们是实现了<strong>View</strong>与<strong>Presenter</strong>的解耦，在onCreate中包含了一个接口对象来实现我们固定的一些必须方法。但是又引入了问题：一些特定方法没办法引用了。比如某个界面的设值、控件的修改显示逻辑对Presenter层的接口，接口对象必须强转成具体子类才能调用。<br>解决办法：可以通过泛型来解决直接引用具体对象的问题。比如我们可以在子类定义以后确定一个Presenter中所引用的<strong>Delegate</strong>的具体类型。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityPresenter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">IDelegate</span>&gt; <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> T viewDelegate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        viewDelegate = getDelegateClass().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;T&gt; <span class="title">getDelegateClass</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们在ActivityPresenter的继承类中就可以通过动态设置getDelegateClass()的返回值来确定Delegate的具体类型了。</p>
<p><strong>4.3.3 MVPro 介绍</strong></p>
<p><strong>MVPro</strong>的实现很简单，思想和上面两篇文章介绍的一样，都是将<strong>Activity</strong>和<strong>Fragment</strong>作为<strong>Presenter</strong>。<strong>Presenter</strong>即我们的<strong>Activity</strong>或者<strong>Fragment</strong>, View呢？说白了就是我们从Activity和Fragment中提取出来的和View操作相关的代码。</p>
<p><strong>原文</strong>：<a href="http://blog.csdn.net/qibin0506/article/details/49992897" target="_blank" rel="external">Android MVP框架MVPro的使用和源码分析</a><br><strong>源码</strong>：<a href="https://github.com/qibin0506/MVPro" target="_blank" rel="external">GitHub 地址</a></p>
<p><img src="http://www.mobile-open.com/wp-content/uploads/2016/04/20160405194433_243.png" alt=""></p>
<p>在<strong>MVPro</strong>中，将Activity，Fragment作为Presenter，并且提供了轻量级的<strong>ActivityPresenterImpl</strong>、<strong>FragmentPresenterImpl</strong>、<strong>FragmentActivityImpl</strong>的实现， 在项目中可以直接继承这些实现去做自己的presenter。<br>IPresenter作为Presenter必须要实现的接口，提供的方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 获取当前presenter泛型的类型</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function">Class&lt;T&gt; <span class="title">getViewClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * View初始化之前可以在此方法做一些操作</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Bundle savedInstance)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * View初始化完毕后调用</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">created</span><span class="params">(Bundle savedInstance)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中getViewClass在Ipresenter的实现类中已经完成了实现，我们的项目中无需考虑.<br>create方法是在setContentView之前调用的，我们可以在该方法中实现<br>例如：requestWindowFeature(Window.FEATURE_CUSTOM_TITLE);<br>等工作。<br>created方法是在setContentView之后调用，可以根据业务需要做自己的逻辑。</p>
<p><strong>**View</strong></p>
<p>在<strong>MVPro</strong>中，<strong>View</strong>层必须要实现IView接口，当然<strong>MVPro</strong>也提供了<strong>ViewImpl</strong>一个轻量级的实现，在我们的项目中完全可以直接继承<strong>ViewImpl</strong>。<br>Model</p>
<p>在MVPro中并没有提供关于model的代码</p>
<p><strong>4.4. Mosby 框架</strong></p>
<p>这是一种解决Activity/Fragment生命周期在屏幕翻转等场景下对Presenter的处理的思路。</p>
<p><strong>原文</strong>：<a href="http://hannesdorfmann.com/android/mosby" target="_blank" rel="external">Ted Mosby – Software Architect</a><br><strong>译文</strong>：<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0528/2945.html" target="_blank" rel="external">MVP框架 – Ted Mosby的软件架构</a><br><strong>源码</strong>：<a href="https://github.com/sockeqwe/mosby" target="_blank" rel="external">GitHub 地址</a></p>
<p><strong>MVP模块( MVP Module )</strong><br>Mosby库中的MVP模块使用泛型来确保类型安全。所有view的基类是MvpView。从根本上说这只是一个空的interface 。Presenter的基类是MvpPresenter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MvpView</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MvpPresenter</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">MvpView</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">attachView</span><span class="params">(V view)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">detachView</span><span class="params">(<span class="keyword">boolean</span> retainInstance)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把Activity和Fragment看做View。因此Mosby库的MVP模块提供了 属于MvpViews 的MvpActivity和MvpFragment作为Activity和Fragment的基类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MvpActivity</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">MvpPresenter</span>&gt; <span class="keyword">extends</span> <span class="title">MosbyActivity</span> <span class="keyword">implements</span> <span class="title">MvpView</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> P presenter;</span><br><span class="line">    <span class="meta">@Override</span>  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        presenter = createPresenter();</span><br><span class="line">        presenter.attachView(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">        presenter.detachView(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="title">PcreatePresenter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MvpFragment</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">MvpPresenter</span>&gt; <span class="title">MosbyFragment</span> <span class="keyword">implements</span> <span class="title">MvpView</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Ppresenter;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(View view,@Nullable Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view,savedInstanceState);</span><br><span class="line">        <span class="comment">// Create the presenter if needed</span></span><br><span class="line">        <span class="keyword">if</span>(presenter == <span class="keyword">null</span>)&#123;</span><br><span class="line">            presenter = createPresenter();</span><br><span class="line">        &#125;</span><br><span class="line">        presenter.attachView(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroyView</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView();</span><br><span class="line">        presenter.detachView(getRetainInstance());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="title">PcreatePresenter</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一理念主要是一个<strong>MvpView</strong> (也就是Fragment or Activity)会关联一个<strong>MvpPresenter</strong>，并且管理<strong>MbpPresenter</strong>的声明周期。大家从上面的代码片段可以看到，<strong>Mosby</strong>使用Activity和Fragement生命周期来实现这一目的。通常presenter是绑定在该生命周期上的。所以初始化或者清理一些东西等操作（例如撤销异步运行任务）应该在 <strong>presenter.onAttach()</strong>和 <strong>resenter.onDetach()</strong> 上进行。 <strong>MvpPresenter</strong>是一个interface 。MVP模块提供一个 <strong>MvpBasePresenter</strong>，这个MvpBasePresenter只持有View（是一个Fragment或Activity）的弱引用，从而避免内存泄露。因此，当presenter想要调用view方法时，我们需要查看<strong>isViewAttached()</strong> 并使用<strong>getView()</strong>来获取引用，以检查view是否连接到了presenter。</p>
<p><strong>4.5. Google 官方推荐</strong></p>
<p>大 Boss 总是最后出场，对于 Android 上 MVP 的实现，Google 给也出了一些建议和实例，赶紧看看去吧。</p>
<p><strong>原文</strong>：<a href="https://github.com/googlesamples/android-architecture?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">Android Architecture Blueprints [beta]</a><br><strong>源码</strong>：<a href="https://github.com/googlesamples/android-architecture?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">GitHub 地址</a></p>
<p><img src="https://github.com/googlesamples/android-architecture/wiki/images/tasks2.png" alt=""></p>
<p><strong>Google MVP 示例</strong></p>
<p><strong>4.6. MVP 实现的完整开源项目</strong></p>
<p><strong>Philm</strong></p>
<p><strong>ChrisBannes</strong>的开源项目<strong>Philm</strong>，其整体架构是一套MVP的实现。</p>
<p><strong>Philm 分析</strong>：<a href="http://www.lightskystreet.com/2015/02/10/philm_mvp/" target="_blank" rel="external">开源项目Philm的MVP架构分析</a><br><strong>源码</strong>：<a href="https://github.com/chrisbanes/philm" target="_blank" rel="external">GitHub 地址</a></p>
<p><img src="http://www.lightskystreet.com/img/philm_mvp/philm_mvp_structure.png" alt=""></p>
<p><img src="http://www.lightskystreet.com/img/philm_mvp/philm_mvp_uml.png" alt=""></p>
<p><img src="http://www.lightskystreet.com/img/philm_mvp/mvp_method_flow.png" alt=""></p>
<p><strong>相关文章</strong></p>
<p><a href="http://blog.csdn.net/vector_yi/article/details/24719873" target="_blank" rel="external">http://blog.csdn.net/vector_yi/article/details/24719873</a></p>
<p><a href="http://antonioleiva.com/mvp-android/" target="_blank" rel="external">http://antonioleiva.com/mvp-android/</a></p>
<p><a href="https://github.com/antoniolg/androidmvp" target="_blank" rel="external">https://github.com/antoniolg/androidmvp</a></p>
<p><a href="http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/" target="_blank" rel="external">http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/</a></p>
<p><a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="external">https://github.com/android10/Android-CleanArchitecture</a></p>
<p><a href="http://magenic.com/BlogArchive/AnMVPPatternforAndroid" target="_blank" rel="external">http://magenic.com/BlogArchive/AnMVPPatternforAndroid</a></p>
<p><a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="external">http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html</a></p>
<p><a href="http://blog.csdn.net/xijiaohuangcao/article/details/7925641" target="_blank" rel="external">http://blog.csdn.net/xijiaohuangcao/article/details/7925641</a></p>
<p><a href="https://github.com/pedrovgs/EffectiveAndroidUI/" target="_blank" rel="external">https://github.com/pedrovgs/EffectiveAndroidUI/</a></p>
]]></content>
    </entry>
    
  
  
</search>
