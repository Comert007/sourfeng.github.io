<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[2016 Googel I/O —人工智能、VR、智能家居、可穿戴型都拿下 ]]></title>
      <url>http://yoursite.com/2016/05/22/2016-Googel-I-O-%E2%80%94%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E3%80%81VR%E3%80%81%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E3%80%81%E5%8F%AF%E7%A9%BF%E6%88%B4%E5%9E%8B%E9%83%BD%E6%8B%BF%E4%B8%8B/</url>
      <content type="html"><![CDATA[<p><img src="http://img.leikeji.com/resource/img/22cc74620f4549bd8e36bcaff34c2fef.jpg@0-0-1400-840a" alt=""></p>
<h1 id="AI、VR、智能家居、可穿戴全都拿下"><a href="#AI、VR、智能家居、可穿戴全都拿下" class="headerlink" title="AI、VR、智能家居、可穿戴全都拿下"></a>AI、VR、智能家居、可穿戴全都拿下</h1><p>Google I/O大会在全球开发者、谷歌粉丝、安卓厂商和竞争对手的翘首以盼中开幕了。I/O大会已连续举办到第9届，在历史上曾发布过Android、Chrome、ChromeBook、Nexus 7、Google Glass、Cardboard等大家耳熟能详的产品。雷小编印象最深刻的就是当年谷歌员工在I/O大会上，戴着Google Glass从天而降、抵达舞台的惊艳之举，简直不能更酷。</p>
<p>2016年的I/O大会，更是意义非凡。     </p>
<p>VR、无人车等产业新浪潮方兴未艾，而面临瓶颈的手机业则亟待老大哥Google前来指明方向…而谷歌对这一次I/O大会也是前所未有地重视，将举办地点搬到了谷歌总部的大门口：山景城的海岸线圆形剧场，并且从室内搬到了露天场地。</p>
<p>事实证明，Google又一次不负众望，满足了大家的部分期待。尽管有一些产品并未如预期到来，但谷歌用别的产品进行了弥补。</p>
<p>先来看看Google I/O大会上的重磅发布：</p>
<h3 id="Google助理：更智能的Google-Now"><a href="#Google助理：更智能的Google-Now" class="headerlink" title="Google助理：更智能的Google Now"></a>Google助理：更智能的Google Now</h3><p>或许Google 认为Google Now不够智能，无法满足人们与机器自然交互的所有需求，因此对其进行了升级，推出了Google Assistant，即谷歌助理。</p>
<p><img src="http://img.leikeji.com/resource/img/9aed1d0d4b70413f8bc459789b26605a.png" alt=""></p>
<p>谷歌已有60%的搜索来自移动设备，20%的搜索来自语音（其中国跟随者百度公布过移动搜索比例，与之相仿，但并未公布过语音搜索比例，谷歌应该领先）。谷歌助理主要针对语音搜索进行处理，其能做的事情更多，正如其名，它可以像助理一样，与你对话交互，而不再是单次的语音识别和响应。它更加聪明，能完成更多事情。除了支持安卓手机之外，谷歌助理还能应用在智能家居、智能手表、智能汽车等场景之中——依然是对标Apple Siri、Amazon Alexa（原名Echo）和微软Cortana，中国厂商百度则有度秘。</p>
<p><img src="http://img.leikeji.com/resource/img/78d9d2f149cc41ef9d542ddea277cbec.png" alt="谷歌助理 已支持的服务"><br>语音助手最先是被Apple通过Siri带到世人面前的。不得不说最初几年Siri并不算“智能”，它许多时候成为用户调戏的玩具，识别能力差，能做的事情少，能查到天气就不错了。这些年随着语音技术和人工智能技术的发展，Siri越来越聪明，能识别更多语音，能进行多轮对话，还能完成许多任务，开始有实用性了。</p>
<p>Google旗下AlphaGo战胜顶级围棋选手表明其在人工智能上的领先者地位，将AI成果与语音和搜索结合，谷歌助理未来可期。</p>
<h3 id="Google-Home：硬件版的Google助理"><a href="#Google-Home：硬件版的Google助理" class="headerlink" title="Google Home：硬件版的Google助理"></a>Google Home：硬件版的Google助理</h3><p>Google发布了全新的智能家居产品：Google Home。这是一款内置了谷歌助理的家居硬件，就像Amazon的Echo一样，它即是一款智能音箱，也是一个可购物、能开灯的硬件助理，内置了名为Alexa的语音助理软件。</p>
<p><img src="http://img.leikeji.com/resource/img/1c8851d5ed1c4461bd797eca1669eec6.png" alt=""></p>
<p>Google Home能叫出租车、订外卖，可进行语音搜索并得到语音结果，未来应该还能开灯，做饭，下片，Google Home开放给智能家居和软件服务厂商进而实现丰富的功能…总之，与Amazon Alexa思路差不多，就是让用户在家里时可从键盘和屏幕解脱出来，一边做饭一边上网，一边XXOO一边回老板邮件（好污）……</p>
<p>在此之前，Google在智能家居上进行了许多探索。</p>
<ul>
<li>2011年的I/O大会上发布了Android@Home，几无进展； </li>
<li>2012年 I/O大会上发布Nexus Q客厅娱乐中心，同样失败； </li>
<li>2013年发布电视棒ChormeCast大获成功，今年一季度市场份额已超过Apple TV，成为全美第二受欢迎的智能电视设备，第一是老牌机顶盒厂商Roku，在I/O大会上谷歌宣布ChromeCast是其卖得最多的智能家居设备； </li>
<li>2014年，Google 32亿美金大手笔收购智能家居佼佼者Nest，这家公司除了帮Google买了一个Dropcam智能摄像头之外，其余方面并无太大起色，未能承载谷歌智能家居的重托；  </li>
<li>2015年I/O大会上，Google再战智能家居，发布了Brillo智能家居端到端系统和Weave跨平台协议，希望从系统和协议层完善智能家居；</li>
</ul>
<p>现在Google Home来了，搜索起家的谷歌，在智能家居上回到搜索（语音助理本质是移动搜索），谋求拿下家庭入口。从Amazon Alexa的成功经历来看，Google Home还是蛮有机会的，基于人工智能的优势，与ChromeCast、Nest、Dropcam等业已普及的设备配合将会对Amazon Alexa构成威胁。</p>
<h3 id="Google-Allo：会假装聊天的微信"><a href="#Google-Allo：会假装聊天的微信" class="headerlink" title="Google Allo：会假装聊天的微信"></a>Google Allo：会假装聊天的微信</h3><p>Google Allo（跟我读：爱喽）可视作是Messenger的升级版。其基于谷歌联系人实现即时通信，支持表情，图片等。最大亮点是整合了谷歌智能技术，比如收到朋友发来的小狗图片，Allo可“假装”评价说“一只可爱的小狗”（貌似很无聊）。还能根据你收到的消息上下文自动推送一些常用回答方式，提升你聊天的效率…</p>
<p><img src="http://img.leikeji.com/resource/img/423b73934fab45c894d4917c96ebdea1.png" alt=""><br><strong>Google Allo与Google助理进行了整合，用户可通过语音唤醒Allo并发送消息。</strong></p>
<p>与此同时谷歌还推出了一个搭配Allo的视频应用Duo（在英语中是二重唱的意思，读成杜-欧，而不是多），一款没有太大亮点的视频聊天应用。今年夏天Android和iOS用户可使用Duo。<br><img src="http://img.leikeji.com/resource/img/7c7f32469f614c86a1c2bece9a668a2d.png" alt=""></p>
<p>总的来说，Allo这款产品还是秉承了谷歌一贯的风格：希望帮你完成尽可能多的事情。之所以要这样干，因为谷歌一直都强调对人工智能技术的应用。谷歌创始人在创立公司时就说过，谷歌不是一家搜索公司，而是一家“人工智能公司”。</p>
<h3 id="Android-N：我们真的努力在创新（cry）！"><a href="#Android-N：我们真的努力在创新（cry）！" class="headerlink" title="Android N：我们真的努力在创新（cry）！"></a>Android N：我们真的努力在创新（cry）！</h3><p>Android N并未成为本次I/O大会的重点，早在今年3月，Android N的首个预览版本就和我们见面，今天谷歌又公布了少量信息：</p>
<p>1、在性能方面，Android N集成了Vulkan，这是OpenGL的升级版，将减少游戏对GPU的要求，提升游戏性能；增加了JIT编译器，编译性能增加75%，进而使得安装程序快了75%；</p>
<p>2、在安全性上，Android N加入了文件加密功能，移动版Chrome能识别恶意网站（这个功能似乎不太好用，误识别率高，许多时候访问成人网站不方便），还有就是Google Play打造了一个SafetyNet安全网，从云端来确保App的安全可靠性；</p>
<p>3、在生产效率上，Android N也有所作为，支持双击界面切换App，支持画中画功能，支持应用分屏功能，通知中心能够实现快速回复（iOS早已支持）；</p>
<p><img src="http://img.leikeji.com/resource/img/cc227de17a334653abd0b5842ce3e392.png" alt=""><br><strong>Android N的看点不多，毕竟之前已经发布了预览版。</strong></p>
<p>作为安卓的第七个大版本，其在“功能”上已经很难大幅创新了，更多是集中在性能和安全上，而“生产效率”优化是所有移动OS都在打的牌，生活场景很好满足了就抢工作场景。</p>
<p>相对于iPad Pro和Surface这两款基于“触控笔+实体键盘”的生产力工具而言，Android N的进步太小，在Windows的Continuum模式（将手机变身电脑主机）面前也是小巫见大巫。在生产力工具这个事情上，谷歌应该还在憋大招吧，或许寄望于ChremeOS？</p>
<p>有意思的是，谷歌强调Android N的灵感主要来自用户的信息反馈，今年的Android版本最难的就是取名，将基于用户投票得出……这个做法，让雷小编（微信ID：leitech)一下就想到了小米，这不就是中国厂商鼓吹的互联网思维嘛。</p>
<p><img src="http://img.leikeji.com/resource/img/b4dd938ebe5d45d7becfc5ef0f64a1b8.png" alt=""></p>
<h3 id="Android-VR落空，但有Daydream-VR平台"><a href="#Android-VR落空，但有Daydream-VR平台" class="headerlink" title="Android VR落空，但有Daydream.VR平台"></a>Android VR落空，但有Daydream.VR平台</h3><p>I/O大会之前，国外知名科技媒体信誓旦旦地说，谷歌确定会发布一款中端VR设备——Android VR。</p>
<p>今天答案揭晓：骗人的。</p>
<p>谷歌I/O大会确实涉及到VR。其公布CardBoard这款廉价版的VR设备应用安装超过5000万，Android N已明确会加入VR模式，更重要的是，谷歌发布了VR平台Daydream.VR（白日梦）。</p>
<p>与Oculus Home等VR平台不同，Daydream不是VR内容平台，而是一套基于Android的制作VR内容和应用的标准解决方案。</p>
<p>其能有效降低延迟、减少眩晕感，支持智能手机，并可以将性能表现降低到20ms以下。基于Android N，它适用大量的手机品牌，这样以后用户通过VR盒子在这些手机上选择“VR模式”，在收看VR内容时体验就更好了——不过2K这个硬条件还是要手机厂商自己努力。</p>
<blockquote>
<p><strong>小米之前造势说会出现在Google I/O，确实出现了，见下图：</strong>      </p>
</blockquote>
<p><img src="http://img.leikeji.com/resource/img/e92c0cbc149f41d58998ff92edf910a7.png" alt=""><br><strong>Daydream.VR会支持的手机厂商</strong></p>
<p>目前，Daydream已有不少合作App，HULU、Netflix等知名内容平台加入其中，同时谷歌街景等App支持Daydream.VR。用户通过兼容Daydream.VR的App，搭载Android N手机，可以看电影、玩游戏、看街景等，会有更好的VR体验。</p>
<p>Daydream VR是一个开放式的VR解决方案。它并不是一个针对VR设备的OS，因为这套方案是基于Android N的。不过，未来Daydream VR或许会演进出一套更独立的系统，类似于Android Wear。Daydream.VR将在今年秋天正式推出。</p>
<p><img src="http://img.leikeji.com/resource/img/f43bd2244218473aa4346ba833ffdc8d.png" alt=""></p>
<p>Daydream.VR支持头戴设备，谷歌提供了关于此的参考产品（类似于Nexus产品之于Android的价值），这是一个纯白色的产品，具有简单的控制器，应该就是传说中的Android VR了，比CardBoard确实要精致点，但感觉还是比较简陋的。</p>
<p>谷歌并未正式发布这款产品，亮相应该还要等些时间。</p>
<p><img src="http://img.leikeji.com/resource/img/c54f0c1629cc45e990f9fa9e7ae9f5d3.gif" alt=""></p>
<h3 id="Android-Wear-2-0发布，可独立于手机使用"><a href="#Android-Wear-2-0发布，可独立于手机使用" class="headerlink" title="Android Wear 2.0发布，可独立于手机使用"></a>Android Wear 2.0发布，可独立于手机使用</h3><p>2014年，Android Wear正式发布，这个系统并未普及开来，除了Moto360和华为Watch支持之外，另一个明星智能手表即三星Gear采取了自家的Tizen系统。并且相对于智能手环和智能手机而言，智能手表市场一直没被打开，老大哥Apple Watch好不容易卖到千万台，今年一季度又迎来了超过60%的大幅下滑。</p>
<p>所以，智能手表何去何从，大家还是挺迷茫的。在去年I/O大会上有过小幅更新之后，Android Wear在I/O大会上发布了2.0版本。在发布时，谷歌表示，有了过去两年的教训之后，终于了解了人们对智能手表的需求。好吧，这个速度真的有点慢啊。</p>
<p>在新版中，增加了智能回复、手写识别以及全新的自动键盘。智能回复是本次I/O大会上不断强调的点，不便于输入的手表更有这样的需求，所以这个功能还是挺有吸引力的。就算要输入，通过Android Wear2.0的手写或自动键盘效率可更好，因为它们底层都应用了机器学习技术。</p>
<p>最大亮点则是，Android Wear 2.0 的手表可独立于手机使用了。它支持手表自己使用蜂窝网络和WIFI网络，还能独立播放本地音乐，独立记录运动数据，优化了运动记录算法，并与Google Fit API接口打通，可支持营养应用和蓝牙音乐。</p>
<p>Android Wear 2.0开发者预览版已经上线，正式版需要到今年秋天才会向用户推送。</p>
<p>除了谷歌助理、谷歌Home、谷歌Allo（以及Duo）、Android N、DayDream.VR和Android Wear 2.0 这6个与消费者息息相关的产品之外，谷歌针对开发者还发布了Studio2.0、Firebase等工具，以及将较多篇幅放在了基于H5技术的App形态即Android Instant Apps上，这一应用基于云端，无需安装，所见即所得，是ChromeOS的核心理念，未来或许在Android上会越来越多，而这一切对用户是透明的。</p>
<p>Google I/O 2016年虽然没有类似于Google Glass、Google无人驾驶汽车这样的“全新产品”惊艳亮相，但依然还是十分赞的，从这个大会可以看到谷歌未来的侧重点：</p>
<blockquote>
<p><strong> 1、人工智能将成为谷歌业务的“血液”。</strong>   </p>
</blockquote>
<p>这一届I/O大会让用户能够深切感知到AI技术的应用，比如谷歌助理、谷歌Home均是典型的人工智能应用。而谷歌Allo，以及Android Wear2.0都开始引入“助理”概念，谷歌正在想办法帮用户做更多的事情。AlphaGo将谷歌推上人工智能的神坛，现在谷歌正在将掌握的前沿人工各种技术应用到更多产品，造福用户。日前，桑达•劈材在最近的公开信中说，这个世界将从“移动设备优先”变为“人工智能优先”，I/O大会表明谷歌对这一世界观正在快速行动。</p>
<p><img src="http://img.leikeji.com/resource/img/dc8abc799bc94e73a72eafd6799e8201.png" alt=""></p>
<blockquote>
<p><strong>2、谷歌对待VR的态度是做标准缔造者。</strong></p>
</blockquote>
<p>谷歌对VR非常积极，去年I/O大会就推出了CardBoard并开源，以帮助VR快速普及，与Amazon、Apple的观望态度，以及微软押宝AR（增强现实）的态度，完全不同。</p>
<p>本次I/O大会虽然谷歌并未如外界期望那样做重度VR产品，但推出Daydream.VR这样的标准解决方案，对VR行业比做一款设备更具现实意义。安卓还是Nexus手机重要？答案显然是安卓。做VR设备只会是谷歌推标准的手段，而不是目的，这与Facebook押宝Oculus有巨大不同。因此，虽然Android VR没来，但做了“白日梦”的谷歌并未让人失望，它将VR当做长期投资在做，将在一起起到安卓之于智能手机行业的角色。</p>
<blockquote>
<p><strong>3、为什么没有汽车？因为I/O大会不吹牛。</strong></p>
</blockquote>
<p>这次谷歌并未如许多人预期那样发布与谷歌无人驾驶汽车相关的消息——而是聚焦在四大领域：手机、家居、可穿戴和VR，并且AI技术被贯穿其中。关于汽车几乎只字未提，是谷歌不重视汽车吗？答案是否定的，谷歌是无人驾驶汽车最激进的玩家，没有谈无人驾驶汽车或许是因为这个业务距离消费者还有很远的距离，并且I/O大会的背景是开发者大会，谷歌公布的事情与开发者均是息息相关的，现在开发者能够针对无人车做什么呢？什么都不能做。所以，谷歌在I/O大会不提汽车就不见怪了。</p>
<h3 id="小结一下："><a href="#小结一下：" class="headerlink" title="小结一下："></a>小结一下：</h3><p>谷歌I/O大会并未带来太大惊喜，但依然体现了浓浓的谷歌风格。这次大会发布了比设备更重要的VR解决方案，发布了与人工智能息息相关的软硬件，还有Android Wear 2.0、Android N以及大量的开发者工具，均表明谷歌的野心从来都不是一款产品，而是一个大家都能一起玩儿的真生态，从安卓到Chrome再到Daydream.VR，透露着浓浓的谷歌情怀</p>
<p><strong>原文链接：<a href="http://www.leikeji.com/article/5763" target="_blank" rel="external">雷科技-2016 Google IO 大会</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用Git Command 秀操作啦 ]]></title>
      <url>http://yoursite.com/2016/05/18/2016-05-16-git/</url>
      <content type="html"><![CDATA[<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><h2 id="将远程的git仓库关联到本地"><a href="#将远程的git仓库关联到本地" class="headerlink" title="将远程的git仓库关联到本地"></a>将远程的git仓库关联到本地</h2><ul>
<li>首先我们需要在远程(github)仓库创建一个仓库，这里的测试仓库是base_project</li>
<li>就需要将远程的仓库和本地关联<br>  a. 需要在本地创建一个和服务器一样的文件夹（base_project）<br>  b. 在这个文件夹下打开git命令窗口<br>  c. 初始化git ： </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    $ git init</span><br><span class="line">    Initialized empty Git repository in D:/android project/test/base_project/.git/</span><br><span class="line"></span><br><span class="line">    <span class="number">10142</span><span class="meta">@DESKTOP</span>-<span class="number">21</span>D76NU MINGW64 /d/android project/test/base_project (master)</span><br><span class="line"></span><br><span class="line">~~~     </span><br><span class="line"></span><br><span class="line">我们能够发现在当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。       </span><br><span class="line">    d. 将本地的仓库和远程的仓库进行关联     </span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">    <span class="number">10142</span><span class="meta">@DESKTOP</span>-<span class="number">21</span>D76NU MINGW64 /d/android project/test/base_project (master)</span><br><span class="line">    $ git remote add origin https:<span class="comment">//github.com/lipengfeng/base_project.git</span></span><br></pre></td></tr></table></figure>
<p>这时将可以查看远程仓库了 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p><strong>备注</strong>:<strong>origin</strong>就是我们的远程库的名字，这是Git默认的叫法，也可以改成别的;<br><strong><a href="https://github.com/lipengfeng/base_project.git" target="_blank" rel="external">https://github.com/lipengfeng/base_project.git</a></strong>是我们远程仓库的路径(这里我们使用的github)</p>
<h2 id="创建文件并提交到远程仓库"><a href="#创建文件并提交到远程仓库" class="headerlink" title="创建文件并提交到远程仓库"></a>创建文件并提交到远程仓库</h2><ul>
<li><p>这样我们就可以开始在本地的文件夹中做事了,这里我们先创建一个MainActivity.java文件</p>
</li>
<li><p>创建文件 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch MainActivity.java</span><br></pre></td></tr></table></figure>
<ul>
<li>将文件添加到本地仓库       </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add MainActivity.java</span><br></pre></td></tr></table></figure>
<ul>
<li>将文件提交到本地缓存区</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"书写提交信息"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将文件推送到远程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -<span class="function">u origin <span class="title">master</span><span class="params">(分支)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>将远程的文件下拉到本地</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
<p>注意如果想添加不同目录下的文件：那么我们要修改目录</p>
<ul>
<li>添加不同路径的文件（<strong>ps:其他的保持不变就可以将其提交上去</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add read/read.txt</span><br></pre></td></tr></table></figure>
<h2 id="分支-branch-操作相关命令"><a href="#分支-branch-操作相关命令" class="headerlink" title="分支(branch)操作相关命令"></a>分支(branch)操作相关命令</h2><ul>
<li>查看本地分支</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 举个例子 下面就是返回了一个master分支</span><br><span class="line">10142@DESKTOP-21D76NU MINGW64 /d/android project/test/base_project (master)</span><br><span class="line">$ git branch</span><br><span class="line">master</span><br><span class="line"></span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看远程分支  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    git branch -r</span><br><span class="line"><span class="comment">/*</span><br><span class="line">    git branch -r</span><br><span class="line">    origin/master</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p><em>创建本地分支（<em>*ps:该命令创建本地分支后并不会切换到该分支</em></em>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch dev[分支名]</span><br><span class="line"><span class="comment">/* 我们可以看到当前的分支已经有两个了</span><br><span class="line">$ git branch</span><br><span class="line">dev</span><br><span class="line">master</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>切换分支<br>在切换分支之前，先查看一下当前处于哪个分支？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 可以看到当前仍然处于 master分支上</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with 'origin/master'.</span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line"></span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev[分支名]</span><br><span class="line"><span class="comment">/* 我们可以看到，当执行切换分支的命令之后，就会将分支切换到另一个分支</span><br><span class="line"></span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch 'dev'</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line"></span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建分支并立即切换到新分支</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    git </span><br><span class="line">    $ git checkout -b other[分支名]</span><br><span class="line">    Switched to a <span class="keyword">new</span> branch <span class="string">'other'</span></span><br><span class="line">~~~     </span><br><span class="line"></span><br><span class="line">* 删除分支</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">    git branch -d other[分支名]</span><br><span class="line">    <span class="comment">/* 可以看到这里报错了，这是因为， 删除的时候我们需要</span><br><span class="line">    切换到其他分支才能删除该分支</span><br><span class="line">    $ git branch -d other</span><br><span class="line">    error: Cannot delete the branch 'other' which you are currently on.</span><br><span class="line">    $ git checkout dev</span><br><span class="line">    Switched to branch 'dev'</span><br><span class="line"></span><br><span class="line">    $ git branch -d other</span><br><span class="line">    Deleted branch other (was 0e7e027).</span><br><span class="line"></span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>本地分支push到远程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    git push origin dev[分支名]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">    $ git push origin dev</span><br><span class="line">    Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">    git To https://github.com/lipengfeng/base_project.git</span><br><span class="line">    * [new branch]      </span><br><span class="line">    dev -&gt; dev</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除远程分支</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin:heads/dev 或者 git push origin:dev</span><br></pre></td></tr></table></figure>
<ul>
<li>合并分支</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git merge dev -----将名为dev的分支与当前分支合并</span><br><span class="line">$ git merge dev</span><br><span class="line">Already up-to-date.</span><br></pre></td></tr></table></figure>
<h2 id="git-远程仓库管理"><a href="#git-远程仓库管理" class="headerlink" title="git 远程仓库管理"></a>git 远程仓库管理</h2><ul>
<li>查看远程服务地址和名称</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    git remote -v <span class="comment">//查看远程服务地址和仓库名称</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    $ git remote -v</span><br><span class="line">    origin  https://github.com/lipengfeng/base_project.git (fetch)</span><br><span class="line">    origin  https://github.com/lipengfeng/base_project.git (push)</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看远程服务器仓库状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line"><span class="comment">/*</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/lipengfeng/base_project.git</span><br><span class="line">  Push  URL: https://github.com/lipengfeng/base_project.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    dev    tracked</span><br><span class="line">    master tracked</span><br><span class="line">  Local branch configured for 'git pull':</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local refs configured for 'git push':</span><br><span class="line">    dev    pushes to dev    (up to date)</span><br><span class="line">    master pushes to master (up to date)</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>克隆远程仓库到本地</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/lipengfeng/base_project.git</span></span><br><span class="line"></span><br><span class="line">$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br><span class="line"><span class="comment">/*该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>添加远程仓库地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@ github:robbin/robbin_site.git</span><br><span class="line"><span class="comment">//这一点在关联远程仓库的时候已经说过了，所以这里不再赘述</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改远程仓库地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@ github.com:robbin/robbin_site.git </span><br><span class="line"><span class="comment">//设置远程仓库地址(用于修改远程仓库地址)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除远程仓库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm &lt;repository&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git暂存管理"><a href="#git暂存管理" class="headerlink" title="git暂存管理"></a>git暂存管理</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash                        # 暂存  </span><br><span class="line">git stash list                   # 列所有stash  </span><br><span class="line">git stash apply                  # 恢复暂存的内容  </span><br><span class="line">git stash drop                   # 删除暂存区</span><br></pre></td></tr></table></figure>
<h2 id="其他一些命令"><a href="#其他一些命令" class="headerlink" title="其他一些命令"></a>其他一些命令</h2><p><strong>git log:</strong>查看历史日志<br><strong>git rm:</strong>从当前工作空间/索引中删除文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm app/model/user.rb</span><br></pre></td></tr></table></figure>
<p><strong>git revert:</strong>git revert：还原一个版本的修改，必须提供一个具体的Git版本号，Git的版本号都是生成的一个哈希值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert bbaf6fb5060b4875b18ff9ff637ce118256d6f20</span><br></pre></td></tr></table></figure>
<p><strong>git checkout</strong>：Git的checkout有两个作用，其一是在不同的branch之间进行切换，例如’git checkout new_branch’就会切换到new_branch的分支上去；另一个功能是还原代码的作用，例如’git checkout app/model/user.rb’就会将user.rb文件从上一个已提交的版本中更新回来，<br>未提交的内容全部会回滚<br><strong>git rebase:</strong>用下面两幅图解释会比较清楚一些，rebase命令执行后，实际上是将分支点从C移到了G，这样分支也就具有了从C到G的功能<br><img src="http://my.csdn.net/uploads/201205/02/1335955913_5248.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ToolBar简单的使用 ]]></title>
      <url>http://yoursite.com/2016/05/16/2016-05-14-ToolBar/</url>
      <content type="html"><![CDATA[<h1 id="ToolBar简介"><a href="#ToolBar简介" class="headerlink" title="ToolBar简介"></a>ToolBar简介</h1><p><strong>导语:</strong></p>
<p>ToolBar是android5.0推出的新的导航控件，用于取代以前的actioBar,由于其高度的可定制性、灵活性、具有Material Design风格等优点，越来越多的应用也用上了ToolBar,比如常用的知乎软件其顶部导航栏正是使用ToolBar。官方考虑到有一部分的手机版本号低于5.0，所以，ToolBar也放进了support v7包内，使得低版本的系统也能够使用ToolBar。本文将使用support v7支持包的ToolBar来进行讲解，包括其基本用法样式定制等之时点。</p>
<h2 id="ToolBar的基本使用"><a href="#ToolBar的基本使用" class="headerlink" title="ToolBar的基本使用"></a>ToolBar的基本使用</h2><blockquote>
<p>引入support v7支持包</p>
</blockquote>
<p>在你的项目中的build.gradle内输入如下代码，即可引入支持包，该支持包内有向下兼容的ToolBar:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">    compile fileTree(<span class="symbol">dr:</span> <span class="string">'libs'</span> , <span class="symbol">include:</span>[<span class="string">'*.jar'</span>])</span><br><span class="line">    compile <span class="string">'com.android.support:appcompat-v7:23.1.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h2><p>为了能够正常使用ToolBar，我们需要隐藏原来的ActionBar,这个可以在主题中修改，在values/styles.xml中做出如下修改：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"AppTheme"</span> parent=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>
<p>继承了<strong>Theme.Appcompat.Light.NoActionBar</strong>主题，这里提一下，这个Theme.Appcompat是支持包内的主题，对应着5.0版本的Theme.Material主题。然后在Manifest文件中引用这个主题。</p>
<p>##在布局文件中创建这个控件</p>
<blockquote>
<p>activity_main.xml文件中，代码如下：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"</span><br><span class="line">    android:layout_width="match_parent"</span><br><span class="line">    android:layout_height="match_parent"</span><br><span class="line">    android:orientation="vertical"&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id="@+id/toolbar"</span><br><span class="line">        android:layout_width="match_parent"</span><br><span class="line">        android:background="?attr/colorPrimary"</span><br><span class="line">        android:layout_height="wrap_content"&gt;</span><br><span class="line"></span><br><span class="line">       &lt;TextView</span><br><span class="line">          android:layout_width="match_parent"</span><br><span class="line">          android:layout_height="wrap_content"</span><br><span class="line">          android:textColor="@color/color_edebeb"</span><br><span class="line">          android:text="标题"</span><br><span class="line">          android:textSize="20sp"/&gt;</span><br><span class="line">    &lt;/android.support.v7.widget.Toolbar&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure>
<p>在上面，创建了android.support.v7.widgt.ToolBar,同时我们在内部放了一个TextView,这是与ActionBar最大的不同，因为ToolBar实际上是一个ViewGroup，支持在其内放子View。ok，我们运行程序，得到如下结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1734948-400fe8513b394718.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看出ToolBar正常显示，当然了，这只是最简单的用法，接下来我们逐步添加内容、样式，使它看起开更加美，功能更加完善。</p>
<h2 id="ToolBar的完善"><a href="#ToolBar的完善" class="headerlink" title="ToolBar的完善"></a>ToolBar的完善</h2><ul>
<li><strong>首先我们考虑改变ToolBar的颜色</strong></li>
</ul>
<p>要想改变toolbar的颜色很简单，直接在布局文件中添加一个backgroud属性指定颜色就可以了，但是为了全局考虑，我们可以这样：在values/styles.xml文件中做出如下修改：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;</span><br><span class="line">    &lt;!-- Customize your theme here. --&gt;</span><br><span class="line">    &lt;item name="colorPrimary"&gt;#2e8abb&lt;/item&gt; &lt;!--浅蓝色--&gt;</span><br><span class="line">    &lt;item name="colorPrimaryDark"&gt;#3A5FCD&lt;/item&gt; &lt;!--深蓝色--&gt;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<p>然后在布局文件中，添加如下属性：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">android:</span>background=<span class="string">"?attr/colorPrimary"</span></span><br></pre></td></tr></table></figure>
<p>这样，就能方便对每一个toolbar引用同样的颜色了，我们先看看现在的效果是怎样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1734948-232e075f427b1ed5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到，颜色已经改变，同时我们注意到，顶部状态栏的颜色也变成了深蓝色，这是因为添加了”colorPrimaryDark”的属性，使得顶部状态栏随之改变，利用这一特性，我们可以轻松实现“状态栏沉浸”的效果了。当然，这只适用于Android 5.0以上，如果在低版本则这个属性无效。这里再附上一张图（图片来自<a href="http://blog.csdn.net/bbld_/article/details/41439715" target="_blank" rel="external">http://blog.csdn.net/bbld_/article/details/41439715</a>）：</p>
<p><img src="http://img.blog.csdn.net/20141122125624647" alt=""></p>
<p>根据图中的说明，我们可以轻松地在styles.xml文件中定制我们的样式，如果想要改变toolbar的<em>title</em>、<em>subtitle</em>以及<em>menu</em>中文字的颜色，可以利用“textColorPrimary”属性等。</p>
<ul>
<li><strong>添加title、subtitle、logo、导航栏图标</strong></li>
</ul>
<p>在MainActivity文件先获取控件的实例，接着通过一系列的set方法即可设置，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Toolbar toolbar;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">      toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">      toolbar.setTitle(<span class="string">"Title"</span>);</span><br><span class="line">      toolbar.setSubtitle(<span class="string">"SubTitle"</span>);</span><br><span class="line">      toolbar.setLogo(R.mipmap.ic_launcher);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//设置导航图标要在setSupportActionBar方法之后</span></span><br><span class="line">      setSupportActionBar(toolbar);</span><br><span class="line">      toolbar.setNavigationIcon(R.mipmap.ic_drawer_home);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1734948-2adaca43f1c531b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如果你想修改标题和子标题的字体大小、颜色等，可以调用 <strong>setTitleTextColor</strong> 、 <strong>setTitleTextAppearance</strong> 、 <strong>setSubtitleTextColor</strong> 、 <strong>setSubtitleTextAppearance</strong> 这些API。当然，这些设置都是支持在xml布局中直接添加的，但是用的不是android:命名空间，而是自定义命名空间，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"</span><br><span class="line">  xmlns:toolbar="http://schemas.android.com/apk/res-auto"</span><br><span class="line">  ...&gt;</span><br><span class="line">  &lt;android.support.v7.widget.Toolbar</span><br><span class="line">      ...</span><br><span class="line">      toolbar:logo="@mipmap/ic_launcher"</span><br><span class="line">      toolbar:title="Title"</span><br><span class="line">      toolbar:subtitle="Sub Title"</span><br><span class="line">      toolbar:titleTextColor="#ffffff"&gt;</span><br><span class="line">  &lt;/android.support.v7.widget.Toolbar&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>添加菜单选项图标及点击事件</strong></li>
</ul>
<p>3.1 添加菜单选项图标</p>
<p>一般导航条，在其右侧都会有菜单选项，当然ToolBar也是支持自定义菜单的，首先我们在菜单文件中，修改如下：res/menu/menu_main.xml:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"</span><br><span class="line">    xmlns:app="http://schemas.android.com/apk/res-auto"</span><br><span class="line">    xmlns:tools="http://schemas.android.com/tools" tools:context=".MainActivity"&gt;</span><br><span class="line">    &lt;item android:id="@+id/action_search"</span><br><span class="line">        android:title="Search"</span><br><span class="line">        android:icon="@mipmap/ic_search"</span><br><span class="line">        app:showAsAction="ifRoom"/&gt;</span><br><span class="line">    &lt;item android:id="@+id/action_notifications"</span><br><span class="line">        android:title="notifications"</span><br><span class="line">        android:icon="@mipmap/ic_notifications"</span><br><span class="line">        app:showAsAction="ifRoom"/&gt;</span><br><span class="line">    &lt;item android:id="@+id/action_settings"</span><br><span class="line">        android:title="@string/action_settings"</span><br><span class="line">        android:orderInCategory="100"</span><br><span class="line">        android:icon="@mipmap/ic_launcher"</span><br><span class="line">        app:showAsAction="never"/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>
<p>这里用了这样一个熟悉：app:showAsAction=”ifRoom”/“never”，app是自定义的命名空间，因为我们的activity继承的是AppCompatActivity，是support v7包的，并不是原生sdk内部的，因此不能使用android:showAsAction，否则会报错。然后ifRoom表示有空间则显示，never表示从不显示，而是会通过overflowwindow显示。<br>接着我们在Activity中，要重写onCreateOptionsMenu()方法，把这个菜单加载进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Overridepublic</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123; </span><br><span class="line">       getMenuInflater().inflate(R.menu.menu_main, menu);   </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.2 添加点击事件</p>
<p>菜单有了，我们要为菜单添加点击事件，这样菜单才会有实际用途,添加点击事件也很方便，可以这样操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置导航图标、添加菜单点击事件要在setSupportActionBar方法之后</span></span><br><span class="line">      setSupportActionBar(toolbar);</span><br><span class="line">      toolbar.setNavigationIcon(R.mipmap.ic_drawer_home);</span><br><span class="line"></span><br><span class="line">      toolbar.setOnMenuItemClickListener(<span class="keyword">new</span> Toolbar.OnMenuItemClickListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMenuItemClick</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">                  <span class="keyword">case</span> R.id.action_search:</span><br><span class="line">                      Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"Search !"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">case</span> R.id.action_notifications:</span><br><span class="line">                      Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"Notificationa !"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">case</span> R.id.action_settings:</span><br><span class="line">                      Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"Settings !"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1734948-5e259fffe328a60e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到，菜单选项图标正常显示，以及点击事件都正常触发，但是还有一点瑕疵的地方，那就是右上角的三个圆点，是黑色的，与图标格格不入，有没有什么办法改变它呢？答案是有的，可以通过添加样式改变，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  &lt;resources&gt;</span><br><span class="line">    &lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;item name="android:textColorSecondary"&gt;#ffffff&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<p>“android:textColorSecondary”属性对应的就是右上角三个圆点的颜色了。改变之后将会变成你要的颜色。</p>
<p>3.3 其他样式修改</p>
<p><em>修改Toolbar popup menu样式</em></p>
<p>我们先点击右上角的三个点，会弹出一个popup menu，如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1734948-7ba30760a0cc8c55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到右上角的popup menu是白底黑字，那么有没有什么办法改变它的背景颜色，使菜单显示为黑底白字呢呢？答案是有的，我们可以这样设置：<br>首先在styles.xml文件中，新建一个主题：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  &lt;!-- toolbar弹出菜单样式 --&gt;</span><br><span class="line">&lt;style name="ToolbarPopupTheme" parent="@style/ThemeOverlay.AppCompat.Dark"&gt;   </span><br><span class="line">     &lt;item name="android:colorBackground"&gt;#000000&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到这个主题的parent是直接继承自ThemeOverlay.AppCompat.Dark，是支持包的一个主题，并且我们在内部声明了“android:colorBackground”这个属性，我们只要更改这个属性就能变更菜单的背景颜色了。接下来我们在布局文件中引入这个主题，这也很简单，为toolbar添加额外的属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolbar:popupTheme=<span class="string">"@style/ToolbarPopupTheme"</span></span><br></pre></td></tr></table></figure>
<p>这样，改几行代码即可修改popup menu的背景颜色了，如下面所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1734948-d08d2fa17f674de1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>修改Toolbar popup menu 弹出位置</strong></p>
<p>我们可以看到，popup menu的位置是过于偏上的，我们还可以修改它的位置，使它处于Toolbar之下，这样看起来可能更美观：<br>修改styles.xml文件如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">style name="ToolbarPopupTheme" parent="@style/ThemeOverlay.AppCompat.Dark"&gt;    </span><br><span class="line">    &lt;item name="android:colorBackground"&gt;#000000&lt;/item&gt;    </span><br><span class="line">    &lt;item name="actionOverflowMenuStyle"&gt;@style/OverflowMenuStyle&lt;/item&gt; &lt;!--新增一个item，用于控制menu--&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;style name="OverflowMenuStyle" parent="Widget.AppCompat.Light.PopupMenu.Overflow"&gt;   </span><br><span class="line">     &lt;item name="overlapAnchor"&gt;false&lt;/item&gt;  &lt;!--把该属性改为false即可使menu位置位于toolbar之下--&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>效果如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1734948-bfdac39320195e5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>那么到目前为止，对于toolbar的相关使用意见讲述完毕，可以看出toolbar的灵活性很高，能自定义很多样式，我们平常开发也会遇到各种不同的样式，因此toolbar用于取代actionbar是非常合适的。以后如果还有遇到别的样式，我也会分享出来，谢谢。</p>
<blockquote>
<p>参考文档：<br><a href="http://www.aichengxu.com/view/2559126" target="_blank" rel="external">Toolbar-5.0新特性</a><br><a href="http://blog.csdn.net/bbld_/article/details/41439715" target="_blank" rel="external">Android Material Design之Toolbar与Palette实践</a><br><a href="http://www.jianshu.com/p/79604c3ddcae" target="_blank" rel="external">Android开发：最详细的 Toolbar 开发实践总结</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[github关联远程仓库 ]]></title>
      <url>http://yoursite.com/2016/05/14/2016-05-14-github/</url>
      <content type="html"><![CDATA[<h1 id="github关联远程仓库"><a href="#github关联远程仓库" class="headerlink" title="github关联远程仓库"></a>github关联远程仓库</h1><h2 id="一-本机远程仓库进行关联"><a href="#一-本机远程仓库进行关联" class="headerlink" title="一. 本机远程仓库进行关联"></a>一. 本机远程仓库进行关联</h2><p>1.1. 在本机创建SSH Key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"eksliang@163.com"</span></span><br></pre></td></tr></table></figure>
<p>一直回车，会在本地生产~/.ssh文件夹，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
<p>1.2.    登录github让本机与github进行关联<br><img src="http://dl2.iteye.com/upload/attachment/0112/3536/318a624c-b3d3-34f3-b26c-80d948a6a8dd.png" alt=""></p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容；<br>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。<br>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<h2 id="二-在github上新建仓库（repository）"><a href="#二-在github上新建仓库（repository）" class="headerlink" title="二.在github上新建仓库（repository）"></a>二.在github上新建仓库（repository）</h2><p><img src="http://dl2.iteye.com/upload/attachment/0112/3540/f81a6b04-be1b-3901-ac3a-0fd984a6896b.png" alt=""><br>此时仓库还是空的，GitHub告诉我们，可以有2种方式进行创建，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。如下所示：</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0112/3542/7f184069-47fd-3313-9bc7-b930d94ff1c6.png" alt=""></p>
<p>现在，我们根据GitHub的提示，在本地仓库下运行命令，把本地仓库的内容推送到GitHub仓库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git<span class="meta">@github</span>.com:ickess/demo.git  </span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p><strong>命令解释如下：</strong></p>
<p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库（建议不要改动，跟整个行业同步起来）<br>本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，以后的推送时可以去掉-u参数。推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。</p>
<p>从现在起，只要本地作了提交，就可以通过命令，将本地的最新代码推送至远程仓库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<h2 id="三-github删除仓库"><a href="#三-github删除仓库" class="headerlink" title="三.github删除仓库"></a>三.github删除仓库</h2><p><img src="http://dl2.iteye.com/upload/attachment/0112/3546/97f6c95e-15db-33d7-9944-466d01ee5f57.png" alt=""><br><img src="http://dl2.iteye.com/upload/attachment/0112/3548/4fd3ec72-7be4-3bdf-b0e5-23d91f877462.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MVP的简单介绍(内含第三方demo)]]></title>
      <url>http://yoursite.com/2016/05/06/MVP%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D(%E5%86%85%E5%90%AB%E7%AC%AC%E4%B8%89%E6%96%B9demo)/</url>
      <content type="html"><![CDATA[<h1 id="MVP的简单介绍"><a href="#MVP的简单介绍" class="headerlink" title="MVP的简单介绍"></a>MVP的简单介绍</h1><h2 id="一、什么是-MVP"><a href="#一、什么是-MVP" class="headerlink" title="一、什么是 MVP"></a>一、什么是 MVP</h2><h3 id="1-MVP-的定义"><a href="#1-MVP-的定义" class="headerlink" title="1. MVP 的定义"></a>1. MVP 的定义</h3><p>MVP，全称 Model-View-Presenter<br>MVP（Model-View-Presenter，模型-视图-表示器）模式则是由IBM开发出来的一个针对C++和Java的编程模型，大概出现于2000年，是MVC模式的一个变种，主要用来隔离UI、UI逻辑和业务逻辑、数据。也就是说，MVP 是从经典的模式MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。</p>
<p>说明：按照View和Presenter之间的交互方式以及View本身的职责范围，Martin Folwer将MVP可分为PV（Passive View）和SoC（Supervising Controller）两种模式。</p>
<p><strong>Passive View</strong><br>顾名思义，PV（Passive View）是一个被动的View，针对包含其中的UI元素（比如控件）的操作不是由View自身来操作，而交给Presenter来操控。</p>
<p><strong>Supervising Controller</strong><br>在SoC（Supervising Controller）模式下，为了降低Presenter的复杂度，将诸如数据绑定和格式化这样简单的UI处理逻辑逻辑转移到View中，这些处理逻辑会体现在View实现的接口中。</p>
<h3 id="2-为什么使用MVP"><a href="#2-为什么使用MVP" class="headerlink" title="2. 为什么使用MVP"></a>2. 为什么使用MVP</h3><p>现在大部分的android程序只是使用了model-view的结构。<br>那么我们更多的是和view打交道，而不是解决业务逻辑。<br>当我们在代码中使用m-v的时候，到最后会发现所以的事物被连到了一起。</p>
<p><img src="http://lookcode-wordpress.stor.sinaapp.com/uploads/2016/01/16.png" alt=""></p>
<p>那么，这样之后，我们的测试或者调试将变得异常的复杂。</p>
<p><strong>With MVP</strong><br>使用MVP</p>
<p><img src="http://lookcode-wordpress.stor.sinaapp.com/uploads/2016/01/22.png" alt=""></p>
<p>复杂的任务被分成细小的任务，并且很容易解决。越小的东西，bug越少，越容易debug，更好测试。在MVP模式下的View层将会变得简单，所以即便是他请求数据的时候也不需要回调函数。View逻辑变成十分直接。</p>
<h3 id="3-MVP的优缺点"><a href="#3-MVP的优缺点" class="headerlink" title="3.MVP的优缺点"></a>3.MVP的优缺点</h3><p>任何事务都存在两面性，MVP当然也不列外，我们来看看MVP的优缺点。<br><strong>优点：</strong><br>1.降低耦合度，实现了Model和View真正的完全分离，可以修改View而不影响Modle  </p>
<ol>
<li>模块职责划分明显，层次清晰（下面会介绍Bob大叔的Clean Architecture）     </li>
<li>隐藏数据     </li>
<li>Presenter可以复用，一个Presenter可以用于多个View，而不需要更改Presenter的逻辑（当然是在View的改动不影响业务逻辑的前提下）       </li>
<li>利于测试驱动开发。以前的Android开发是难以进行单元测试的（虽然很多Android开发者都没有写过测试用例，但是随着项目变得越来越复杂，没有测试是很难保证软件质量的；而且近几年来Android上的测试框架已经有了长足的发展——开始写测试用例吧），在使用MVP的项目中Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。       </li>
<li>View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。              </li>
<li>代码灵活性<br><strong>缺点：</strong>     </li>
<li>Presenter中除了应用逻辑以外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。    </li>
<li>由于对视图的渲染放在了Presenter中，所以视图和Presenter的交互会过于频繁。    </li>
<li>如果Presenter过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更，那么Presenter也需要变更了。  </li>
<li>额外的代码复杂度及学习成本。<br><strong>在MVP模式里通常包含4个要素：</strong></li>
</ol>
<p>(1) View :负责绘制UI元素、与用户进行交互(在Android中体现为Activity);<br>(2) View interface :需要View实现的接口，View通过View      interface与Presenter进行交互，降低耦合，方便进行单元测试;<br>(3) Model :负责存储、检索、操纵数据(有时也实现一个Model    interface用来降低耦合);<br>(4) Presenter :作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。</p>
<p><img src="http://new.51cto.com/files/uploadimg/20090430/1559491.jpg" alt=""></p>
<h3 id="4-Android-上-MVP-的几种实现"><a href="#4-Android-上-MVP-的几种实现" class="headerlink" title="4.Android 上 MVP 的几种实现"></a>4.Android 上 MVP 的几种实现</h3><p><strong>4.1 存取用户信息的demo：<br>原文：</strong><br><a href="http://blog.csdn.net/vector_yi/article/details/24719873" target="_blank" rel="external">MVP模式在Android开发中的应用 </a><br><strong>github</strong>:<a href="https://github.com/VectorYi/MVPSample" target="_blank" rel="external">https://github.com/VectorYi/MVPSample</a></p>
<p><img src="http://img.blog.csdn.net/20140429154522203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdmVjdG9yX3lp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从这其中的目录结构我们可以看出，将MVP分的很清楚，而且可以发现，<strong>Presenter</strong>与<strong>Model</strong>、<strong>View</strong>都是通过接口来进行交互的，既降低耦合也方便进行单元测试。<br>(1) 首先我们需要一个UserBean，用来保存用户信息<br>(2) 再来看看View接口：<br>        View可以对<strong>ID</strong>、<strong>FirstName</strong>、<strong>LastName</strong>这三个EditText进行读操作，对FirstName和LastName进行写操作，由此定义IUserView接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserView</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">getFristName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">getLastName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3) Model接口：<br>     同样，Model也需要对这三个字段进行读写操作，并存储在某个载体内(这不是我们所关心的，可以存在内存、文件、数据库或者远程服务器，但对于Presenter及View无影响),定义IUserModel接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserModel</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">UserBean <span class="title">load</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4) Presenter:<br>     至此，Presenter就能通过接口与View及Model进行交互了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPresenter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> IUserView mUserView;</span><br><span class="line">	<span class="keyword">private</span> IUserModel mUserModel;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserPresenter</span><span class="params">(IUserView view)</span> </span>&#123;</span><br><span class="line">		mUserView = view;</span><br><span class="line">		mUserModel = <span class="keyword">new</span> UserModel();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(<span class="keyword">int</span> id, String firstName, String lastName)</span> </span>&#123;</span><br><span class="line">		mUserModel.setID(id);</span><br><span class="line">		mUserModel.setFirstName(firstName);</span><br><span class="line">		mUserModel.setLastName(lastName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		UserBean user = mUserModel.load(id);</span><br><span class="line">		mUserView.setFirstName(user.getFirstName());</span><br><span class="line">		mUserView.setLastName(user.getLastName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(5)UserActivity:<br>     UserActivity实现了IUserView接口，同时有一个UserPresenter成员变量：<br>可以看到，View只负责处理与用户进行交互，并把数据相关的逻辑操作都扔给了Presenter去做。而Presenter调用Model处理完数据之后，再通过IUserView更新View显示的信息。</p>
<p><strong>4.2 天气查询的 MVP 小 Demo</strong><br>原文：<a href="http://rocko.xyz/2015/02/06/Android%E4%B8%AD%E7%9A%84MVP/" target="_blank" rel="external">Android中的MVP</a><br>github:<a href="https://github.com/zhengxiaopeng/Rocko-Android-Demos/tree/master/architecture/android-mvp" target="_blank" rel="external">https://github.com/zhengxiaopeng/Rocko-Android-Demos/tree/master/architecture/android-mvp</a></p>
<p><strong>包结构</strong></p>
<p><img src="http://rocko-blog.qiniudn.com/Android%E4%B8%AD%E7%9A%84MVP_2.png?imageView2/2/w/450/h/450/q/100" alt=""></p>
<p>包图中明显的三层：Model包、Presenter包、UI包，其中，三者都实现各自的结构，Model为WeatherModel、Presenter为WeatherPresenter、View为Weather，那么具体实现类就是impl包里的了，View层的即为Activity。     </p>
<p><strong>View里面的接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WeatherView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showLoading</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hideLoading</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showError</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWeatherInfo</span><span class="params">(Weather weather)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WeatherPresenter的接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WeatherPresenter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 获取天气的逻辑</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getWeather</span><span class="params">(String cityNO)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WeatherModel接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WeatherModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadWeather</span><span class="params">(String cityNO, OnWeatherListener listener)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prestener里面还有个<strong>OnWeatherListener</strong>，其在Presenter层实现，给Model层回调，更改View层的状态，确保Model层不直接操作View层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnWeatherListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 成功时回调</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> weather</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Weather weather)</span></span>;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 失败时回调，简单处理，没做什么</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.3. 使用 Activity/Fragment 作为 Presenter 的探索</strong></p>
<p>上面的示例 View 都是 Activity 来承担的，Presenter 是一个普通的类，Android 在不同场景下会进入不同的生命周期，这将可能导致 Presenter 也随着其生命周期需要做出响应。从这个角度考虑，有不少开发者提出了 MVP 实现的其他思路，接下来我们要探讨的就是<strong>使用 Activity/Fragment 作为 Presenter 的一些实现方案</strong>。</p>
<p><strong>4.3.1 一种实现MVP模式的新思路</strong><br><strong>原文</strong>：<a href="https://github.com/bboyfeiyu/android-tech-frontier/tree/master/androidweekly/%E4%B8%80%E7%A7%8D%E5%9C%A8android%E4%B8%AD%E5%AE%9E%E7%8E%B0MVP%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B0%E6%80%9D%E8%B7%AF" target="_blank" rel="external">一种在android中实现MVP模式的新思路</a><br><strong>源码</strong>：<a href="https://github.com/wongcain/MVP-Simple-Demo" target="_blank" rel="external">GitHub 地址</a>     </p>
<p>贴上作者对activity和fragment作为（View层）的见解：<br><strong>使用Activity和Fragment作为视图层(View)真的合适么?</strong></p>
<p>目前很多使用了MVP模式的android 项目,基本上都是将activity和fragment作为视图层来进行处理的.而presenters通常是通过继承自被视图层实例化或者注入的对象来得到的. 诚然,我同意说,这种方式可以节省掉很多让人厌烦的”import android..”语句, 并且将presenters从activity的生命周期中分割出来以后, 项目后续的维护会变得简便很多.这种思路是正确的， 但是,从另一个角度来说, activity 有一个很复杂的生命周期(fragment的生命周期可能会更复杂), 而这些生命周期很有可能对你项目的业务逻辑有非常重大的影响. Activity 可以获取上下文环境和多种android系统服务. Activity中发送Intent，启动Service和执行FragmentTransisitons等。而这些特性在我看来绝不应该是视图层应该涉及的领域(视图的功能就是现实数据和从用户那里获取输入数据，在理想的情况下，视图应该避免业务逻辑).      </p>
<p>基于上述的原因，我对目前的主流做法并不赞同，所以我在尝试使用Activity和Fragment作为Presenters。</p>
<p><strong>1. 去除所有的view</strong></p>
<p>将Activity和Fragment作为presenter最大的困难就是如何将关于UI的逻辑抽取出来.我的解决方案是: 让需要作为presenter的activity 或者 fragment来继承一个抽象的类(或者叫”基类”), 这样关于View 各种组件的初始化以及逻辑,都可以在继承了抽象类的方法中进行操作，而当继承了该抽象类的class需要对某些组件进行操作的时候，只需要调用继承自抽象类的方法，就可以了。<br>那么抽象类怎么获取到的view组件呢？在抽象类里面会有一个实例化的接口，这个接口里面的init()方法就会对view进行实例化，这个接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(LayoutInflater inflater, ViewGroup container)</span></span>;</span><br><span class="line">    <span class="function">View <span class="title">getView</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所见，Vu定义了一个通用的初始化例程，我可以通过它来实现一个容器视图，它也有一个方法来获得一个View的实例，每一个presenter将会和它自己的Vu关联，这个presenter将会继承这个接口（直接或者间接的去继承一个来自Vu的接口）</p>
<p><strong>2. 创建一个presenter基类 (Activity)</strong></p>
<p>有了Vu接口，我们可以通过构建一系列的class来操纵很多不同的view组件，这些class 使用Vu接口来初始化View组件，并通过继承的方式给子类以操纵view组件的方法，以此来达到将ui 逻辑剥离出activity的目的。</p>
<p>在下面的代码中，你可以看到，我覆写了activity的onCreate 、 onCreateView、onDestroy 、 onDestroyView，通过对这些方法的覆写，就可以对Vu的实例化和销毁进行精确的控制（vu.init()就是实例化一个view组件）。</p>
<p>onBindVu() 和onDestoryVu()是控制view生命周期的两个方法。通过对actiivty中相关方法的覆写达到控制组件的生命周期的目的（具体看下面的代码，你就明白了）， 这样做的好处就是无论是activity 还是 fragment， 其用与控制view组件创建和销毁的语句是一样的（尽量避免定义多余的函数）。这样的话，二者之间的切换也会减少一定的阻力（也许你今天的需求是用fragment实现的，但是第二天发现使用fragment会有一个惊天bug，译者本人就遇到过）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePresenterActivity</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">Vu</span>&gt; <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> V vu;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            vu = getVuClass().newInstance();</span><br><span class="line">            vu.init(getLayoutInflater(), <span class="keyword">null</span>);</span><br><span class="line">            setContentView(vu.getView());</span><br><span class="line">            onBindVu();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        onDestroyVu();</span><br><span class="line">        vu = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;V&gt; <span class="title">getVuClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onBindVu</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroyVu</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 创建一个基本的presenter(Fragment)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePresenterFragment</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">Vu</span>&gt; <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> V vu;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View view = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            vu = getVuClass().newInstance();</span><br><span class="line">            vu.init(inflater, container);</span><br><span class="line">            onBindVu();</span><br><span class="line">            view = vu.getView();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onDestroyView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        onDestroyVu();</span><br><span class="line">        vu = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroyVu</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onBindVu</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;V&gt; <span class="title">getVuClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 一个简单的例子</strong></p>
<p>如前文所述，我们已经确定了一个框架，现在就来写一个简单的例子来进一步的说明. 为了避免篇幅过长，我就写一个“hello world”的例子。首先要有一个实现Vu接口的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloVu</span> <span class="keyword">implements</span> <span class="title">Vu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">View view;</span><br><span class="line">TextView helloView;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(LayoutInflater inflater, ViewGroup container)</span> </span>&#123;</span><br><span class="line">    view = inflater.inflate(R.layout.hello, container, <span class="keyword">false</span>);</span><br><span class="line">    helloView = (TextView) view.findViewById(R.id.hello);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHelloMessage</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    helloView.setText(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>下一步</strong>，创建一个presenter来操作这个TextView</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloActivity</span> <span class="keyword">extends</span> <span class="title">BasePresenterActivity</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onBindVu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vu.setHelloMessage(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Class&lt;HelloVu&gt; <span class="title">getVuClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HelloVu.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK,这样就大功告成了！！是不是很简便！<br><strong>等等…耦合警告!</strong></p>
<p>你可能注意到我的HelloVu类直接实现了Vu接口，我的<strong>Presenter</strong>的<strong>getVuClass</strong>方法直接引用了实现类。传统的MVP模式中，Presenter是要通过接口与他们的View解耦合的。因此，你也可以这么做。避免直接实现Vu接口，我们可以创建一个扩展了Vu的<strong>IHelloView</strong>接口，然后使用这个接口作为Presenter的泛型类型。这样Presenter看起来应该是如下这样的 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloActivity</span> <span class="keyword">extends</span> <span class="title">BasePresenterActivity</span>&lt;<span class="title">IHelloVu</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onBindVu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vu.setHelloMessage(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Class&lt;HelloVuImpl&gt; <span class="title">getVuClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HelloVuImpl.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我使用强大的模拟工具过程中，我个人并没有看到在一个接口下面实现Vu所带来的好处。但是对于我来说一个好的方面是，有没有Vu接口它都能够工作，唯一的需求就是最终你会实现Vu。<br>使用adapter作为presenter</p>
<p>将Activity作为presente已经足够狡猾了吧？使用adapter作为presenter，你想过没有？ 好吧，请看如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePresenterAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> V vu;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        LayoutInflater inflater = (LayoutInflater) parent.getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            vu = (V) getVuClass().newInstance();</span><br><span class="line">            vu.init(inflater, parent);</span><br><span class="line">            convertView = vu.getView();</span><br><span class="line">            convertView.setTag(vu);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vu = (V) convertView.getTag();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(convertView!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        onBindListItemVu(position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> convertView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onBindListItemVu</span><span class="params">(<span class="keyword">int</span> position)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;V&gt; <span class="title">getVuClass</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.3.2. TheMVP 介绍</strong></p>
<p><strong>TheMVP</strong>使用Activity作为Presenter层来处理代码逻辑，通过让Activity包含一个<strong>ViewDelegate</strong>对象来间接操作View层对外提供的方法，从而做到完全解耦视图层。</p>
<p><strong>原文</strong>：<a href="http://www.kymjs.com/code/2015/11/09/01/" target="_blank" rel="external">用MVP架构开发Android应用</a><br><strong>源码</strong>：<a href="https://github.com/kymjs/TheMVP" target="_blank" rel="external">GitHub 地址</a></p>
<p><strong>TheMVP</strong>使用Activity作为Presenter层来处理代码逻辑，通过让Activity包含一个<strong>ViewDelegate</strong>对象来间接操作View层对外提供的方法，从而做到完全解耦视图层。如下图：<br><strong>TheMVP架构图</strong><br><img src="http://kymjs.com/images/blog_image/20151029_1.png" alt=""></p>
<p>要将Activity作为Presenter来写，需要让View变得可复用，必须解决的一个问题就是setContentView()如何调用，因为它是Activity(Fragment有类似)的方法。<br>我们需要把视图抽离出来独立实现。可以定义一个接口，来限定View层必须实现的方法(这个接口定义，也就是View层的代理对象)，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(LayoutInflater i, ViewGroup v, Bundle b)</span></span>;</span><br><span class="line">    <span class="function">View <span class="title">getRootView</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过<strong>inflater</strong>一个布局，将这个布局转换成<strong>View</strong>，再用g<strong>etRootView()</strong>方法把这个<strong>View</strong>返回给<strong>Presenter</strong>层，让<strong>setContentView(view)</strong>去调用，这样就实现了<strong>rootView</strong>的独立。<br>所以，在Presenter层，我们的实现应该是：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取到视图层对象</span></span><br><span class="line">    IDelegate viewDelegate = xxx;</span><br><span class="line">    <span class="comment">//让视图层初始化(如果是Fragment，就需要传递onCreateView方法中的三个参数)</span></span><br><span class="line">    viewDelegate.create(getLayoutInflater(), <span class="keyword">null</span>, savedInstanceState);</span><br><span class="line">    <span class="comment">//拿到初始化以后的rootview，并设置content</span></span><br><span class="line">    setContentView(viewDelegate.getRootView());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用泛型解耦</strong></p>
<p>现在我们是实现了<strong>View</strong>与<strong>Presenter</strong>的解耦，在onCreate中包含了一个接口对象来实现我们固定的一些必须方法。但是又引入了问题：一些特定方法没办法引用了。比如某个界面的设值、控件的修改显示逻辑对Presenter层的接口，接口对象必须强转成具体子类才能调用。<br>解决办法：可以通过泛型来解决直接引用具体对象的问题。比如我们可以在子类定义以后确定一个Presenter中所引用的<strong>Delegate</strong>的具体类型。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityPresenter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">IDelegate</span>&gt; <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> T viewDelegate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        viewDelegate = getDelegateClass().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;T&gt; <span class="title">getDelegateClass</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们在ActivityPresenter的继承类中就可以通过动态设置getDelegateClass()的返回值来确定Delegate的具体类型了。</p>
<p><strong>4.3.3 MVPro 介绍</strong></p>
<p><strong>MVPro</strong>的实现很简单，思想和上面两篇文章介绍的一样，都是将<strong>Activity</strong>和<strong>Fragment</strong>作为<strong>Presenter</strong>。<strong>Presenter</strong>即我们的<strong>Activity</strong>或者<strong>Fragment</strong>, View呢？说白了就是我们从Activity和Fragment中提取出来的和View操作相关的代码。</p>
<p><strong>原文</strong>：<a href="http://blog.csdn.net/qibin0506/article/details/49992897" target="_blank" rel="external">Android MVP框架MVPro的使用和源码分析</a><br><strong>源码</strong>：<a href="https://github.com/qibin0506/MVPro" target="_blank" rel="external">GitHub 地址</a></p>
<p><img src="http://www.mobile-open.com/wp-content/uploads/2016/04/20160405194433_243.png" alt=""></p>
<p>在<strong>MVPro</strong>中，将Activity，Fragment作为Presenter，并且提供了轻量级的<strong>ActivityPresenterImpl</strong>、<strong>FragmentPresenterImpl</strong>、<strong>FragmentActivityImpl</strong>的实现， 在项目中可以直接继承这些实现去做自己的presenter。<br>IPresenter作为Presenter必须要实现的接口，提供的方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 获取当前presenter泛型的类型</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function">Class&lt;T&gt; <span class="title">getViewClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * View初始化之前可以在此方法做一些操作</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Bundle savedInstance)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * View初始化完毕后调用</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">created</span><span class="params">(Bundle savedInstance)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中getViewClass在Ipresenter的实现类中已经完成了实现，我们的项目中无需考虑.<br>create方法是在setContentView之前调用的，我们可以在该方法中实现<br>例如：requestWindowFeature(Window.FEATURE_CUSTOM_TITLE);<br>等工作。<br>created方法是在setContentView之后调用，可以根据业务需要做自己的逻辑。</p>
<p><strong>**View</strong></p>
<p>在<strong>MVPro</strong>中，<strong>View</strong>层必须要实现IView接口，当然<strong>MVPro</strong>也提供了<strong>ViewImpl</strong>一个轻量级的实现，在我们的项目中完全可以直接继承<strong>ViewImpl</strong>。<br>Model</p>
<p>在MVPro中并没有提供关于model的代码</p>
<p><strong>4.4. Mosby 框架</strong></p>
<p>这是一种解决Activity/Fragment生命周期在屏幕翻转等场景下对Presenter的处理的思路。</p>
<p><strong>原文</strong>：<a href="http://hannesdorfmann.com/android/mosby" target="_blank" rel="external">Ted Mosby – Software Architect</a><br><strong>译文</strong>：<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0528/2945.html" target="_blank" rel="external">MVP框架 – Ted Mosby的软件架构</a><br><strong>源码</strong>：<a href="https://github.com/sockeqwe/mosby" target="_blank" rel="external">GitHub 地址</a></p>
<p><strong>MVP模块( MVP Module )</strong><br>Mosby库中的MVP模块使用泛型来确保类型安全。所有view的基类是MvpView。从根本上说这只是一个空的interface 。Presenter的基类是MvpPresenter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MvpView</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MvpPresenter</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">MvpView</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">attachView</span><span class="params">(V view)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">detachView</span><span class="params">(<span class="keyword">boolean</span> retainInstance)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把Activity和Fragment看做View。因此Mosby库的MVP模块提供了 属于MvpViews 的MvpActivity和MvpFragment作为Activity和Fragment的基类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MvpActivity</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">MvpPresenter</span>&gt; <span class="keyword">extends</span> <span class="title">MosbyActivity</span> <span class="keyword">implements</span> <span class="title">MvpView</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> P presenter;</span><br><span class="line">    <span class="meta">@Override</span>  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        presenter = createPresenter();</span><br><span class="line">        presenter.attachView(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">        presenter.detachView(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="title">PcreatePresenter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MvpFragment</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">MvpPresenter</span>&gt; <span class="title">MosbyFragment</span> <span class="keyword">implements</span> <span class="title">MvpView</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Ppresenter;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(View view,@Nullable Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view,savedInstanceState);</span><br><span class="line">        <span class="comment">// Create the presenter if needed</span></span><br><span class="line">        <span class="keyword">if</span>(presenter == <span class="keyword">null</span>)&#123;</span><br><span class="line">            presenter = createPresenter();</span><br><span class="line">        &#125;</span><br><span class="line">        presenter.attachView(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroyView</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView();</span><br><span class="line">        presenter.detachView(getRetainInstance());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="title">PcreatePresenter</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一理念主要是一个<strong>MvpView</strong> (也就是Fragment or Activity)会关联一个<strong>MvpPresenter</strong>，并且管理<strong>MbpPresenter</strong>的声明周期。大家从上面的代码片段可以看到，<strong>Mosby</strong>使用Activity和Fragement生命周期来实现这一目的。通常presenter是绑定在该生命周期上的。所以初始化或者清理一些东西等操作（例如撤销异步运行任务）应该在 <strong>presenter.onAttach()</strong>和 <strong>resenter.onDetach()</strong> 上进行。 <strong>MvpPresenter</strong>是一个interface 。MVP模块提供一个 <strong>MvpBasePresenter</strong>，这个MvpBasePresenter只持有View（是一个Fragment或Activity）的弱引用，从而避免内存泄露。因此，当presenter想要调用view方法时，我们需要查看<strong>isViewAttached()</strong> 并使用<strong>getView()</strong>来获取引用，以检查view是否连接到了presenter。</p>
<p><strong>4.5. Google 官方推荐</strong></p>
<p>大 Boss 总是最后出场，对于 Android 上 MVP 的实现，Google 给也出了一些建议和实例，赶紧看看去吧。</p>
<p><strong>原文</strong>：<a href="https://github.com/googlesamples/android-architecture?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">Android Architecture Blueprints [beta]</a><br><strong>源码</strong>：<a href="https://github.com/googlesamples/android-architecture?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">GitHub 地址</a></p>
<p><img src="https://github.com/googlesamples/android-architecture/wiki/images/tasks2.png" alt=""></p>
<p><strong>Google MVP 示例</strong></p>
<p><strong>4.6. MVP 实现的完整开源项目</strong></p>
<p><strong>Philm</strong></p>
<p><strong>ChrisBannes</strong>的开源项目<strong>Philm</strong>，其整体架构是一套MVP的实现。</p>
<p><strong>Philm 分析</strong>：<a href="http://www.lightskystreet.com/2015/02/10/philm_mvp/" target="_blank" rel="external">开源项目Philm的MVP架构分析</a><br><strong>源码</strong>：<a href="https://github.com/chrisbanes/philm" target="_blank" rel="external">GitHub 地址</a></p>
<p><img src="http://www.lightskystreet.com/img/philm_mvp/philm_mvp_structure.png" alt=""></p>
<p><img src="http://www.lightskystreet.com/img/philm_mvp/philm_mvp_uml.png" alt=""></p>
<p><img src="http://www.lightskystreet.com/img/philm_mvp/mvp_method_flow.png" alt=""></p>
<p><strong>相关文章</strong></p>
<p><a href="http://blog.csdn.net/vector_yi/article/details/24719873" target="_blank" rel="external">http://blog.csdn.net/vector_yi/article/details/24719873</a></p>
<p><a href="http://antonioleiva.com/mvp-android/" target="_blank" rel="external">http://antonioleiva.com/mvp-android/</a></p>
<p><a href="https://github.com/antoniolg/androidmvp" target="_blank" rel="external">https://github.com/antoniolg/androidmvp</a></p>
<p><a href="http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/" target="_blank" rel="external">http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/</a></p>
<p><a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="external">https://github.com/android10/Android-CleanArchitecture</a></p>
<p><a href="http://magenic.com/BlogArchive/AnMVPPatternforAndroid" target="_blank" rel="external">http://magenic.com/BlogArchive/AnMVPPatternforAndroid</a></p>
<p><a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="external">http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html</a></p>
<p><a href="http://blog.csdn.net/xijiaohuangcao/article/details/7925641" target="_blank" rel="external">http://blog.csdn.net/xijiaohuangcao/article/details/7925641</a></p>
<p><a href="https://github.com/pedrovgs/EffectiveAndroidUI/" target="_blank" rel="external">https://github.com/pedrovgs/EffectiveAndroidUI/</a></p>
]]></content>
    </entry>
    
  
  
</search>
